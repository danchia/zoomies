// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: zoomies/zoomies.proto

#include "zoomies/zoomies.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG
namespace zoomies {
constexpr DriverLog::DriverLog(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : imu_accel_(nullptr)
  , imu_rotation_(nullptr)
  , localizer_correction_(nullptr)
  , localizer_variance_(nullptr)
  , t_us_(uint64_t{0u})
  , linear_velocity_(0)
  , angular_velocity_(0)
  , desired_linear_velocity_(0)
  , desired_angular_velocity_(0)
  , heading_(0)
  , x_(0)
  , y_(0)
  , total_distance_(0)
  , racing_path_dist_(0)
  , dist_delta_(0)
  , heading_delta_(0)
  , dist_stddev_(0)
  , heading_stddev_(0)
  , esc_(0)
  , steer_(0)
  , delta_t_s_(0){}
struct DriverLogDefaultTypeInternal {
  constexpr DriverLogDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~DriverLogDefaultTypeInternal() {}
  union {
    DriverLog _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT DriverLogDefaultTypeInternal _DriverLog_default_instance_;
constexpr MotionPlan::MotionPlan(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : path_velocity_(0)
  , path_heading_(0)
  , desired_linear_velocity_(0)
  , lane_gain_(0)
  , delta_heading_(0)
  , lane_delta_(0)
  , delta_(0)
  , desired_angular_velocity_(0)
  , path_dist_to_closest_(0){}
struct MotionPlanDefaultTypeInternal {
  constexpr MotionPlanDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~MotionPlanDefaultTypeInternal() {}
  union {
    MotionPlan _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT MotionPlanDefaultTypeInternal _MotionPlan_default_instance_;
}  // namespace zoomies
static ::PROTOBUF_NAMESPACE_ID::Metadata file_level_metadata_zoomies_2fzoomies_2eproto[2];
static constexpr ::PROTOBUF_NAMESPACE_ID::EnumDescriptor const** file_level_enum_descriptors_zoomies_2fzoomies_2eproto = nullptr;
static constexpr ::PROTOBUF_NAMESPACE_ID::ServiceDescriptor const** file_level_service_descriptors_zoomies_2fzoomies_2eproto = nullptr;

const uint32_t TableStruct_zoomies_2fzoomies_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::zoomies::DriverLog, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::zoomies::DriverLog, t_us_),
  PROTOBUF_FIELD_OFFSET(::zoomies::DriverLog, delta_t_s_),
  PROTOBUF_FIELD_OFFSET(::zoomies::DriverLog, linear_velocity_),
  PROTOBUF_FIELD_OFFSET(::zoomies::DriverLog, angular_velocity_),
  PROTOBUF_FIELD_OFFSET(::zoomies::DriverLog, desired_linear_velocity_),
  PROTOBUF_FIELD_OFFSET(::zoomies::DriverLog, desired_angular_velocity_),
  PROTOBUF_FIELD_OFFSET(::zoomies::DriverLog, heading_),
  PROTOBUF_FIELD_OFFSET(::zoomies::DriverLog, x_),
  PROTOBUF_FIELD_OFFSET(::zoomies::DriverLog, y_),
  PROTOBUF_FIELD_OFFSET(::zoomies::DriverLog, total_distance_),
  PROTOBUF_FIELD_OFFSET(::zoomies::DriverLog, racing_path_dist_),
  PROTOBUF_FIELD_OFFSET(::zoomies::DriverLog, dist_delta_),
  PROTOBUF_FIELD_OFFSET(::zoomies::DriverLog, heading_delta_),
  PROTOBUF_FIELD_OFFSET(::zoomies::DriverLog, dist_stddev_),
  PROTOBUF_FIELD_OFFSET(::zoomies::DriverLog, heading_stddev_),
  PROTOBUF_FIELD_OFFSET(::zoomies::DriverLog, esc_),
  PROTOBUF_FIELD_OFFSET(::zoomies::DriverLog, steer_),
  PROTOBUF_FIELD_OFFSET(::zoomies::DriverLog, imu_accel_),
  PROTOBUF_FIELD_OFFSET(::zoomies::DriverLog, imu_rotation_),
  PROTOBUF_FIELD_OFFSET(::zoomies::DriverLog, localizer_correction_),
  PROTOBUF_FIELD_OFFSET(::zoomies::DriverLog, localizer_variance_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::zoomies::MotionPlan, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::zoomies::MotionPlan, path_velocity_),
  PROTOBUF_FIELD_OFFSET(::zoomies::MotionPlan, path_heading_),
  PROTOBUF_FIELD_OFFSET(::zoomies::MotionPlan, path_dist_to_closest_),
  PROTOBUF_FIELD_OFFSET(::zoomies::MotionPlan, desired_linear_velocity_),
  PROTOBUF_FIELD_OFFSET(::zoomies::MotionPlan, lane_gain_),
  PROTOBUF_FIELD_OFFSET(::zoomies::MotionPlan, delta_heading_),
  PROTOBUF_FIELD_OFFSET(::zoomies::MotionPlan, lane_delta_),
  PROTOBUF_FIELD_OFFSET(::zoomies::MotionPlan, delta_),
  PROTOBUF_FIELD_OFFSET(::zoomies::MotionPlan, desired_angular_velocity_),
};
static const ::PROTOBUF_NAMESPACE_ID::internal::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, -1, -1, sizeof(::zoomies::DriverLog)},
  { 27, -1, -1, sizeof(::zoomies::MotionPlan)},
};

static ::PROTOBUF_NAMESPACE_ID::Message const * const file_default_instances[] = {
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::zoomies::_DriverLog_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::zoomies::_MotionPlan_default_instance_),
};

const char descriptor_table_protodef_zoomies_2fzoomies_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\025zoomies/zoomies.proto\022\007zoomies\032\037ros/ge"
  "ometry_msgs/Vector3.proto\"\302\004\n\tDriverLog\022"
  "\014\n\004t_us\030\001 \001(\006\022\021\n\tdelta_t_s\030\025 \001(\002\022\027\n\017line"
  "ar_velocity\030\002 \001(\002\022\030\n\020angular_velocity\030\003 "
  "\001(\002\022\037\n\027desired_linear_velocity\030\004 \001(\002\022 \n\030"
  "desired_angular_velocity\030\005 \001(\002\022\017\n\007headin"
  "g\030\006 \001(\002\022\t\n\001x\030\007 \001(\002\022\t\n\001y\030\010 \001(\002\022\026\n\016total_d"
  "istance\030\t \001(\002\022\030\n\020racing_path_dist\030\n \001(\002\022"
  "\022\n\ndist_delta\030\013 \001(\002\022\025\n\rheading_delta\030\014 \001"
  "(\002\022\023\n\013dist_stddev\030\r \001(\002\022\026\n\016heading_stdde"
  "v\030\016 \001(\002\022\013\n\003esc\030\017 \001(\002\022\r\n\005steer\030\020 \001(\002\022-\n\ti"
  "mu_accel\030\021 \001(\0132\032.ros.geometry_msgs.Vecto"
  "r3\0220\n\014imu_rotation\030\022 \001(\0132\032.ros.geometry_"
  "msgs.Vector3\0228\n\024localizer_correction\030\023 \001"
  "(\0132\032.ros.geometry_msgs.Vector3\0226\n\022locali"
  "zer_variance\030\024 \001(\0132\032.ros.geometry_msgs.V"
  "ector3\"\347\001\n\nMotionPlan\022\025\n\rpath_velocity\030\001"
  " \001(\002\022\024\n\014path_heading\030\002 \001(\002\022\034\n\024path_dist_"
  "to_closest\030\t \001(\002\022\037\n\027desired_linear_veloc"
  "ity\030\003 \001(\002\022\021\n\tlane_gain\030\004 \001(\002\022\025\n\rdelta_he"
  "ading\030\005 \001(\002\022\022\n\nlane_delta\030\006 \001(\002\022\r\n\005delta"
  "\030\007 \001(\002\022 \n\030desired_angular_velocity\030\010 \001(\002"
  "b\006proto3"
  ;
static const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable*const descriptor_table_zoomies_2fzoomies_2eproto_deps[1] = {
  &::descriptor_table_ros_2fgeometry_5fmsgs_2fVector3_2eproto,
};
static ::PROTOBUF_NAMESPACE_ID::internal::once_flag descriptor_table_zoomies_2fzoomies_2eproto_once;
const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_zoomies_2fzoomies_2eproto = {
  false, false, 888, descriptor_table_protodef_zoomies_2fzoomies_2eproto, "zoomies/zoomies.proto", 
  &descriptor_table_zoomies_2fzoomies_2eproto_once, descriptor_table_zoomies_2fzoomies_2eproto_deps, 1, 2,
  schemas, file_default_instances, TableStruct_zoomies_2fzoomies_2eproto::offsets,
  file_level_metadata_zoomies_2fzoomies_2eproto, file_level_enum_descriptors_zoomies_2fzoomies_2eproto, file_level_service_descriptors_zoomies_2fzoomies_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable* descriptor_table_zoomies_2fzoomies_2eproto_getter() {
  return &descriptor_table_zoomies_2fzoomies_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY static ::PROTOBUF_NAMESPACE_ID::internal::AddDescriptorsRunner dynamic_init_dummy_zoomies_2fzoomies_2eproto(&descriptor_table_zoomies_2fzoomies_2eproto);
namespace zoomies {

// ===================================================================

class DriverLog::_Internal {
 public:
  static const ::ros::geometry_msgs::Vector3& imu_accel(const DriverLog* msg);
  static const ::ros::geometry_msgs::Vector3& imu_rotation(const DriverLog* msg);
  static const ::ros::geometry_msgs::Vector3& localizer_correction(const DriverLog* msg);
  static const ::ros::geometry_msgs::Vector3& localizer_variance(const DriverLog* msg);
};

const ::ros::geometry_msgs::Vector3&
DriverLog::_Internal::imu_accel(const DriverLog* msg) {
  return *msg->imu_accel_;
}
const ::ros::geometry_msgs::Vector3&
DriverLog::_Internal::imu_rotation(const DriverLog* msg) {
  return *msg->imu_rotation_;
}
const ::ros::geometry_msgs::Vector3&
DriverLog::_Internal::localizer_correction(const DriverLog* msg) {
  return *msg->localizer_correction_;
}
const ::ros::geometry_msgs::Vector3&
DriverLog::_Internal::localizer_variance(const DriverLog* msg) {
  return *msg->localizer_variance_;
}
void DriverLog::clear_imu_accel() {
  if (GetArenaForAllocation() == nullptr && imu_accel_ != nullptr) {
    delete imu_accel_;
  }
  imu_accel_ = nullptr;
}
void DriverLog::clear_imu_rotation() {
  if (GetArenaForAllocation() == nullptr && imu_rotation_ != nullptr) {
    delete imu_rotation_;
  }
  imu_rotation_ = nullptr;
}
void DriverLog::clear_localizer_correction() {
  if (GetArenaForAllocation() == nullptr && localizer_correction_ != nullptr) {
    delete localizer_correction_;
  }
  localizer_correction_ = nullptr;
}
void DriverLog::clear_localizer_variance() {
  if (GetArenaForAllocation() == nullptr && localizer_variance_ != nullptr) {
    delete localizer_variance_;
  }
  localizer_variance_ = nullptr;
}
DriverLog::DriverLog(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:zoomies.DriverLog)
}
DriverLog::DriverLog(const DriverLog& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_imu_accel()) {
    imu_accel_ = new ::ros::geometry_msgs::Vector3(*from.imu_accel_);
  } else {
    imu_accel_ = nullptr;
  }
  if (from._internal_has_imu_rotation()) {
    imu_rotation_ = new ::ros::geometry_msgs::Vector3(*from.imu_rotation_);
  } else {
    imu_rotation_ = nullptr;
  }
  if (from._internal_has_localizer_correction()) {
    localizer_correction_ = new ::ros::geometry_msgs::Vector3(*from.localizer_correction_);
  } else {
    localizer_correction_ = nullptr;
  }
  if (from._internal_has_localizer_variance()) {
    localizer_variance_ = new ::ros::geometry_msgs::Vector3(*from.localizer_variance_);
  } else {
    localizer_variance_ = nullptr;
  }
  ::memcpy(&t_us_, &from.t_us_,
    static_cast<size_t>(reinterpret_cast<char*>(&delta_t_s_) -
    reinterpret_cast<char*>(&t_us_)) + sizeof(delta_t_s_));
  // @@protoc_insertion_point(copy_constructor:zoomies.DriverLog)
}

inline void DriverLog::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&imu_accel_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&delta_t_s_) -
    reinterpret_cast<char*>(&imu_accel_)) + sizeof(delta_t_s_));
}

DriverLog::~DriverLog() {
  // @@protoc_insertion_point(destructor:zoomies.DriverLog)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void DriverLog::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete imu_accel_;
  if (this != internal_default_instance()) delete imu_rotation_;
  if (this != internal_default_instance()) delete localizer_correction_;
  if (this != internal_default_instance()) delete localizer_variance_;
}

void DriverLog::ArenaDtor(void* object) {
  DriverLog* _this = reinterpret_cast< DriverLog* >(object);
  (void)_this;
}
void DriverLog::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void DriverLog::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void DriverLog::Clear() {
// @@protoc_insertion_point(message_clear_start:zoomies.DriverLog)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && imu_accel_ != nullptr) {
    delete imu_accel_;
  }
  imu_accel_ = nullptr;
  if (GetArenaForAllocation() == nullptr && imu_rotation_ != nullptr) {
    delete imu_rotation_;
  }
  imu_rotation_ = nullptr;
  if (GetArenaForAllocation() == nullptr && localizer_correction_ != nullptr) {
    delete localizer_correction_;
  }
  localizer_correction_ = nullptr;
  if (GetArenaForAllocation() == nullptr && localizer_variance_ != nullptr) {
    delete localizer_variance_;
  }
  localizer_variance_ = nullptr;
  ::memset(&t_us_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&delta_t_s_) -
      reinterpret_cast<char*>(&t_us_)) + sizeof(delta_t_s_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* DriverLog::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // fixed64 t_us = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 9)) {
          t_us_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint64_t>(ptr);
          ptr += sizeof(uint64_t);
        } else
          goto handle_unusual;
        continue;
      // float linear_velocity = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          linear_velocity_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float angular_velocity = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 29)) {
          angular_velocity_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float desired_linear_velocity = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 37)) {
          desired_linear_velocity_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float desired_angular_velocity = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 45)) {
          desired_angular_velocity_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float heading = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 53)) {
          heading_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float x = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 61)) {
          x_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float y = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 69)) {
          y_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float total_distance = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 77)) {
          total_distance_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float racing_path_dist = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 85)) {
          racing_path_dist_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float dist_delta = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 93)) {
          dist_delta_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float heading_delta = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 101)) {
          heading_delta_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float dist_stddev = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 109)) {
          dist_stddev_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float heading_stddev = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 117)) {
          heading_stddev_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float esc = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 125)) {
          esc_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float steer = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 133)) {
          steer_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // .ros.geometry_msgs.Vector3 imu_accel = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 138)) {
          ptr = ctx->ParseMessage(_internal_mutable_imu_accel(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .ros.geometry_msgs.Vector3 imu_rotation = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 146)) {
          ptr = ctx->ParseMessage(_internal_mutable_imu_rotation(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .ros.geometry_msgs.Vector3 localizer_correction = 19;
      case 19:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 154)) {
          ptr = ctx->ParseMessage(_internal_mutable_localizer_correction(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .ros.geometry_msgs.Vector3 localizer_variance = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 162)) {
          ptr = ctx->ParseMessage(_internal_mutable_localizer_variance(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // float delta_t_s = 21;
      case 21:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 173)) {
          delta_t_s_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DriverLog::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:zoomies.DriverLog)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // fixed64 t_us = 1;
  if (this->_internal_t_us() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFixed64ToArray(1, this->_internal_t_us(), target);
  }

  // float linear_velocity = 2;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_linear_velocity = this->_internal_linear_velocity();
  uint32_t raw_linear_velocity;
  memcpy(&raw_linear_velocity, &tmp_linear_velocity, sizeof(tmp_linear_velocity));
  if (raw_linear_velocity != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(2, this->_internal_linear_velocity(), target);
  }

  // float angular_velocity = 3;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_angular_velocity = this->_internal_angular_velocity();
  uint32_t raw_angular_velocity;
  memcpy(&raw_angular_velocity, &tmp_angular_velocity, sizeof(tmp_angular_velocity));
  if (raw_angular_velocity != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(3, this->_internal_angular_velocity(), target);
  }

  // float desired_linear_velocity = 4;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_desired_linear_velocity = this->_internal_desired_linear_velocity();
  uint32_t raw_desired_linear_velocity;
  memcpy(&raw_desired_linear_velocity, &tmp_desired_linear_velocity, sizeof(tmp_desired_linear_velocity));
  if (raw_desired_linear_velocity != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(4, this->_internal_desired_linear_velocity(), target);
  }

  // float desired_angular_velocity = 5;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_desired_angular_velocity = this->_internal_desired_angular_velocity();
  uint32_t raw_desired_angular_velocity;
  memcpy(&raw_desired_angular_velocity, &tmp_desired_angular_velocity, sizeof(tmp_desired_angular_velocity));
  if (raw_desired_angular_velocity != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(5, this->_internal_desired_angular_velocity(), target);
  }

  // float heading = 6;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_heading = this->_internal_heading();
  uint32_t raw_heading;
  memcpy(&raw_heading, &tmp_heading, sizeof(tmp_heading));
  if (raw_heading != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(6, this->_internal_heading(), target);
  }

  // float x = 7;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_x = this->_internal_x();
  uint32_t raw_x;
  memcpy(&raw_x, &tmp_x, sizeof(tmp_x));
  if (raw_x != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(7, this->_internal_x(), target);
  }

  // float y = 8;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_y = this->_internal_y();
  uint32_t raw_y;
  memcpy(&raw_y, &tmp_y, sizeof(tmp_y));
  if (raw_y != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(8, this->_internal_y(), target);
  }

  // float total_distance = 9;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_total_distance = this->_internal_total_distance();
  uint32_t raw_total_distance;
  memcpy(&raw_total_distance, &tmp_total_distance, sizeof(tmp_total_distance));
  if (raw_total_distance != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(9, this->_internal_total_distance(), target);
  }

  // float racing_path_dist = 10;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_racing_path_dist = this->_internal_racing_path_dist();
  uint32_t raw_racing_path_dist;
  memcpy(&raw_racing_path_dist, &tmp_racing_path_dist, sizeof(tmp_racing_path_dist));
  if (raw_racing_path_dist != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(10, this->_internal_racing_path_dist(), target);
  }

  // float dist_delta = 11;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_dist_delta = this->_internal_dist_delta();
  uint32_t raw_dist_delta;
  memcpy(&raw_dist_delta, &tmp_dist_delta, sizeof(tmp_dist_delta));
  if (raw_dist_delta != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(11, this->_internal_dist_delta(), target);
  }

  // float heading_delta = 12;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_heading_delta = this->_internal_heading_delta();
  uint32_t raw_heading_delta;
  memcpy(&raw_heading_delta, &tmp_heading_delta, sizeof(tmp_heading_delta));
  if (raw_heading_delta != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(12, this->_internal_heading_delta(), target);
  }

  // float dist_stddev = 13;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_dist_stddev = this->_internal_dist_stddev();
  uint32_t raw_dist_stddev;
  memcpy(&raw_dist_stddev, &tmp_dist_stddev, sizeof(tmp_dist_stddev));
  if (raw_dist_stddev != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(13, this->_internal_dist_stddev(), target);
  }

  // float heading_stddev = 14;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_heading_stddev = this->_internal_heading_stddev();
  uint32_t raw_heading_stddev;
  memcpy(&raw_heading_stddev, &tmp_heading_stddev, sizeof(tmp_heading_stddev));
  if (raw_heading_stddev != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(14, this->_internal_heading_stddev(), target);
  }

  // float esc = 15;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_esc = this->_internal_esc();
  uint32_t raw_esc;
  memcpy(&raw_esc, &tmp_esc, sizeof(tmp_esc));
  if (raw_esc != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(15, this->_internal_esc(), target);
  }

  // float steer = 16;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_steer = this->_internal_steer();
  uint32_t raw_steer;
  memcpy(&raw_steer, &tmp_steer, sizeof(tmp_steer));
  if (raw_steer != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(16, this->_internal_steer(), target);
  }

  // .ros.geometry_msgs.Vector3 imu_accel = 17;
  if (this->_internal_has_imu_accel()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        17, _Internal::imu_accel(this), target, stream);
  }

  // .ros.geometry_msgs.Vector3 imu_rotation = 18;
  if (this->_internal_has_imu_rotation()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        18, _Internal::imu_rotation(this), target, stream);
  }

  // .ros.geometry_msgs.Vector3 localizer_correction = 19;
  if (this->_internal_has_localizer_correction()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        19, _Internal::localizer_correction(this), target, stream);
  }

  // .ros.geometry_msgs.Vector3 localizer_variance = 20;
  if (this->_internal_has_localizer_variance()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        20, _Internal::localizer_variance(this), target, stream);
  }

  // float delta_t_s = 21;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_delta_t_s = this->_internal_delta_t_s();
  uint32_t raw_delta_t_s;
  memcpy(&raw_delta_t_s, &tmp_delta_t_s, sizeof(tmp_delta_t_s));
  if (raw_delta_t_s != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(21, this->_internal_delta_t_s(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:zoomies.DriverLog)
  return target;
}

size_t DriverLog::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:zoomies.DriverLog)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .ros.geometry_msgs.Vector3 imu_accel = 17;
  if (this->_internal_has_imu_accel()) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *imu_accel_);
  }

  // .ros.geometry_msgs.Vector3 imu_rotation = 18;
  if (this->_internal_has_imu_rotation()) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *imu_rotation_);
  }

  // .ros.geometry_msgs.Vector3 localizer_correction = 19;
  if (this->_internal_has_localizer_correction()) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *localizer_correction_);
  }

  // .ros.geometry_msgs.Vector3 localizer_variance = 20;
  if (this->_internal_has_localizer_variance()) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *localizer_variance_);
  }

  // fixed64 t_us = 1;
  if (this->_internal_t_us() != 0) {
    total_size += 1 + 8;
  }

  // float linear_velocity = 2;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_linear_velocity = this->_internal_linear_velocity();
  uint32_t raw_linear_velocity;
  memcpy(&raw_linear_velocity, &tmp_linear_velocity, sizeof(tmp_linear_velocity));
  if (raw_linear_velocity != 0) {
    total_size += 1 + 4;
  }

  // float angular_velocity = 3;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_angular_velocity = this->_internal_angular_velocity();
  uint32_t raw_angular_velocity;
  memcpy(&raw_angular_velocity, &tmp_angular_velocity, sizeof(tmp_angular_velocity));
  if (raw_angular_velocity != 0) {
    total_size += 1 + 4;
  }

  // float desired_linear_velocity = 4;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_desired_linear_velocity = this->_internal_desired_linear_velocity();
  uint32_t raw_desired_linear_velocity;
  memcpy(&raw_desired_linear_velocity, &tmp_desired_linear_velocity, sizeof(tmp_desired_linear_velocity));
  if (raw_desired_linear_velocity != 0) {
    total_size += 1 + 4;
  }

  // float desired_angular_velocity = 5;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_desired_angular_velocity = this->_internal_desired_angular_velocity();
  uint32_t raw_desired_angular_velocity;
  memcpy(&raw_desired_angular_velocity, &tmp_desired_angular_velocity, sizeof(tmp_desired_angular_velocity));
  if (raw_desired_angular_velocity != 0) {
    total_size += 1 + 4;
  }

  // float heading = 6;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_heading = this->_internal_heading();
  uint32_t raw_heading;
  memcpy(&raw_heading, &tmp_heading, sizeof(tmp_heading));
  if (raw_heading != 0) {
    total_size += 1 + 4;
  }

  // float x = 7;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_x = this->_internal_x();
  uint32_t raw_x;
  memcpy(&raw_x, &tmp_x, sizeof(tmp_x));
  if (raw_x != 0) {
    total_size += 1 + 4;
  }

  // float y = 8;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_y = this->_internal_y();
  uint32_t raw_y;
  memcpy(&raw_y, &tmp_y, sizeof(tmp_y));
  if (raw_y != 0) {
    total_size += 1 + 4;
  }

  // float total_distance = 9;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_total_distance = this->_internal_total_distance();
  uint32_t raw_total_distance;
  memcpy(&raw_total_distance, &tmp_total_distance, sizeof(tmp_total_distance));
  if (raw_total_distance != 0) {
    total_size += 1 + 4;
  }

  // float racing_path_dist = 10;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_racing_path_dist = this->_internal_racing_path_dist();
  uint32_t raw_racing_path_dist;
  memcpy(&raw_racing_path_dist, &tmp_racing_path_dist, sizeof(tmp_racing_path_dist));
  if (raw_racing_path_dist != 0) {
    total_size += 1 + 4;
  }

  // float dist_delta = 11;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_dist_delta = this->_internal_dist_delta();
  uint32_t raw_dist_delta;
  memcpy(&raw_dist_delta, &tmp_dist_delta, sizeof(tmp_dist_delta));
  if (raw_dist_delta != 0) {
    total_size += 1 + 4;
  }

  // float heading_delta = 12;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_heading_delta = this->_internal_heading_delta();
  uint32_t raw_heading_delta;
  memcpy(&raw_heading_delta, &tmp_heading_delta, sizeof(tmp_heading_delta));
  if (raw_heading_delta != 0) {
    total_size += 1 + 4;
  }

  // float dist_stddev = 13;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_dist_stddev = this->_internal_dist_stddev();
  uint32_t raw_dist_stddev;
  memcpy(&raw_dist_stddev, &tmp_dist_stddev, sizeof(tmp_dist_stddev));
  if (raw_dist_stddev != 0) {
    total_size += 1 + 4;
  }

  // float heading_stddev = 14;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_heading_stddev = this->_internal_heading_stddev();
  uint32_t raw_heading_stddev;
  memcpy(&raw_heading_stddev, &tmp_heading_stddev, sizeof(tmp_heading_stddev));
  if (raw_heading_stddev != 0) {
    total_size += 1 + 4;
  }

  // float esc = 15;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_esc = this->_internal_esc();
  uint32_t raw_esc;
  memcpy(&raw_esc, &tmp_esc, sizeof(tmp_esc));
  if (raw_esc != 0) {
    total_size += 1 + 4;
  }

  // float steer = 16;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_steer = this->_internal_steer();
  uint32_t raw_steer;
  memcpy(&raw_steer, &tmp_steer, sizeof(tmp_steer));
  if (raw_steer != 0) {
    total_size += 2 + 4;
  }

  // float delta_t_s = 21;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_delta_t_s = this->_internal_delta_t_s();
  uint32_t raw_delta_t_s;
  memcpy(&raw_delta_t_s, &tmp_delta_t_s, sizeof(tmp_delta_t_s));
  if (raw_delta_t_s != 0) {
    total_size += 2 + 4;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData DriverLog::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    DriverLog::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*DriverLog::GetClassData() const { return &_class_data_; }

void DriverLog::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<DriverLog *>(to)->MergeFrom(
      static_cast<const DriverLog &>(from));
}


void DriverLog::MergeFrom(const DriverLog& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:zoomies.DriverLog)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_imu_accel()) {
    _internal_mutable_imu_accel()->::ros::geometry_msgs::Vector3::MergeFrom(from._internal_imu_accel());
  }
  if (from._internal_has_imu_rotation()) {
    _internal_mutable_imu_rotation()->::ros::geometry_msgs::Vector3::MergeFrom(from._internal_imu_rotation());
  }
  if (from._internal_has_localizer_correction()) {
    _internal_mutable_localizer_correction()->::ros::geometry_msgs::Vector3::MergeFrom(from._internal_localizer_correction());
  }
  if (from._internal_has_localizer_variance()) {
    _internal_mutable_localizer_variance()->::ros::geometry_msgs::Vector3::MergeFrom(from._internal_localizer_variance());
  }
  if (from._internal_t_us() != 0) {
    _internal_set_t_us(from._internal_t_us());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_linear_velocity = from._internal_linear_velocity();
  uint32_t raw_linear_velocity;
  memcpy(&raw_linear_velocity, &tmp_linear_velocity, sizeof(tmp_linear_velocity));
  if (raw_linear_velocity != 0) {
    _internal_set_linear_velocity(from._internal_linear_velocity());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_angular_velocity = from._internal_angular_velocity();
  uint32_t raw_angular_velocity;
  memcpy(&raw_angular_velocity, &tmp_angular_velocity, sizeof(tmp_angular_velocity));
  if (raw_angular_velocity != 0) {
    _internal_set_angular_velocity(from._internal_angular_velocity());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_desired_linear_velocity = from._internal_desired_linear_velocity();
  uint32_t raw_desired_linear_velocity;
  memcpy(&raw_desired_linear_velocity, &tmp_desired_linear_velocity, sizeof(tmp_desired_linear_velocity));
  if (raw_desired_linear_velocity != 0) {
    _internal_set_desired_linear_velocity(from._internal_desired_linear_velocity());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_desired_angular_velocity = from._internal_desired_angular_velocity();
  uint32_t raw_desired_angular_velocity;
  memcpy(&raw_desired_angular_velocity, &tmp_desired_angular_velocity, sizeof(tmp_desired_angular_velocity));
  if (raw_desired_angular_velocity != 0) {
    _internal_set_desired_angular_velocity(from._internal_desired_angular_velocity());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_heading = from._internal_heading();
  uint32_t raw_heading;
  memcpy(&raw_heading, &tmp_heading, sizeof(tmp_heading));
  if (raw_heading != 0) {
    _internal_set_heading(from._internal_heading());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_x = from._internal_x();
  uint32_t raw_x;
  memcpy(&raw_x, &tmp_x, sizeof(tmp_x));
  if (raw_x != 0) {
    _internal_set_x(from._internal_x());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_y = from._internal_y();
  uint32_t raw_y;
  memcpy(&raw_y, &tmp_y, sizeof(tmp_y));
  if (raw_y != 0) {
    _internal_set_y(from._internal_y());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_total_distance = from._internal_total_distance();
  uint32_t raw_total_distance;
  memcpy(&raw_total_distance, &tmp_total_distance, sizeof(tmp_total_distance));
  if (raw_total_distance != 0) {
    _internal_set_total_distance(from._internal_total_distance());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_racing_path_dist = from._internal_racing_path_dist();
  uint32_t raw_racing_path_dist;
  memcpy(&raw_racing_path_dist, &tmp_racing_path_dist, sizeof(tmp_racing_path_dist));
  if (raw_racing_path_dist != 0) {
    _internal_set_racing_path_dist(from._internal_racing_path_dist());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_dist_delta = from._internal_dist_delta();
  uint32_t raw_dist_delta;
  memcpy(&raw_dist_delta, &tmp_dist_delta, sizeof(tmp_dist_delta));
  if (raw_dist_delta != 0) {
    _internal_set_dist_delta(from._internal_dist_delta());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_heading_delta = from._internal_heading_delta();
  uint32_t raw_heading_delta;
  memcpy(&raw_heading_delta, &tmp_heading_delta, sizeof(tmp_heading_delta));
  if (raw_heading_delta != 0) {
    _internal_set_heading_delta(from._internal_heading_delta());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_dist_stddev = from._internal_dist_stddev();
  uint32_t raw_dist_stddev;
  memcpy(&raw_dist_stddev, &tmp_dist_stddev, sizeof(tmp_dist_stddev));
  if (raw_dist_stddev != 0) {
    _internal_set_dist_stddev(from._internal_dist_stddev());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_heading_stddev = from._internal_heading_stddev();
  uint32_t raw_heading_stddev;
  memcpy(&raw_heading_stddev, &tmp_heading_stddev, sizeof(tmp_heading_stddev));
  if (raw_heading_stddev != 0) {
    _internal_set_heading_stddev(from._internal_heading_stddev());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_esc = from._internal_esc();
  uint32_t raw_esc;
  memcpy(&raw_esc, &tmp_esc, sizeof(tmp_esc));
  if (raw_esc != 0) {
    _internal_set_esc(from._internal_esc());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_steer = from._internal_steer();
  uint32_t raw_steer;
  memcpy(&raw_steer, &tmp_steer, sizeof(tmp_steer));
  if (raw_steer != 0) {
    _internal_set_steer(from._internal_steer());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_delta_t_s = from._internal_delta_t_s();
  uint32_t raw_delta_t_s;
  memcpy(&raw_delta_t_s, &tmp_delta_t_s, sizeof(tmp_delta_t_s));
  if (raw_delta_t_s != 0) {
    _internal_set_delta_t_s(from._internal_delta_t_s());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void DriverLog::CopyFrom(const DriverLog& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:zoomies.DriverLog)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DriverLog::IsInitialized() const {
  return true;
}

void DriverLog::InternalSwap(DriverLog* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(DriverLog, delta_t_s_)
      + sizeof(DriverLog::delta_t_s_)
      - PROTOBUF_FIELD_OFFSET(DriverLog, imu_accel_)>(
          reinterpret_cast<char*>(&imu_accel_),
          reinterpret_cast<char*>(&other->imu_accel_));
}

::PROTOBUF_NAMESPACE_ID::Metadata DriverLog::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_zoomies_2fzoomies_2eproto_getter, &descriptor_table_zoomies_2fzoomies_2eproto_once,
      file_level_metadata_zoomies_2fzoomies_2eproto[0]);
}

// ===================================================================

class MotionPlan::_Internal {
 public:
};

MotionPlan::MotionPlan(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:zoomies.MotionPlan)
}
MotionPlan::MotionPlan(const MotionPlan& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&path_velocity_, &from.path_velocity_,
    static_cast<size_t>(reinterpret_cast<char*>(&path_dist_to_closest_) -
    reinterpret_cast<char*>(&path_velocity_)) + sizeof(path_dist_to_closest_));
  // @@protoc_insertion_point(copy_constructor:zoomies.MotionPlan)
}

inline void MotionPlan::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&path_velocity_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&path_dist_to_closest_) -
    reinterpret_cast<char*>(&path_velocity_)) + sizeof(path_dist_to_closest_));
}

MotionPlan::~MotionPlan() {
  // @@protoc_insertion_point(destructor:zoomies.MotionPlan)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void MotionPlan::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void MotionPlan::ArenaDtor(void* object) {
  MotionPlan* _this = reinterpret_cast< MotionPlan* >(object);
  (void)_this;
}
void MotionPlan::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void MotionPlan::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void MotionPlan::Clear() {
// @@protoc_insertion_point(message_clear_start:zoomies.MotionPlan)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&path_velocity_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&path_dist_to_closest_) -
      reinterpret_cast<char*>(&path_velocity_)) + sizeof(path_dist_to_closest_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* MotionPlan::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // float path_velocity = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 13)) {
          path_velocity_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float path_heading = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          path_heading_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float desired_linear_velocity = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 29)) {
          desired_linear_velocity_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float lane_gain = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 37)) {
          lane_gain_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float delta_heading = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 45)) {
          delta_heading_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float lane_delta = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 53)) {
          lane_delta_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float delta = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 61)) {
          delta_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float desired_angular_velocity = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 69)) {
          desired_angular_velocity_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float path_dist_to_closest = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 77)) {
          path_dist_to_closest_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* MotionPlan::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:zoomies.MotionPlan)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // float path_velocity = 1;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_path_velocity = this->_internal_path_velocity();
  uint32_t raw_path_velocity;
  memcpy(&raw_path_velocity, &tmp_path_velocity, sizeof(tmp_path_velocity));
  if (raw_path_velocity != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(1, this->_internal_path_velocity(), target);
  }

  // float path_heading = 2;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_path_heading = this->_internal_path_heading();
  uint32_t raw_path_heading;
  memcpy(&raw_path_heading, &tmp_path_heading, sizeof(tmp_path_heading));
  if (raw_path_heading != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(2, this->_internal_path_heading(), target);
  }

  // float desired_linear_velocity = 3;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_desired_linear_velocity = this->_internal_desired_linear_velocity();
  uint32_t raw_desired_linear_velocity;
  memcpy(&raw_desired_linear_velocity, &tmp_desired_linear_velocity, sizeof(tmp_desired_linear_velocity));
  if (raw_desired_linear_velocity != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(3, this->_internal_desired_linear_velocity(), target);
  }

  // float lane_gain = 4;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_lane_gain = this->_internal_lane_gain();
  uint32_t raw_lane_gain;
  memcpy(&raw_lane_gain, &tmp_lane_gain, sizeof(tmp_lane_gain));
  if (raw_lane_gain != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(4, this->_internal_lane_gain(), target);
  }

  // float delta_heading = 5;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_delta_heading = this->_internal_delta_heading();
  uint32_t raw_delta_heading;
  memcpy(&raw_delta_heading, &tmp_delta_heading, sizeof(tmp_delta_heading));
  if (raw_delta_heading != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(5, this->_internal_delta_heading(), target);
  }

  // float lane_delta = 6;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_lane_delta = this->_internal_lane_delta();
  uint32_t raw_lane_delta;
  memcpy(&raw_lane_delta, &tmp_lane_delta, sizeof(tmp_lane_delta));
  if (raw_lane_delta != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(6, this->_internal_lane_delta(), target);
  }

  // float delta = 7;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_delta = this->_internal_delta();
  uint32_t raw_delta;
  memcpy(&raw_delta, &tmp_delta, sizeof(tmp_delta));
  if (raw_delta != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(7, this->_internal_delta(), target);
  }

  // float desired_angular_velocity = 8;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_desired_angular_velocity = this->_internal_desired_angular_velocity();
  uint32_t raw_desired_angular_velocity;
  memcpy(&raw_desired_angular_velocity, &tmp_desired_angular_velocity, sizeof(tmp_desired_angular_velocity));
  if (raw_desired_angular_velocity != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(8, this->_internal_desired_angular_velocity(), target);
  }

  // float path_dist_to_closest = 9;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_path_dist_to_closest = this->_internal_path_dist_to_closest();
  uint32_t raw_path_dist_to_closest;
  memcpy(&raw_path_dist_to_closest, &tmp_path_dist_to_closest, sizeof(tmp_path_dist_to_closest));
  if (raw_path_dist_to_closest != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(9, this->_internal_path_dist_to_closest(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:zoomies.MotionPlan)
  return target;
}

size_t MotionPlan::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:zoomies.MotionPlan)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // float path_velocity = 1;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_path_velocity = this->_internal_path_velocity();
  uint32_t raw_path_velocity;
  memcpy(&raw_path_velocity, &tmp_path_velocity, sizeof(tmp_path_velocity));
  if (raw_path_velocity != 0) {
    total_size += 1 + 4;
  }

  // float path_heading = 2;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_path_heading = this->_internal_path_heading();
  uint32_t raw_path_heading;
  memcpy(&raw_path_heading, &tmp_path_heading, sizeof(tmp_path_heading));
  if (raw_path_heading != 0) {
    total_size += 1 + 4;
  }

  // float desired_linear_velocity = 3;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_desired_linear_velocity = this->_internal_desired_linear_velocity();
  uint32_t raw_desired_linear_velocity;
  memcpy(&raw_desired_linear_velocity, &tmp_desired_linear_velocity, sizeof(tmp_desired_linear_velocity));
  if (raw_desired_linear_velocity != 0) {
    total_size += 1 + 4;
  }

  // float lane_gain = 4;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_lane_gain = this->_internal_lane_gain();
  uint32_t raw_lane_gain;
  memcpy(&raw_lane_gain, &tmp_lane_gain, sizeof(tmp_lane_gain));
  if (raw_lane_gain != 0) {
    total_size += 1 + 4;
  }

  // float delta_heading = 5;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_delta_heading = this->_internal_delta_heading();
  uint32_t raw_delta_heading;
  memcpy(&raw_delta_heading, &tmp_delta_heading, sizeof(tmp_delta_heading));
  if (raw_delta_heading != 0) {
    total_size += 1 + 4;
  }

  // float lane_delta = 6;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_lane_delta = this->_internal_lane_delta();
  uint32_t raw_lane_delta;
  memcpy(&raw_lane_delta, &tmp_lane_delta, sizeof(tmp_lane_delta));
  if (raw_lane_delta != 0) {
    total_size += 1 + 4;
  }

  // float delta = 7;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_delta = this->_internal_delta();
  uint32_t raw_delta;
  memcpy(&raw_delta, &tmp_delta, sizeof(tmp_delta));
  if (raw_delta != 0) {
    total_size += 1 + 4;
  }

  // float desired_angular_velocity = 8;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_desired_angular_velocity = this->_internal_desired_angular_velocity();
  uint32_t raw_desired_angular_velocity;
  memcpy(&raw_desired_angular_velocity, &tmp_desired_angular_velocity, sizeof(tmp_desired_angular_velocity));
  if (raw_desired_angular_velocity != 0) {
    total_size += 1 + 4;
  }

  // float path_dist_to_closest = 9;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_path_dist_to_closest = this->_internal_path_dist_to_closest();
  uint32_t raw_path_dist_to_closest;
  memcpy(&raw_path_dist_to_closest, &tmp_path_dist_to_closest, sizeof(tmp_path_dist_to_closest));
  if (raw_path_dist_to_closest != 0) {
    total_size += 1 + 4;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData MotionPlan::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    MotionPlan::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*MotionPlan::GetClassData() const { return &_class_data_; }

void MotionPlan::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<MotionPlan *>(to)->MergeFrom(
      static_cast<const MotionPlan &>(from));
}


void MotionPlan::MergeFrom(const MotionPlan& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:zoomies.MotionPlan)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_path_velocity = from._internal_path_velocity();
  uint32_t raw_path_velocity;
  memcpy(&raw_path_velocity, &tmp_path_velocity, sizeof(tmp_path_velocity));
  if (raw_path_velocity != 0) {
    _internal_set_path_velocity(from._internal_path_velocity());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_path_heading = from._internal_path_heading();
  uint32_t raw_path_heading;
  memcpy(&raw_path_heading, &tmp_path_heading, sizeof(tmp_path_heading));
  if (raw_path_heading != 0) {
    _internal_set_path_heading(from._internal_path_heading());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_desired_linear_velocity = from._internal_desired_linear_velocity();
  uint32_t raw_desired_linear_velocity;
  memcpy(&raw_desired_linear_velocity, &tmp_desired_linear_velocity, sizeof(tmp_desired_linear_velocity));
  if (raw_desired_linear_velocity != 0) {
    _internal_set_desired_linear_velocity(from._internal_desired_linear_velocity());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_lane_gain = from._internal_lane_gain();
  uint32_t raw_lane_gain;
  memcpy(&raw_lane_gain, &tmp_lane_gain, sizeof(tmp_lane_gain));
  if (raw_lane_gain != 0) {
    _internal_set_lane_gain(from._internal_lane_gain());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_delta_heading = from._internal_delta_heading();
  uint32_t raw_delta_heading;
  memcpy(&raw_delta_heading, &tmp_delta_heading, sizeof(tmp_delta_heading));
  if (raw_delta_heading != 0) {
    _internal_set_delta_heading(from._internal_delta_heading());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_lane_delta = from._internal_lane_delta();
  uint32_t raw_lane_delta;
  memcpy(&raw_lane_delta, &tmp_lane_delta, sizeof(tmp_lane_delta));
  if (raw_lane_delta != 0) {
    _internal_set_lane_delta(from._internal_lane_delta());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_delta = from._internal_delta();
  uint32_t raw_delta;
  memcpy(&raw_delta, &tmp_delta, sizeof(tmp_delta));
  if (raw_delta != 0) {
    _internal_set_delta(from._internal_delta());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_desired_angular_velocity = from._internal_desired_angular_velocity();
  uint32_t raw_desired_angular_velocity;
  memcpy(&raw_desired_angular_velocity, &tmp_desired_angular_velocity, sizeof(tmp_desired_angular_velocity));
  if (raw_desired_angular_velocity != 0) {
    _internal_set_desired_angular_velocity(from._internal_desired_angular_velocity());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_path_dist_to_closest = from._internal_path_dist_to_closest();
  uint32_t raw_path_dist_to_closest;
  memcpy(&raw_path_dist_to_closest, &tmp_path_dist_to_closest, sizeof(tmp_path_dist_to_closest));
  if (raw_path_dist_to_closest != 0) {
    _internal_set_path_dist_to_closest(from._internal_path_dist_to_closest());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void MotionPlan::CopyFrom(const MotionPlan& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:zoomies.MotionPlan)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MotionPlan::IsInitialized() const {
  return true;
}

void MotionPlan::InternalSwap(MotionPlan* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(MotionPlan, path_dist_to_closest_)
      + sizeof(MotionPlan::path_dist_to_closest_)
      - PROTOBUF_FIELD_OFFSET(MotionPlan, path_velocity_)>(
          reinterpret_cast<char*>(&path_velocity_),
          reinterpret_cast<char*>(&other->path_velocity_));
}

::PROTOBUF_NAMESPACE_ID::Metadata MotionPlan::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_zoomies_2fzoomies_2eproto_getter, &descriptor_table_zoomies_2fzoomies_2eproto_once,
      file_level_metadata_zoomies_2fzoomies_2eproto[1]);
}

// @@protoc_insertion_point(namespace_scope)
}  // namespace zoomies
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::zoomies::DriverLog* Arena::CreateMaybeMessage< ::zoomies::DriverLog >(Arena* arena) {
  return Arena::CreateMessageInternal< ::zoomies::DriverLog >(arena);
}
template<> PROTOBUF_NOINLINE ::zoomies::MotionPlan* Arena::CreateMaybeMessage< ::zoomies::MotionPlan >(Arena* arena) {
  return Arena::CreateMessageInternal< ::zoomies::MotionPlan >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
