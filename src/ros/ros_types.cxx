// Copyright 2016 Proyectos y Sistemas de Mantenimiento SL (eProsima).
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/*!
 * @file ros_types.cpp
 * This source file contains the definition of the described types in the IDL file.
 *
 * This file was generated by the tool gen.
 */

#ifdef _WIN32
// Remove linker warning LNK4221 on Visual Studio
namespace {
char dummy;
}  // namespace
#endif  // _WIN32

#include "ros_types.h"
#include <fastcdr/Cdr.h>

#include <fastcdr/exceptions/BadParamException.h>
using namespace eprosima::fastcdr::exception;

#include <utility>

builtins__Time::builtins__Time()
{
    // m_sec com.eprosima.idl.parser.typecode.PrimitiveTypeCode@553a3d88
    m_sec = 0;
    // m_nsec com.eprosima.idl.parser.typecode.PrimitiveTypeCode@cb0ed20
    m_nsec = 0;

}

builtins__Time::~builtins__Time()
{


}

builtins__Time::builtins__Time(
        const builtins__Time& x)
{
    m_sec = x.m_sec;
    m_nsec = x.m_nsec;
}

builtins__Time::builtins__Time(
        builtins__Time&& x)
{
    m_sec = x.m_sec;
    m_nsec = x.m_nsec;
}

builtins__Time& builtins__Time::operator =(
        const builtins__Time& x)
{

    m_sec = x.m_sec;
    m_nsec = x.m_nsec;

    return *this;
}

builtins__Time& builtins__Time::operator =(
        builtins__Time&& x)
{

    m_sec = x.m_sec;
    m_nsec = x.m_nsec;

    return *this;
}

bool builtins__Time::operator ==(
        const builtins__Time& x) const
{

    return (m_sec == x.m_sec && m_nsec == x.m_nsec);
}

bool builtins__Time::operator !=(
        const builtins__Time& x) const
{
    return !(*this == x);
}

size_t builtins__Time::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);



    return current_alignment - initial_alignment;
}

size_t builtins__Time::getCdrSerializedSize(
        const builtins__Time& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);



    return current_alignment - initial_alignment;
}

void builtins__Time::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_sec;
    scdr << m_nsec;

}

void builtins__Time::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_sec;
    dcdr >> m_nsec;
}

/*!
 * @brief This function sets a value in member sec
 * @param _sec New value for member sec
 */
void builtins__Time::sec(
        int32_t _sec)
{
    m_sec = _sec;
}

/*!
 * @brief This function returns the value of member sec
 * @return Value of member sec
 */
int32_t builtins__Time::sec() const
{
    return m_sec;
}

/*!
 * @brief This function returns a reference to member sec
 * @return Reference to member sec
 */
int32_t& builtins__Time::sec()
{
    return m_sec;
}

/*!
 * @brief This function sets a value in member nsec
 * @param _nsec New value for member nsec
 */
void builtins__Time::nsec(
        int32_t _nsec)
{
    m_nsec = _nsec;
}

/*!
 * @brief This function returns the value of member nsec
 * @return Value of member nsec
 */
int32_t builtins__Time::nsec() const
{
    return m_nsec;
}

/*!
 * @brief This function returns a reference to member nsec
 * @return Reference to member nsec
 */
int32_t& builtins__Time::nsec()
{
    return m_nsec;
}


size_t builtins__Time::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t current_align = current_alignment;





    return current_align;
}

bool builtins__Time::isKeyDefined()
{
    return false;
}

void builtins__Time::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
      
}

builtins__Duration::builtins__Duration()
{
    // m_sec com.eprosima.idl.parser.typecode.PrimitiveTypeCode@c81cdd1
    m_sec = 0;
    // m_nsec com.eprosima.idl.parser.typecode.PrimitiveTypeCode@1fc2b765
    m_nsec = 0;

}

builtins__Duration::~builtins__Duration()
{


}

builtins__Duration::builtins__Duration(
        const builtins__Duration& x)
{
    m_sec = x.m_sec;
    m_nsec = x.m_nsec;
}

builtins__Duration::builtins__Duration(
        builtins__Duration&& x)
{
    m_sec = x.m_sec;
    m_nsec = x.m_nsec;
}

builtins__Duration& builtins__Duration::operator =(
        const builtins__Duration& x)
{

    m_sec = x.m_sec;
    m_nsec = x.m_nsec;

    return *this;
}

builtins__Duration& builtins__Duration::operator =(
        builtins__Duration&& x)
{

    m_sec = x.m_sec;
    m_nsec = x.m_nsec;

    return *this;
}

bool builtins__Duration::operator ==(
        const builtins__Duration& x) const
{

    return (m_sec == x.m_sec && m_nsec == x.m_nsec);
}

bool builtins__Duration::operator !=(
        const builtins__Duration& x) const
{
    return !(*this == x);
}

size_t builtins__Duration::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);



    return current_alignment - initial_alignment;
}

size_t builtins__Duration::getCdrSerializedSize(
        const builtins__Duration& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);



    return current_alignment - initial_alignment;
}

void builtins__Duration::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_sec;
    scdr << m_nsec;

}

void builtins__Duration::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_sec;
    dcdr >> m_nsec;
}

/*!
 * @brief This function sets a value in member sec
 * @param _sec New value for member sec
 */
void builtins__Duration::sec(
        int32_t _sec)
{
    m_sec = _sec;
}

/*!
 * @brief This function returns the value of member sec
 * @return Value of member sec
 */
int32_t builtins__Duration::sec() const
{
    return m_sec;
}

/*!
 * @brief This function returns a reference to member sec
 * @return Reference to member sec
 */
int32_t& builtins__Duration::sec()
{
    return m_sec;
}

/*!
 * @brief This function sets a value in member nsec
 * @param _nsec New value for member nsec
 */
void builtins__Duration::nsec(
        int32_t _nsec)
{
    m_nsec = _nsec;
}

/*!
 * @brief This function returns the value of member nsec
 * @return Value of member nsec
 */
int32_t builtins__Duration::nsec() const
{
    return m_nsec;
}

/*!
 * @brief This function returns a reference to member nsec
 * @return Reference to member nsec
 */
int32_t& builtins__Duration::nsec()
{
    return m_nsec;
}


size_t builtins__Duration::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t current_align = current_alignment;





    return current_align;
}

bool builtins__Duration::isKeyDefined()
{
    return false;
}

void builtins__Duration::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
      
}

std_msgs__Header::std_msgs__Header()
{
    // m_stamp com.eprosima.fastdds.idl.parser.typecode.StructTypeCode@517cd4b

    // m_frame_id com.eprosima.idl.parser.typecode.StringTypeCode@6cc7b4de
    m_frame_id ="";

}

std_msgs__Header::~std_msgs__Header()
{


}

std_msgs__Header::std_msgs__Header(
        const std_msgs__Header& x)
{
    m_stamp = x.m_stamp;
    m_frame_id = x.m_frame_id;
}

std_msgs__Header::std_msgs__Header(
        std_msgs__Header&& x)
{
    m_stamp = std::move(x.m_stamp);
    m_frame_id = std::move(x.m_frame_id);
}

std_msgs__Header& std_msgs__Header::operator =(
        const std_msgs__Header& x)
{

    m_stamp = x.m_stamp;
    m_frame_id = x.m_frame_id;

    return *this;
}

std_msgs__Header& std_msgs__Header::operator =(
        std_msgs__Header&& x)
{

    m_stamp = std::move(x.m_stamp);
    m_frame_id = std::move(x.m_frame_id);

    return *this;
}

bool std_msgs__Header::operator ==(
        const std_msgs__Header& x) const
{

    return (m_stamp == x.m_stamp && m_frame_id == x.m_frame_id);
}

bool std_msgs__Header::operator !=(
        const std_msgs__Header& x) const
{
    return !(*this == x);
}

size_t std_msgs__Header::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t initial_alignment = current_alignment;


    current_alignment += builtins__Time::getMaxCdrSerializedSize(current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 255 + 1;


    return current_alignment - initial_alignment;
}

size_t std_msgs__Header::getCdrSerializedSize(
        const std_msgs__Header& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += builtins__Time::getCdrSerializedSize(data.stamp(), current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.frame_id().size() + 1;


    return current_alignment - initial_alignment;
}

void std_msgs__Header::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_stamp;
    scdr << m_frame_id;

}

void std_msgs__Header::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_stamp;
    dcdr >> m_frame_id;
}

/*!
 * @brief This function copies the value in member stamp
 * @param _stamp New value to be copied in member stamp
 */
void std_msgs__Header::stamp(
        const builtins__Time& _stamp)
{
    m_stamp = _stamp;
}

/*!
 * @brief This function moves the value in member stamp
 * @param _stamp New value to be moved in member stamp
 */
void std_msgs__Header::stamp(
        builtins__Time&& _stamp)
{
    m_stamp = std::move(_stamp);
}

/*!
 * @brief This function returns a constant reference to member stamp
 * @return Constant reference to member stamp
 */
const builtins__Time& std_msgs__Header::stamp() const
{
    return m_stamp;
}

/*!
 * @brief This function returns a reference to member stamp
 * @return Reference to member stamp
 */
builtins__Time& std_msgs__Header::stamp()
{
    return m_stamp;
}
/*!
 * @brief This function copies the value in member frame_id
 * @param _frame_id New value to be copied in member frame_id
 */
void std_msgs__Header::frame_id(
        const std::string& _frame_id)
{
    m_frame_id = _frame_id;
}

/*!
 * @brief This function moves the value in member frame_id
 * @param _frame_id New value to be moved in member frame_id
 */
void std_msgs__Header::frame_id(
        std::string&& _frame_id)
{
    m_frame_id = std::move(_frame_id);
}

/*!
 * @brief This function returns a constant reference to member frame_id
 * @return Constant reference to member frame_id
 */
const std::string& std_msgs__Header::frame_id() const
{
    return m_frame_id;
}

/*!
 * @brief This function returns a reference to member frame_id
 * @return Reference to member frame_id
 */
std::string& std_msgs__Header::frame_id()
{
    return m_frame_id;
}

size_t std_msgs__Header::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t current_align = current_alignment;





    return current_align;
}

bool std_msgs__Header::isKeyDefined()
{
    return false;
}

void std_msgs__Header::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
      
}

std_msgs__ColorRGBA::std_msgs__ColorRGBA()
{
    // m_r com.eprosima.idl.parser.typecode.PrimitiveTypeCode@799d4f69
    m_r = 0.0;
    // m_g com.eprosima.idl.parser.typecode.PrimitiveTypeCode@49c43f4e
    m_g = 0.0;
    // m_b com.eprosima.idl.parser.typecode.PrimitiveTypeCode@290dbf45
    m_b = 0.0;
    // m_a com.eprosima.idl.parser.typecode.PrimitiveTypeCode@12028586
    m_a = 0.0;

}

std_msgs__ColorRGBA::~std_msgs__ColorRGBA()
{




}

std_msgs__ColorRGBA::std_msgs__ColorRGBA(
        const std_msgs__ColorRGBA& x)
{
    m_r = x.m_r;
    m_g = x.m_g;
    m_b = x.m_b;
    m_a = x.m_a;
}

std_msgs__ColorRGBA::std_msgs__ColorRGBA(
        std_msgs__ColorRGBA&& x)
{
    m_r = x.m_r;
    m_g = x.m_g;
    m_b = x.m_b;
    m_a = x.m_a;
}

std_msgs__ColorRGBA& std_msgs__ColorRGBA::operator =(
        const std_msgs__ColorRGBA& x)
{

    m_r = x.m_r;
    m_g = x.m_g;
    m_b = x.m_b;
    m_a = x.m_a;

    return *this;
}

std_msgs__ColorRGBA& std_msgs__ColorRGBA::operator =(
        std_msgs__ColorRGBA&& x)
{

    m_r = x.m_r;
    m_g = x.m_g;
    m_b = x.m_b;
    m_a = x.m_a;

    return *this;
}

bool std_msgs__ColorRGBA::operator ==(
        const std_msgs__ColorRGBA& x) const
{

    return (m_r == x.m_r && m_g == x.m_g && m_b == x.m_b && m_a == x.m_a);
}

bool std_msgs__ColorRGBA::operator !=(
        const std_msgs__ColorRGBA& x) const
{
    return !(*this == x);
}

size_t std_msgs__ColorRGBA::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);



    return current_alignment - initial_alignment;
}

size_t std_msgs__ColorRGBA::getCdrSerializedSize(
        const std_msgs__ColorRGBA& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);



    return current_alignment - initial_alignment;
}

void std_msgs__ColorRGBA::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_r;
    scdr << m_g;
    scdr << m_b;
    scdr << m_a;

}

void std_msgs__ColorRGBA::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_r;
    dcdr >> m_g;
    dcdr >> m_b;
    dcdr >> m_a;
}

/*!
 * @brief This function sets a value in member r
 * @param _r New value for member r
 */
void std_msgs__ColorRGBA::r(
        float _r)
{
    m_r = _r;
}

/*!
 * @brief This function returns the value of member r
 * @return Value of member r
 */
float std_msgs__ColorRGBA::r() const
{
    return m_r;
}

/*!
 * @brief This function returns a reference to member r
 * @return Reference to member r
 */
float& std_msgs__ColorRGBA::r()
{
    return m_r;
}

/*!
 * @brief This function sets a value in member g
 * @param _g New value for member g
 */
void std_msgs__ColorRGBA::g(
        float _g)
{
    m_g = _g;
}

/*!
 * @brief This function returns the value of member g
 * @return Value of member g
 */
float std_msgs__ColorRGBA::g() const
{
    return m_g;
}

/*!
 * @brief This function returns a reference to member g
 * @return Reference to member g
 */
float& std_msgs__ColorRGBA::g()
{
    return m_g;
}

/*!
 * @brief This function sets a value in member b
 * @param _b New value for member b
 */
void std_msgs__ColorRGBA::b(
        float _b)
{
    m_b = _b;
}

/*!
 * @brief This function returns the value of member b
 * @return Value of member b
 */
float std_msgs__ColorRGBA::b() const
{
    return m_b;
}

/*!
 * @brief This function returns a reference to member b
 * @return Reference to member b
 */
float& std_msgs__ColorRGBA::b()
{
    return m_b;
}

/*!
 * @brief This function sets a value in member a
 * @param _a New value for member a
 */
void std_msgs__ColorRGBA::a(
        float _a)
{
    m_a = _a;
}

/*!
 * @brief This function returns the value of member a
 * @return Value of member a
 */
float std_msgs__ColorRGBA::a() const
{
    return m_a;
}

/*!
 * @brief This function returns a reference to member a
 * @return Reference to member a
 */
float& std_msgs__ColorRGBA::a()
{
    return m_a;
}


size_t std_msgs__ColorRGBA::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t current_align = current_alignment;







    return current_align;
}

bool std_msgs__ColorRGBA::isKeyDefined()
{
    return false;
}

void std_msgs__ColorRGBA::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
        
}

std_msgs__Int32::std_msgs__Int32()
{
    // m_data com.eprosima.idl.parser.typecode.PrimitiveTypeCode@701fc37a
    m_data = 0;

}

std_msgs__Int32::~std_msgs__Int32()
{
}

std_msgs__Int32::std_msgs__Int32(
        const std_msgs__Int32& x)
{
    m_data = x.m_data;
}

std_msgs__Int32::std_msgs__Int32(
        std_msgs__Int32&& x)
{
    m_data = x.m_data;
}

std_msgs__Int32& std_msgs__Int32::operator =(
        const std_msgs__Int32& x)
{

    m_data = x.m_data;

    return *this;
}

std_msgs__Int32& std_msgs__Int32::operator =(
        std_msgs__Int32&& x)
{

    m_data = x.m_data;

    return *this;
}

bool std_msgs__Int32::operator ==(
        const std_msgs__Int32& x) const
{

    return (m_data == x.m_data);
}

bool std_msgs__Int32::operator !=(
        const std_msgs__Int32& x) const
{
    return !(*this == x);
}

size_t std_msgs__Int32::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    return current_alignment - initial_alignment;
}

size_t std_msgs__Int32::getCdrSerializedSize(
        const std_msgs__Int32& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    return current_alignment - initial_alignment;
}

void std_msgs__Int32::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_data;

}

void std_msgs__Int32::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_data;
}

/*!
 * @brief This function sets a value in member data
 * @param _data New value for member data
 */
void std_msgs__Int32::data(
        int32_t _data)
{
    m_data = _data;
}

/*!
 * @brief This function returns the value of member data
 * @return Value of member data
 */
int32_t std_msgs__Int32::data() const
{
    return m_data;
}

/*!
 * @brief This function returns a reference to member data
 * @return Reference to member data
 */
int32_t& std_msgs__Int32::data()
{
    return m_data;
}


size_t std_msgs__Int32::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t current_align = current_alignment;



    return current_align;
}

bool std_msgs__Int32::isKeyDefined()
{
    return false;
}

void std_msgs__Int32::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
     
}

std_msgs__Float32::std_msgs__Float32()
{
    // m_data com.eprosima.idl.parser.typecode.PrimitiveTypeCode@7fad8c79
    m_data = 0.0;

}

std_msgs__Float32::~std_msgs__Float32()
{
}

std_msgs__Float32::std_msgs__Float32(
        const std_msgs__Float32& x)
{
    m_data = x.m_data;
}

std_msgs__Float32::std_msgs__Float32(
        std_msgs__Float32&& x)
{
    m_data = x.m_data;
}

std_msgs__Float32& std_msgs__Float32::operator =(
        const std_msgs__Float32& x)
{

    m_data = x.m_data;

    return *this;
}

std_msgs__Float32& std_msgs__Float32::operator =(
        std_msgs__Float32&& x)
{

    m_data = x.m_data;

    return *this;
}

bool std_msgs__Float32::operator ==(
        const std_msgs__Float32& x) const
{

    return (m_data == x.m_data);
}

bool std_msgs__Float32::operator !=(
        const std_msgs__Float32& x) const
{
    return !(*this == x);
}

size_t std_msgs__Float32::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    return current_alignment - initial_alignment;
}

size_t std_msgs__Float32::getCdrSerializedSize(
        const std_msgs__Float32& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    return current_alignment - initial_alignment;
}

void std_msgs__Float32::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_data;

}

void std_msgs__Float32::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_data;
}

/*!
 * @brief This function sets a value in member data
 * @param _data New value for member data
 */
void std_msgs__Float32::data(
        float _data)
{
    m_data = _data;
}

/*!
 * @brief This function returns the value of member data
 * @return Value of member data
 */
float std_msgs__Float32::data() const
{
    return m_data;
}

/*!
 * @brief This function returns a reference to member data
 * @return Reference to member data
 */
float& std_msgs__Float32::data()
{
    return m_data;
}


size_t std_msgs__Float32::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t current_align = current_alignment;



    return current_align;
}

bool std_msgs__Float32::isKeyDefined()
{
    return false;
}

void std_msgs__Float32::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
     
}

geometry_msgs__Vector3::geometry_msgs__Vector3()
{
    // m_x com.eprosima.idl.parser.typecode.PrimitiveTypeCode@71a794e5
    m_x = 0.0;
    // m_y com.eprosima.idl.parser.typecode.PrimitiveTypeCode@76329302
    m_y = 0.0;
    // m_z com.eprosima.idl.parser.typecode.PrimitiveTypeCode@5e25a92e
    m_z = 0.0;

}

geometry_msgs__Vector3::~geometry_msgs__Vector3()
{



}

geometry_msgs__Vector3::geometry_msgs__Vector3(
        const geometry_msgs__Vector3& x)
{
    m_x = x.m_x;
    m_y = x.m_y;
    m_z = x.m_z;
}

geometry_msgs__Vector3::geometry_msgs__Vector3(
        geometry_msgs__Vector3&& x)
{
    m_x = x.m_x;
    m_y = x.m_y;
    m_z = x.m_z;
}

geometry_msgs__Vector3& geometry_msgs__Vector3::operator =(
        const geometry_msgs__Vector3& x)
{

    m_x = x.m_x;
    m_y = x.m_y;
    m_z = x.m_z;

    return *this;
}

geometry_msgs__Vector3& geometry_msgs__Vector3::operator =(
        geometry_msgs__Vector3&& x)
{

    m_x = x.m_x;
    m_y = x.m_y;
    m_z = x.m_z;

    return *this;
}

bool geometry_msgs__Vector3::operator ==(
        const geometry_msgs__Vector3& x) const
{

    return (m_x == x.m_x && m_y == x.m_y && m_z == x.m_z);
}

bool geometry_msgs__Vector3::operator !=(
        const geometry_msgs__Vector3& x) const
{
    return !(*this == x);
}

size_t geometry_msgs__Vector3::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t initial_alignment = current_alignment;


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);



    return current_alignment - initial_alignment;
}

size_t geometry_msgs__Vector3::getCdrSerializedSize(
        const geometry_msgs__Vector3& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);



    return current_alignment - initial_alignment;
}

void geometry_msgs__Vector3::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_x;
    scdr << m_y;
    scdr << m_z;

}

void geometry_msgs__Vector3::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_x;
    dcdr >> m_y;
    dcdr >> m_z;
}

/*!
 * @brief This function sets a value in member x
 * @param _x New value for member x
 */
void geometry_msgs__Vector3::x(
        double _x)
{
    m_x = _x;
}

/*!
 * @brief This function returns the value of member x
 * @return Value of member x
 */
double geometry_msgs__Vector3::x() const
{
    return m_x;
}

/*!
 * @brief This function returns a reference to member x
 * @return Reference to member x
 */
double& geometry_msgs__Vector3::x()
{
    return m_x;
}

/*!
 * @brief This function sets a value in member y
 * @param _y New value for member y
 */
void geometry_msgs__Vector3::y(
        double _y)
{
    m_y = _y;
}

/*!
 * @brief This function returns the value of member y
 * @return Value of member y
 */
double geometry_msgs__Vector3::y() const
{
    return m_y;
}

/*!
 * @brief This function returns a reference to member y
 * @return Reference to member y
 */
double& geometry_msgs__Vector3::y()
{
    return m_y;
}

/*!
 * @brief This function sets a value in member z
 * @param _z New value for member z
 */
void geometry_msgs__Vector3::z(
        double _z)
{
    m_z = _z;
}

/*!
 * @brief This function returns the value of member z
 * @return Value of member z
 */
double geometry_msgs__Vector3::z() const
{
    return m_z;
}

/*!
 * @brief This function returns a reference to member z
 * @return Reference to member z
 */
double& geometry_msgs__Vector3::z()
{
    return m_z;
}


size_t geometry_msgs__Vector3::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t current_align = current_alignment;






    return current_align;
}

bool geometry_msgs__Vector3::isKeyDefined()
{
    return false;
}

void geometry_msgs__Vector3::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
       
}

geometry_msgs__Point::geometry_msgs__Point()
{
    // m_x com.eprosima.idl.parser.typecode.PrimitiveTypeCode@1dd02175
    m_x = 0.0;
    // m_y com.eprosima.idl.parser.typecode.PrimitiveTypeCode@31206beb
    m_y = 0.0;
    // m_z com.eprosima.idl.parser.typecode.PrimitiveTypeCode@23bb8443
    m_z = 0.0;

}

geometry_msgs__Point::~geometry_msgs__Point()
{



}

geometry_msgs__Point::geometry_msgs__Point(
        const geometry_msgs__Point& x)
{
    m_x = x.m_x;
    m_y = x.m_y;
    m_z = x.m_z;
}

geometry_msgs__Point::geometry_msgs__Point(
        geometry_msgs__Point&& x)
{
    m_x = x.m_x;
    m_y = x.m_y;
    m_z = x.m_z;
}

geometry_msgs__Point& geometry_msgs__Point::operator =(
        const geometry_msgs__Point& x)
{

    m_x = x.m_x;
    m_y = x.m_y;
    m_z = x.m_z;

    return *this;
}

geometry_msgs__Point& geometry_msgs__Point::operator =(
        geometry_msgs__Point&& x)
{

    m_x = x.m_x;
    m_y = x.m_y;
    m_z = x.m_z;

    return *this;
}

bool geometry_msgs__Point::operator ==(
        const geometry_msgs__Point& x) const
{

    return (m_x == x.m_x && m_y == x.m_y && m_z == x.m_z);
}

bool geometry_msgs__Point::operator !=(
        const geometry_msgs__Point& x) const
{
    return !(*this == x);
}

size_t geometry_msgs__Point::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t initial_alignment = current_alignment;


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);



    return current_alignment - initial_alignment;
}

size_t geometry_msgs__Point::getCdrSerializedSize(
        const geometry_msgs__Point& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);



    return current_alignment - initial_alignment;
}

void geometry_msgs__Point::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_x;
    scdr << m_y;
    scdr << m_z;

}

void geometry_msgs__Point::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_x;
    dcdr >> m_y;
    dcdr >> m_z;
}

/*!
 * @brief This function sets a value in member x
 * @param _x New value for member x
 */
void geometry_msgs__Point::x(
        double _x)
{
    m_x = _x;
}

/*!
 * @brief This function returns the value of member x
 * @return Value of member x
 */
double geometry_msgs__Point::x() const
{
    return m_x;
}

/*!
 * @brief This function returns a reference to member x
 * @return Reference to member x
 */
double& geometry_msgs__Point::x()
{
    return m_x;
}

/*!
 * @brief This function sets a value in member y
 * @param _y New value for member y
 */
void geometry_msgs__Point::y(
        double _y)
{
    m_y = _y;
}

/*!
 * @brief This function returns the value of member y
 * @return Value of member y
 */
double geometry_msgs__Point::y() const
{
    return m_y;
}

/*!
 * @brief This function returns a reference to member y
 * @return Reference to member y
 */
double& geometry_msgs__Point::y()
{
    return m_y;
}

/*!
 * @brief This function sets a value in member z
 * @param _z New value for member z
 */
void geometry_msgs__Point::z(
        double _z)
{
    m_z = _z;
}

/*!
 * @brief This function returns the value of member z
 * @return Value of member z
 */
double geometry_msgs__Point::z() const
{
    return m_z;
}

/*!
 * @brief This function returns a reference to member z
 * @return Reference to member z
 */
double& geometry_msgs__Point::z()
{
    return m_z;
}


size_t geometry_msgs__Point::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t current_align = current_alignment;






    return current_align;
}

bool geometry_msgs__Point::isKeyDefined()
{
    return false;
}

void geometry_msgs__Point::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
       
}

geometry_msgs__Quaternion::geometry_msgs__Quaternion()
{
    // m_x com.eprosima.idl.parser.typecode.PrimitiveTypeCode@37574691
    m_x = 0.0;
    // m_y com.eprosima.idl.parser.typecode.PrimitiveTypeCode@25359ed8
    m_y = 0.0;
    // m_z com.eprosima.idl.parser.typecode.PrimitiveTypeCode@21a947fe
    m_z = 0.0;
    // m_w com.eprosima.idl.parser.typecode.PrimitiveTypeCode@5606c0b
    m_w = 0.0;

}

geometry_msgs__Quaternion::~geometry_msgs__Quaternion()
{




}

geometry_msgs__Quaternion::geometry_msgs__Quaternion(
        const geometry_msgs__Quaternion& x)
{
    m_x = x.m_x;
    m_y = x.m_y;
    m_z = x.m_z;
    m_w = x.m_w;
}

geometry_msgs__Quaternion::geometry_msgs__Quaternion(
        geometry_msgs__Quaternion&& x)
{
    m_x = x.m_x;
    m_y = x.m_y;
    m_z = x.m_z;
    m_w = x.m_w;
}

geometry_msgs__Quaternion& geometry_msgs__Quaternion::operator =(
        const geometry_msgs__Quaternion& x)
{

    m_x = x.m_x;
    m_y = x.m_y;
    m_z = x.m_z;
    m_w = x.m_w;

    return *this;
}

geometry_msgs__Quaternion& geometry_msgs__Quaternion::operator =(
        geometry_msgs__Quaternion&& x)
{

    m_x = x.m_x;
    m_y = x.m_y;
    m_z = x.m_z;
    m_w = x.m_w;

    return *this;
}

bool geometry_msgs__Quaternion::operator ==(
        const geometry_msgs__Quaternion& x) const
{

    return (m_x == x.m_x && m_y == x.m_y && m_z == x.m_z && m_w == x.m_w);
}

bool geometry_msgs__Quaternion::operator !=(
        const geometry_msgs__Quaternion& x) const
{
    return !(*this == x);
}

size_t geometry_msgs__Quaternion::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t initial_alignment = current_alignment;


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);



    return current_alignment - initial_alignment;
}

size_t geometry_msgs__Quaternion::getCdrSerializedSize(
        const geometry_msgs__Quaternion& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);



    return current_alignment - initial_alignment;
}

void geometry_msgs__Quaternion::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_x;
    scdr << m_y;
    scdr << m_z;
    scdr << m_w;

}

void geometry_msgs__Quaternion::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_x;
    dcdr >> m_y;
    dcdr >> m_z;
    dcdr >> m_w;
}

/*!
 * @brief This function sets a value in member x
 * @param _x New value for member x
 */
void geometry_msgs__Quaternion::x(
        double _x)
{
    m_x = _x;
}

/*!
 * @brief This function returns the value of member x
 * @return Value of member x
 */
double geometry_msgs__Quaternion::x() const
{
    return m_x;
}

/*!
 * @brief This function returns a reference to member x
 * @return Reference to member x
 */
double& geometry_msgs__Quaternion::x()
{
    return m_x;
}

/*!
 * @brief This function sets a value in member y
 * @param _y New value for member y
 */
void geometry_msgs__Quaternion::y(
        double _y)
{
    m_y = _y;
}

/*!
 * @brief This function returns the value of member y
 * @return Value of member y
 */
double geometry_msgs__Quaternion::y() const
{
    return m_y;
}

/*!
 * @brief This function returns a reference to member y
 * @return Reference to member y
 */
double& geometry_msgs__Quaternion::y()
{
    return m_y;
}

/*!
 * @brief This function sets a value in member z
 * @param _z New value for member z
 */
void geometry_msgs__Quaternion::z(
        double _z)
{
    m_z = _z;
}

/*!
 * @brief This function returns the value of member z
 * @return Value of member z
 */
double geometry_msgs__Quaternion::z() const
{
    return m_z;
}

/*!
 * @brief This function returns a reference to member z
 * @return Reference to member z
 */
double& geometry_msgs__Quaternion::z()
{
    return m_z;
}

/*!
 * @brief This function sets a value in member w
 * @param _w New value for member w
 */
void geometry_msgs__Quaternion::w(
        double _w)
{
    m_w = _w;
}

/*!
 * @brief This function returns the value of member w
 * @return Value of member w
 */
double geometry_msgs__Quaternion::w() const
{
    return m_w;
}

/*!
 * @brief This function returns a reference to member w
 * @return Reference to member w
 */
double& geometry_msgs__Quaternion::w()
{
    return m_w;
}


size_t geometry_msgs__Quaternion::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t current_align = current_alignment;







    return current_align;
}

bool geometry_msgs__Quaternion::isKeyDefined()
{
    return false;
}

void geometry_msgs__Quaternion::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
        
}

geometry_msgs__Twist::geometry_msgs__Twist()
{
    // m_linear com.eprosima.fastdds.idl.parser.typecode.StructTypeCode@12405818

    // m_angular com.eprosima.fastdds.idl.parser.typecode.StructTypeCode@12405818


}

geometry_msgs__Twist::~geometry_msgs__Twist()
{


}

geometry_msgs__Twist::geometry_msgs__Twist(
        const geometry_msgs__Twist& x)
{
    m_linear = x.m_linear;
    m_angular = x.m_angular;
}

geometry_msgs__Twist::geometry_msgs__Twist(
        geometry_msgs__Twist&& x)
{
    m_linear = std::move(x.m_linear);
    m_angular = std::move(x.m_angular);
}

geometry_msgs__Twist& geometry_msgs__Twist::operator =(
        const geometry_msgs__Twist& x)
{

    m_linear = x.m_linear;
    m_angular = x.m_angular;

    return *this;
}

geometry_msgs__Twist& geometry_msgs__Twist::operator =(
        geometry_msgs__Twist&& x)
{

    m_linear = std::move(x.m_linear);
    m_angular = std::move(x.m_angular);

    return *this;
}

bool geometry_msgs__Twist::operator ==(
        const geometry_msgs__Twist& x) const
{

    return (m_linear == x.m_linear && m_angular == x.m_angular);
}

bool geometry_msgs__Twist::operator !=(
        const geometry_msgs__Twist& x) const
{
    return !(*this == x);
}

size_t geometry_msgs__Twist::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t initial_alignment = current_alignment;


    current_alignment += geometry_msgs__Vector3::getMaxCdrSerializedSize(current_alignment);
    current_alignment += geometry_msgs__Vector3::getMaxCdrSerializedSize(current_alignment);

    return current_alignment - initial_alignment;
}

size_t geometry_msgs__Twist::getCdrSerializedSize(
        const geometry_msgs__Twist& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += geometry_msgs__Vector3::getCdrSerializedSize(data.linear(), current_alignment);
    current_alignment += geometry_msgs__Vector3::getCdrSerializedSize(data.angular(), current_alignment);

    return current_alignment - initial_alignment;
}

void geometry_msgs__Twist::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_linear;
    scdr << m_angular;

}

void geometry_msgs__Twist::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_linear;
    dcdr >> m_angular;
}

/*!
 * @brief This function copies the value in member linear
 * @param _linear New value to be copied in member linear
 */
void geometry_msgs__Twist::linear(
        const geometry_msgs__Vector3& _linear)
{
    m_linear = _linear;
}

/*!
 * @brief This function moves the value in member linear
 * @param _linear New value to be moved in member linear
 */
void geometry_msgs__Twist::linear(
        geometry_msgs__Vector3&& _linear)
{
    m_linear = std::move(_linear);
}

/*!
 * @brief This function returns a constant reference to member linear
 * @return Constant reference to member linear
 */
const geometry_msgs__Vector3& geometry_msgs__Twist::linear() const
{
    return m_linear;
}

/*!
 * @brief This function returns a reference to member linear
 * @return Reference to member linear
 */
geometry_msgs__Vector3& geometry_msgs__Twist::linear()
{
    return m_linear;
}
/*!
 * @brief This function copies the value in member angular
 * @param _angular New value to be copied in member angular
 */
void geometry_msgs__Twist::angular(
        const geometry_msgs__Vector3& _angular)
{
    m_angular = _angular;
}

/*!
 * @brief This function moves the value in member angular
 * @param _angular New value to be moved in member angular
 */
void geometry_msgs__Twist::angular(
        geometry_msgs__Vector3&& _angular)
{
    m_angular = std::move(_angular);
}

/*!
 * @brief This function returns a constant reference to member angular
 * @return Constant reference to member angular
 */
const geometry_msgs__Vector3& geometry_msgs__Twist::angular() const
{
    return m_angular;
}

/*!
 * @brief This function returns a reference to member angular
 * @return Reference to member angular
 */
geometry_msgs__Vector3& geometry_msgs__Twist::angular()
{
    return m_angular;
}

size_t geometry_msgs__Twist::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t current_align = current_alignment;





    return current_align;
}

bool geometry_msgs__Twist::isKeyDefined()
{
    return false;
}

void geometry_msgs__Twist::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
      
}

geometry_msgs__TwistStamped::geometry_msgs__TwistStamped()
{
    // m_header com.eprosima.fastdds.idl.parser.typecode.StructTypeCode@314c508a

    // m_twist com.eprosima.fastdds.idl.parser.typecode.StructTypeCode@10b48321


}

geometry_msgs__TwistStamped::~geometry_msgs__TwistStamped()
{


}

geometry_msgs__TwistStamped::geometry_msgs__TwistStamped(
        const geometry_msgs__TwistStamped& x)
{
    m_header = x.m_header;
    m_twist = x.m_twist;
}

geometry_msgs__TwistStamped::geometry_msgs__TwistStamped(
        geometry_msgs__TwistStamped&& x)
{
    m_header = std::move(x.m_header);
    m_twist = std::move(x.m_twist);
}

geometry_msgs__TwistStamped& geometry_msgs__TwistStamped::operator =(
        const geometry_msgs__TwistStamped& x)
{

    m_header = x.m_header;
    m_twist = x.m_twist;

    return *this;
}

geometry_msgs__TwistStamped& geometry_msgs__TwistStamped::operator =(
        geometry_msgs__TwistStamped&& x)
{

    m_header = std::move(x.m_header);
    m_twist = std::move(x.m_twist);

    return *this;
}

bool geometry_msgs__TwistStamped::operator ==(
        const geometry_msgs__TwistStamped& x) const
{

    return (m_header == x.m_header && m_twist == x.m_twist);
}

bool geometry_msgs__TwistStamped::operator !=(
        const geometry_msgs__TwistStamped& x) const
{
    return !(*this == x);
}

size_t geometry_msgs__TwistStamped::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t initial_alignment = current_alignment;


    current_alignment += std_msgs__Header::getMaxCdrSerializedSize(current_alignment);
    current_alignment += geometry_msgs__Twist::getMaxCdrSerializedSize(current_alignment);

    return current_alignment - initial_alignment;
}

size_t geometry_msgs__TwistStamped::getCdrSerializedSize(
        const geometry_msgs__TwistStamped& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += std_msgs__Header::getCdrSerializedSize(data.header(), current_alignment);
    current_alignment += geometry_msgs__Twist::getCdrSerializedSize(data.twist(), current_alignment);

    return current_alignment - initial_alignment;
}

void geometry_msgs__TwistStamped::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_header;
    scdr << m_twist;

}

void geometry_msgs__TwistStamped::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_header;
    dcdr >> m_twist;
}

/*!
 * @brief This function copies the value in member header
 * @param _header New value to be copied in member header
 */
void geometry_msgs__TwistStamped::header(
        const std_msgs__Header& _header)
{
    m_header = _header;
}

/*!
 * @brief This function moves the value in member header
 * @param _header New value to be moved in member header
 */
void geometry_msgs__TwistStamped::header(
        std_msgs__Header&& _header)
{
    m_header = std::move(_header);
}

/*!
 * @brief This function returns a constant reference to member header
 * @return Constant reference to member header
 */
const std_msgs__Header& geometry_msgs__TwistStamped::header() const
{
    return m_header;
}

/*!
 * @brief This function returns a reference to member header
 * @return Reference to member header
 */
std_msgs__Header& geometry_msgs__TwistStamped::header()
{
    return m_header;
}
/*!
 * @brief This function copies the value in member twist
 * @param _twist New value to be copied in member twist
 */
void geometry_msgs__TwistStamped::twist(
        const geometry_msgs__Twist& _twist)
{
    m_twist = _twist;
}

/*!
 * @brief This function moves the value in member twist
 * @param _twist New value to be moved in member twist
 */
void geometry_msgs__TwistStamped::twist(
        geometry_msgs__Twist&& _twist)
{
    m_twist = std::move(_twist);
}

/*!
 * @brief This function returns a constant reference to member twist
 * @return Constant reference to member twist
 */
const geometry_msgs__Twist& geometry_msgs__TwistStamped::twist() const
{
    return m_twist;
}

/*!
 * @brief This function returns a reference to member twist
 * @return Reference to member twist
 */
geometry_msgs__Twist& geometry_msgs__TwistStamped::twist()
{
    return m_twist;
}

size_t geometry_msgs__TwistStamped::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t current_align = current_alignment;





    return current_align;
}

bool geometry_msgs__TwistStamped::isKeyDefined()
{
    return false;
}

void geometry_msgs__TwistStamped::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
      
}

geometry_msgs__TwistWithCovariance::geometry_msgs__TwistWithCovariance()
{
    // m_twist com.eprosima.fastdds.idl.parser.typecode.StructTypeCode@10b48321

    // m_covariance com.eprosima.idl.parser.typecode.ArrayTypeCode@59717824
    memset(&m_covariance, 0, (36) * 8);

}

geometry_msgs__TwistWithCovariance::~geometry_msgs__TwistWithCovariance()
{


}

geometry_msgs__TwistWithCovariance::geometry_msgs__TwistWithCovariance(
        const geometry_msgs__TwistWithCovariance& x)
{
    m_twist = x.m_twist;
    m_covariance = x.m_covariance;
}

geometry_msgs__TwistWithCovariance::geometry_msgs__TwistWithCovariance(
        geometry_msgs__TwistWithCovariance&& x)
{
    m_twist = std::move(x.m_twist);
    m_covariance = std::move(x.m_covariance);
}

geometry_msgs__TwistWithCovariance& geometry_msgs__TwistWithCovariance::operator =(
        const geometry_msgs__TwistWithCovariance& x)
{

    m_twist = x.m_twist;
    m_covariance = x.m_covariance;

    return *this;
}

geometry_msgs__TwistWithCovariance& geometry_msgs__TwistWithCovariance::operator =(
        geometry_msgs__TwistWithCovariance&& x)
{

    m_twist = std::move(x.m_twist);
    m_covariance = std::move(x.m_covariance);

    return *this;
}

bool geometry_msgs__TwistWithCovariance::operator ==(
        const geometry_msgs__TwistWithCovariance& x) const
{

    return (m_twist == x.m_twist && m_covariance == x.m_covariance);
}

bool geometry_msgs__TwistWithCovariance::operator !=(
        const geometry_msgs__TwistWithCovariance& x) const
{
    return !(*this == x);
}

size_t geometry_msgs__TwistWithCovariance::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t initial_alignment = current_alignment;


    current_alignment += geometry_msgs__Twist::getMaxCdrSerializedSize(current_alignment);
    current_alignment += ((36) * 8) + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);



    return current_alignment - initial_alignment;
}

size_t geometry_msgs__TwistWithCovariance::getCdrSerializedSize(
        const geometry_msgs__TwistWithCovariance& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += geometry_msgs__Twist::getCdrSerializedSize(data.twist(), current_alignment);
    if ((36) > 0)
    {
        current_alignment += ((36) * 8) + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);
    }


    return current_alignment - initial_alignment;
}

void geometry_msgs__TwistWithCovariance::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_twist;
    scdr << m_covariance;


}

void geometry_msgs__TwistWithCovariance::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_twist;
    dcdr >> m_covariance;

}

/*!
 * @brief This function copies the value in member twist
 * @param _twist New value to be copied in member twist
 */
void geometry_msgs__TwistWithCovariance::twist(
        const geometry_msgs__Twist& _twist)
{
    m_twist = _twist;
}

/*!
 * @brief This function moves the value in member twist
 * @param _twist New value to be moved in member twist
 */
void geometry_msgs__TwistWithCovariance::twist(
        geometry_msgs__Twist&& _twist)
{
    m_twist = std::move(_twist);
}

/*!
 * @brief This function returns a constant reference to member twist
 * @return Constant reference to member twist
 */
const geometry_msgs__Twist& geometry_msgs__TwistWithCovariance::twist() const
{
    return m_twist;
}

/*!
 * @brief This function returns a reference to member twist
 * @return Reference to member twist
 */
geometry_msgs__Twist& geometry_msgs__TwistWithCovariance::twist()
{
    return m_twist;
}
/*!
 * @brief This function copies the value in member covariance
 * @param _covariance New value to be copied in member covariance
 */
void geometry_msgs__TwistWithCovariance::covariance(
        const std::array<double, 36>& _covariance)
{
    m_covariance = _covariance;
}

/*!
 * @brief This function moves the value in member covariance
 * @param _covariance New value to be moved in member covariance
 */
void geometry_msgs__TwistWithCovariance::covariance(
        std::array<double, 36>&& _covariance)
{
    m_covariance = std::move(_covariance);
}

/*!
 * @brief This function returns a constant reference to member covariance
 * @return Constant reference to member covariance
 */
const std::array<double, 36>& geometry_msgs__TwistWithCovariance::covariance() const
{
    return m_covariance;
}

/*!
 * @brief This function returns a reference to member covariance
 * @return Reference to member covariance
 */
std::array<double, 36>& geometry_msgs__TwistWithCovariance::covariance()
{
    return m_covariance;
}

size_t geometry_msgs__TwistWithCovariance::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t current_align = current_alignment;





    return current_align;
}

bool geometry_msgs__TwistWithCovariance::isKeyDefined()
{
    return false;
}

void geometry_msgs__TwistWithCovariance::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
      
}

geometry_msgs__TwistWithCovarianceStamped::geometry_msgs__TwistWithCovarianceStamped()
{
    // m_header com.eprosima.fastdds.idl.parser.typecode.StructTypeCode@314c508a

    // m_twist com.eprosima.fastdds.idl.parser.typecode.StructTypeCode@3c0a50da


}

geometry_msgs__TwistWithCovarianceStamped::~geometry_msgs__TwistWithCovarianceStamped()
{


}

geometry_msgs__TwistWithCovarianceStamped::geometry_msgs__TwistWithCovarianceStamped(
        const geometry_msgs__TwistWithCovarianceStamped& x)
{
    m_header = x.m_header;
    m_twist = x.m_twist;
}

geometry_msgs__TwistWithCovarianceStamped::geometry_msgs__TwistWithCovarianceStamped(
        geometry_msgs__TwistWithCovarianceStamped&& x)
{
    m_header = std::move(x.m_header);
    m_twist = std::move(x.m_twist);
}

geometry_msgs__TwistWithCovarianceStamped& geometry_msgs__TwistWithCovarianceStamped::operator =(
        const geometry_msgs__TwistWithCovarianceStamped& x)
{

    m_header = x.m_header;
    m_twist = x.m_twist;

    return *this;
}

geometry_msgs__TwistWithCovarianceStamped& geometry_msgs__TwistWithCovarianceStamped::operator =(
        geometry_msgs__TwistWithCovarianceStamped&& x)
{

    m_header = std::move(x.m_header);
    m_twist = std::move(x.m_twist);

    return *this;
}

bool geometry_msgs__TwistWithCovarianceStamped::operator ==(
        const geometry_msgs__TwistWithCovarianceStamped& x) const
{

    return (m_header == x.m_header && m_twist == x.m_twist);
}

bool geometry_msgs__TwistWithCovarianceStamped::operator !=(
        const geometry_msgs__TwistWithCovarianceStamped& x) const
{
    return !(*this == x);
}

size_t geometry_msgs__TwistWithCovarianceStamped::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t initial_alignment = current_alignment;


    current_alignment += std_msgs__Header::getMaxCdrSerializedSize(current_alignment);
    current_alignment += geometry_msgs__TwistWithCovariance::getMaxCdrSerializedSize(current_alignment);

    return current_alignment - initial_alignment;
}

size_t geometry_msgs__TwistWithCovarianceStamped::getCdrSerializedSize(
        const geometry_msgs__TwistWithCovarianceStamped& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += std_msgs__Header::getCdrSerializedSize(data.header(), current_alignment);
    current_alignment += geometry_msgs__TwistWithCovariance::getCdrSerializedSize(data.twist(), current_alignment);

    return current_alignment - initial_alignment;
}

void geometry_msgs__TwistWithCovarianceStamped::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_header;
    scdr << m_twist;

}

void geometry_msgs__TwistWithCovarianceStamped::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_header;
    dcdr >> m_twist;
}

/*!
 * @brief This function copies the value in member header
 * @param _header New value to be copied in member header
 */
void geometry_msgs__TwistWithCovarianceStamped::header(
        const std_msgs__Header& _header)
{
    m_header = _header;
}

/*!
 * @brief This function moves the value in member header
 * @param _header New value to be moved in member header
 */
void geometry_msgs__TwistWithCovarianceStamped::header(
        std_msgs__Header&& _header)
{
    m_header = std::move(_header);
}

/*!
 * @brief This function returns a constant reference to member header
 * @return Constant reference to member header
 */
const std_msgs__Header& geometry_msgs__TwistWithCovarianceStamped::header() const
{
    return m_header;
}

/*!
 * @brief This function returns a reference to member header
 * @return Reference to member header
 */
std_msgs__Header& geometry_msgs__TwistWithCovarianceStamped::header()
{
    return m_header;
}
/*!
 * @brief This function copies the value in member twist
 * @param _twist New value to be copied in member twist
 */
void geometry_msgs__TwistWithCovarianceStamped::twist(
        const geometry_msgs__TwistWithCovariance& _twist)
{
    m_twist = _twist;
}

/*!
 * @brief This function moves the value in member twist
 * @param _twist New value to be moved in member twist
 */
void geometry_msgs__TwistWithCovarianceStamped::twist(
        geometry_msgs__TwistWithCovariance&& _twist)
{
    m_twist = std::move(_twist);
}

/*!
 * @brief This function returns a constant reference to member twist
 * @return Constant reference to member twist
 */
const geometry_msgs__TwistWithCovariance& geometry_msgs__TwistWithCovarianceStamped::twist() const
{
    return m_twist;
}

/*!
 * @brief This function returns a reference to member twist
 * @return Reference to member twist
 */
geometry_msgs__TwistWithCovariance& geometry_msgs__TwistWithCovarianceStamped::twist()
{
    return m_twist;
}

size_t geometry_msgs__TwistWithCovarianceStamped::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t current_align = current_alignment;





    return current_align;
}

bool geometry_msgs__TwistWithCovarianceStamped::isKeyDefined()
{
    return false;
}

void geometry_msgs__TwistWithCovarianceStamped::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
      
}

geometry_msgs__Pose::geometry_msgs__Pose()
{
    // m_position com.eprosima.fastdds.idl.parser.typecode.StructTypeCode@dd3b207

    // m_orientation com.eprosima.fastdds.idl.parser.typecode.StructTypeCode@551bdc27


}

geometry_msgs__Pose::~geometry_msgs__Pose()
{


}

geometry_msgs__Pose::geometry_msgs__Pose(
        const geometry_msgs__Pose& x)
{
    m_position = x.m_position;
    m_orientation = x.m_orientation;
}

geometry_msgs__Pose::geometry_msgs__Pose(
        geometry_msgs__Pose&& x)
{
    m_position = std::move(x.m_position);
    m_orientation = std::move(x.m_orientation);
}

geometry_msgs__Pose& geometry_msgs__Pose::operator =(
        const geometry_msgs__Pose& x)
{

    m_position = x.m_position;
    m_orientation = x.m_orientation;

    return *this;
}

geometry_msgs__Pose& geometry_msgs__Pose::operator =(
        geometry_msgs__Pose&& x)
{

    m_position = std::move(x.m_position);
    m_orientation = std::move(x.m_orientation);

    return *this;
}

bool geometry_msgs__Pose::operator ==(
        const geometry_msgs__Pose& x) const
{

    return (m_position == x.m_position && m_orientation == x.m_orientation);
}

bool geometry_msgs__Pose::operator !=(
        const geometry_msgs__Pose& x) const
{
    return !(*this == x);
}

size_t geometry_msgs__Pose::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t initial_alignment = current_alignment;


    current_alignment += geometry_msgs__Point::getMaxCdrSerializedSize(current_alignment);
    current_alignment += geometry_msgs__Quaternion::getMaxCdrSerializedSize(current_alignment);

    return current_alignment - initial_alignment;
}

size_t geometry_msgs__Pose::getCdrSerializedSize(
        const geometry_msgs__Pose& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += geometry_msgs__Point::getCdrSerializedSize(data.position(), current_alignment);
    current_alignment += geometry_msgs__Quaternion::getCdrSerializedSize(data.orientation(), current_alignment);

    return current_alignment - initial_alignment;
}

void geometry_msgs__Pose::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_position;
    scdr << m_orientation;

}

void geometry_msgs__Pose::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_position;
    dcdr >> m_orientation;
}

/*!
 * @brief This function copies the value in member position
 * @param _position New value to be copied in member position
 */
void geometry_msgs__Pose::position(
        const geometry_msgs__Point& _position)
{
    m_position = _position;
}

/*!
 * @brief This function moves the value in member position
 * @param _position New value to be moved in member position
 */
void geometry_msgs__Pose::position(
        geometry_msgs__Point&& _position)
{
    m_position = std::move(_position);
}

/*!
 * @brief This function returns a constant reference to member position
 * @return Constant reference to member position
 */
const geometry_msgs__Point& geometry_msgs__Pose::position() const
{
    return m_position;
}

/*!
 * @brief This function returns a reference to member position
 * @return Reference to member position
 */
geometry_msgs__Point& geometry_msgs__Pose::position()
{
    return m_position;
}
/*!
 * @brief This function copies the value in member orientation
 * @param _orientation New value to be copied in member orientation
 */
void geometry_msgs__Pose::orientation(
        const geometry_msgs__Quaternion& _orientation)
{
    m_orientation = _orientation;
}

/*!
 * @brief This function moves the value in member orientation
 * @param _orientation New value to be moved in member orientation
 */
void geometry_msgs__Pose::orientation(
        geometry_msgs__Quaternion&& _orientation)
{
    m_orientation = std::move(_orientation);
}

/*!
 * @brief This function returns a constant reference to member orientation
 * @return Constant reference to member orientation
 */
const geometry_msgs__Quaternion& geometry_msgs__Pose::orientation() const
{
    return m_orientation;
}

/*!
 * @brief This function returns a reference to member orientation
 * @return Reference to member orientation
 */
geometry_msgs__Quaternion& geometry_msgs__Pose::orientation()
{
    return m_orientation;
}

size_t geometry_msgs__Pose::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t current_align = current_alignment;





    return current_align;
}

bool geometry_msgs__Pose::isKeyDefined()
{
    return false;
}

void geometry_msgs__Pose::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
      
}

geometry_msgs__PoseStamped::geometry_msgs__PoseStamped()
{
    // m_header com.eprosima.fastdds.idl.parser.typecode.StructTypeCode@314c508a

    // m_pose com.eprosima.fastdds.idl.parser.typecode.StructTypeCode@58fdd99


}

geometry_msgs__PoseStamped::~geometry_msgs__PoseStamped()
{


}

geometry_msgs__PoseStamped::geometry_msgs__PoseStamped(
        const geometry_msgs__PoseStamped& x)
{
    m_header = x.m_header;
    m_pose = x.m_pose;
}

geometry_msgs__PoseStamped::geometry_msgs__PoseStamped(
        geometry_msgs__PoseStamped&& x)
{
    m_header = std::move(x.m_header);
    m_pose = std::move(x.m_pose);
}

geometry_msgs__PoseStamped& geometry_msgs__PoseStamped::operator =(
        const geometry_msgs__PoseStamped& x)
{

    m_header = x.m_header;
    m_pose = x.m_pose;

    return *this;
}

geometry_msgs__PoseStamped& geometry_msgs__PoseStamped::operator =(
        geometry_msgs__PoseStamped&& x)
{

    m_header = std::move(x.m_header);
    m_pose = std::move(x.m_pose);

    return *this;
}

bool geometry_msgs__PoseStamped::operator ==(
        const geometry_msgs__PoseStamped& x) const
{

    return (m_header == x.m_header && m_pose == x.m_pose);
}

bool geometry_msgs__PoseStamped::operator !=(
        const geometry_msgs__PoseStamped& x) const
{
    return !(*this == x);
}

size_t geometry_msgs__PoseStamped::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t initial_alignment = current_alignment;


    current_alignment += std_msgs__Header::getMaxCdrSerializedSize(current_alignment);
    current_alignment += geometry_msgs__Pose::getMaxCdrSerializedSize(current_alignment);

    return current_alignment - initial_alignment;
}

size_t geometry_msgs__PoseStamped::getCdrSerializedSize(
        const geometry_msgs__PoseStamped& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += std_msgs__Header::getCdrSerializedSize(data.header(), current_alignment);
    current_alignment += geometry_msgs__Pose::getCdrSerializedSize(data.pose(), current_alignment);

    return current_alignment - initial_alignment;
}

void geometry_msgs__PoseStamped::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_header;
    scdr << m_pose;

}

void geometry_msgs__PoseStamped::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_header;
    dcdr >> m_pose;
}

/*!
 * @brief This function copies the value in member header
 * @param _header New value to be copied in member header
 */
void geometry_msgs__PoseStamped::header(
        const std_msgs__Header& _header)
{
    m_header = _header;
}

/*!
 * @brief This function moves the value in member header
 * @param _header New value to be moved in member header
 */
void geometry_msgs__PoseStamped::header(
        std_msgs__Header&& _header)
{
    m_header = std::move(_header);
}

/*!
 * @brief This function returns a constant reference to member header
 * @return Constant reference to member header
 */
const std_msgs__Header& geometry_msgs__PoseStamped::header() const
{
    return m_header;
}

/*!
 * @brief This function returns a reference to member header
 * @return Reference to member header
 */
std_msgs__Header& geometry_msgs__PoseStamped::header()
{
    return m_header;
}
/*!
 * @brief This function copies the value in member pose
 * @param _pose New value to be copied in member pose
 */
void geometry_msgs__PoseStamped::pose(
        const geometry_msgs__Pose& _pose)
{
    m_pose = _pose;
}

/*!
 * @brief This function moves the value in member pose
 * @param _pose New value to be moved in member pose
 */
void geometry_msgs__PoseStamped::pose(
        geometry_msgs__Pose&& _pose)
{
    m_pose = std::move(_pose);
}

/*!
 * @brief This function returns a constant reference to member pose
 * @return Constant reference to member pose
 */
const geometry_msgs__Pose& geometry_msgs__PoseStamped::pose() const
{
    return m_pose;
}

/*!
 * @brief This function returns a reference to member pose
 * @return Reference to member pose
 */
geometry_msgs__Pose& geometry_msgs__PoseStamped::pose()
{
    return m_pose;
}

size_t geometry_msgs__PoseStamped::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t current_align = current_alignment;





    return current_align;
}

bool geometry_msgs__PoseStamped::isKeyDefined()
{
    return false;
}

void geometry_msgs__PoseStamped::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
      
}

geometry_msgs__PoseWithCovariance::geometry_msgs__PoseWithCovariance()
{
    // m_pose com.eprosima.fastdds.idl.parser.typecode.StructTypeCode@58fdd99

    // m_covariance com.eprosima.idl.parser.typecode.ArrayTypeCode@709ba3fb
    memset(&m_covariance, 0, (36) * 8);

}

geometry_msgs__PoseWithCovariance::~geometry_msgs__PoseWithCovariance()
{


}

geometry_msgs__PoseWithCovariance::geometry_msgs__PoseWithCovariance(
        const geometry_msgs__PoseWithCovariance& x)
{
    m_pose = x.m_pose;
    m_covariance = x.m_covariance;
}

geometry_msgs__PoseWithCovariance::geometry_msgs__PoseWithCovariance(
        geometry_msgs__PoseWithCovariance&& x)
{
    m_pose = std::move(x.m_pose);
    m_covariance = std::move(x.m_covariance);
}

geometry_msgs__PoseWithCovariance& geometry_msgs__PoseWithCovariance::operator =(
        const geometry_msgs__PoseWithCovariance& x)
{

    m_pose = x.m_pose;
    m_covariance = x.m_covariance;

    return *this;
}

geometry_msgs__PoseWithCovariance& geometry_msgs__PoseWithCovariance::operator =(
        geometry_msgs__PoseWithCovariance&& x)
{

    m_pose = std::move(x.m_pose);
    m_covariance = std::move(x.m_covariance);

    return *this;
}

bool geometry_msgs__PoseWithCovariance::operator ==(
        const geometry_msgs__PoseWithCovariance& x) const
{

    return (m_pose == x.m_pose && m_covariance == x.m_covariance);
}

bool geometry_msgs__PoseWithCovariance::operator !=(
        const geometry_msgs__PoseWithCovariance& x) const
{
    return !(*this == x);
}

size_t geometry_msgs__PoseWithCovariance::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t initial_alignment = current_alignment;


    current_alignment += geometry_msgs__Pose::getMaxCdrSerializedSize(current_alignment);
    current_alignment += ((36) * 8) + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);



    return current_alignment - initial_alignment;
}

size_t geometry_msgs__PoseWithCovariance::getCdrSerializedSize(
        const geometry_msgs__PoseWithCovariance& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += geometry_msgs__Pose::getCdrSerializedSize(data.pose(), current_alignment);
    if ((36) > 0)
    {
        current_alignment += ((36) * 8) + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);
    }


    return current_alignment - initial_alignment;
}

void geometry_msgs__PoseWithCovariance::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_pose;
    scdr << m_covariance;


}

void geometry_msgs__PoseWithCovariance::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_pose;
    dcdr >> m_covariance;

}

/*!
 * @brief This function copies the value in member pose
 * @param _pose New value to be copied in member pose
 */
void geometry_msgs__PoseWithCovariance::pose(
        const geometry_msgs__Pose& _pose)
{
    m_pose = _pose;
}

/*!
 * @brief This function moves the value in member pose
 * @param _pose New value to be moved in member pose
 */
void geometry_msgs__PoseWithCovariance::pose(
        geometry_msgs__Pose&& _pose)
{
    m_pose = std::move(_pose);
}

/*!
 * @brief This function returns a constant reference to member pose
 * @return Constant reference to member pose
 */
const geometry_msgs__Pose& geometry_msgs__PoseWithCovariance::pose() const
{
    return m_pose;
}

/*!
 * @brief This function returns a reference to member pose
 * @return Reference to member pose
 */
geometry_msgs__Pose& geometry_msgs__PoseWithCovariance::pose()
{
    return m_pose;
}
/*!
 * @brief This function copies the value in member covariance
 * @param _covariance New value to be copied in member covariance
 */
void geometry_msgs__PoseWithCovariance::covariance(
        const std::array<double, 36>& _covariance)
{
    m_covariance = _covariance;
}

/*!
 * @brief This function moves the value in member covariance
 * @param _covariance New value to be moved in member covariance
 */
void geometry_msgs__PoseWithCovariance::covariance(
        std::array<double, 36>&& _covariance)
{
    m_covariance = std::move(_covariance);
}

/*!
 * @brief This function returns a constant reference to member covariance
 * @return Constant reference to member covariance
 */
const std::array<double, 36>& geometry_msgs__PoseWithCovariance::covariance() const
{
    return m_covariance;
}

/*!
 * @brief This function returns a reference to member covariance
 * @return Reference to member covariance
 */
std::array<double, 36>& geometry_msgs__PoseWithCovariance::covariance()
{
    return m_covariance;
}

size_t geometry_msgs__PoseWithCovariance::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t current_align = current_alignment;





    return current_align;
}

bool geometry_msgs__PoseWithCovariance::isKeyDefined()
{
    return false;
}

void geometry_msgs__PoseWithCovariance::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
      
}

geometry_msgs__PoseWithCovarianceStamped::geometry_msgs__PoseWithCovarianceStamped()
{
    // m_header com.eprosima.fastdds.idl.parser.typecode.StructTypeCode@314c508a

    // m_pose com.eprosima.fastdds.idl.parser.typecode.StructTypeCode@3f200884


}

geometry_msgs__PoseWithCovarianceStamped::~geometry_msgs__PoseWithCovarianceStamped()
{


}

geometry_msgs__PoseWithCovarianceStamped::geometry_msgs__PoseWithCovarianceStamped(
        const geometry_msgs__PoseWithCovarianceStamped& x)
{
    m_header = x.m_header;
    m_pose = x.m_pose;
}

geometry_msgs__PoseWithCovarianceStamped::geometry_msgs__PoseWithCovarianceStamped(
        geometry_msgs__PoseWithCovarianceStamped&& x)
{
    m_header = std::move(x.m_header);
    m_pose = std::move(x.m_pose);
}

geometry_msgs__PoseWithCovarianceStamped& geometry_msgs__PoseWithCovarianceStamped::operator =(
        const geometry_msgs__PoseWithCovarianceStamped& x)
{

    m_header = x.m_header;
    m_pose = x.m_pose;

    return *this;
}

geometry_msgs__PoseWithCovarianceStamped& geometry_msgs__PoseWithCovarianceStamped::operator =(
        geometry_msgs__PoseWithCovarianceStamped&& x)
{

    m_header = std::move(x.m_header);
    m_pose = std::move(x.m_pose);

    return *this;
}

bool geometry_msgs__PoseWithCovarianceStamped::operator ==(
        const geometry_msgs__PoseWithCovarianceStamped& x) const
{

    return (m_header == x.m_header && m_pose == x.m_pose);
}

bool geometry_msgs__PoseWithCovarianceStamped::operator !=(
        const geometry_msgs__PoseWithCovarianceStamped& x) const
{
    return !(*this == x);
}

size_t geometry_msgs__PoseWithCovarianceStamped::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t initial_alignment = current_alignment;


    current_alignment += std_msgs__Header::getMaxCdrSerializedSize(current_alignment);
    current_alignment += geometry_msgs__PoseWithCovariance::getMaxCdrSerializedSize(current_alignment);

    return current_alignment - initial_alignment;
}

size_t geometry_msgs__PoseWithCovarianceStamped::getCdrSerializedSize(
        const geometry_msgs__PoseWithCovarianceStamped& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += std_msgs__Header::getCdrSerializedSize(data.header(), current_alignment);
    current_alignment += geometry_msgs__PoseWithCovariance::getCdrSerializedSize(data.pose(), current_alignment);

    return current_alignment - initial_alignment;
}

void geometry_msgs__PoseWithCovarianceStamped::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_header;
    scdr << m_pose;

}

void geometry_msgs__PoseWithCovarianceStamped::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_header;
    dcdr >> m_pose;
}

/*!
 * @brief This function copies the value in member header
 * @param _header New value to be copied in member header
 */
void geometry_msgs__PoseWithCovarianceStamped::header(
        const std_msgs__Header& _header)
{
    m_header = _header;
}

/*!
 * @brief This function moves the value in member header
 * @param _header New value to be moved in member header
 */
void geometry_msgs__PoseWithCovarianceStamped::header(
        std_msgs__Header&& _header)
{
    m_header = std::move(_header);
}

/*!
 * @brief This function returns a constant reference to member header
 * @return Constant reference to member header
 */
const std_msgs__Header& geometry_msgs__PoseWithCovarianceStamped::header() const
{
    return m_header;
}

/*!
 * @brief This function returns a reference to member header
 * @return Reference to member header
 */
std_msgs__Header& geometry_msgs__PoseWithCovarianceStamped::header()
{
    return m_header;
}
/*!
 * @brief This function copies the value in member pose
 * @param _pose New value to be copied in member pose
 */
void geometry_msgs__PoseWithCovarianceStamped::pose(
        const geometry_msgs__PoseWithCovariance& _pose)
{
    m_pose = _pose;
}

/*!
 * @brief This function moves the value in member pose
 * @param _pose New value to be moved in member pose
 */
void geometry_msgs__PoseWithCovarianceStamped::pose(
        geometry_msgs__PoseWithCovariance&& _pose)
{
    m_pose = std::move(_pose);
}

/*!
 * @brief This function returns a constant reference to member pose
 * @return Constant reference to member pose
 */
const geometry_msgs__PoseWithCovariance& geometry_msgs__PoseWithCovarianceStamped::pose() const
{
    return m_pose;
}

/*!
 * @brief This function returns a reference to member pose
 * @return Reference to member pose
 */
geometry_msgs__PoseWithCovariance& geometry_msgs__PoseWithCovarianceStamped::pose()
{
    return m_pose;
}

size_t geometry_msgs__PoseWithCovarianceStamped::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t current_align = current_alignment;





    return current_align;
}

bool geometry_msgs__PoseWithCovarianceStamped::isKeyDefined()
{
    return false;
}

void geometry_msgs__PoseWithCovarianceStamped::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
      
}

sensor_msgs__Imu::sensor_msgs__Imu()
{
    // m_header com.eprosima.fastdds.idl.parser.typecode.StructTypeCode@314c508a

    // m_orientation com.eprosima.fastdds.idl.parser.typecode.StructTypeCode@551bdc27

    // m_orientation_covariance com.eprosima.idl.parser.typecode.ArrayTypeCode@4d339552
    memset(&m_orientation_covariance, 0, (9) * 8);
    // m_angular_velocity com.eprosima.fastdds.idl.parser.typecode.StructTypeCode@12405818

    // m_angular_velocity_covariance com.eprosima.idl.parser.typecode.ArrayTypeCode@f0f2775
    memset(&m_angular_velocity_covariance, 0, (9) * 8);
    // m_linear_acceleration com.eprosima.fastdds.idl.parser.typecode.StructTypeCode@12405818

    // m_linear_acceleration_covariance com.eprosima.idl.parser.typecode.ArrayTypeCode@5a4aa2f2
    memset(&m_linear_acceleration_covariance, 0, (9) * 8);

}

sensor_msgs__Imu::~sensor_msgs__Imu()
{







}

sensor_msgs__Imu::sensor_msgs__Imu(
        const sensor_msgs__Imu& x)
{
    m_header = x.m_header;
    m_orientation = x.m_orientation;
    m_orientation_covariance = x.m_orientation_covariance;
    m_angular_velocity = x.m_angular_velocity;
    m_angular_velocity_covariance = x.m_angular_velocity_covariance;
    m_linear_acceleration = x.m_linear_acceleration;
    m_linear_acceleration_covariance = x.m_linear_acceleration_covariance;
}

sensor_msgs__Imu::sensor_msgs__Imu(
        sensor_msgs__Imu&& x)
{
    m_header = std::move(x.m_header);
    m_orientation = std::move(x.m_orientation);
    m_orientation_covariance = std::move(x.m_orientation_covariance);
    m_angular_velocity = std::move(x.m_angular_velocity);
    m_angular_velocity_covariance = std::move(x.m_angular_velocity_covariance);
    m_linear_acceleration = std::move(x.m_linear_acceleration);
    m_linear_acceleration_covariance = std::move(x.m_linear_acceleration_covariance);
}

sensor_msgs__Imu& sensor_msgs__Imu::operator =(
        const sensor_msgs__Imu& x)
{

    m_header = x.m_header;
    m_orientation = x.m_orientation;
    m_orientation_covariance = x.m_orientation_covariance;
    m_angular_velocity = x.m_angular_velocity;
    m_angular_velocity_covariance = x.m_angular_velocity_covariance;
    m_linear_acceleration = x.m_linear_acceleration;
    m_linear_acceleration_covariance = x.m_linear_acceleration_covariance;

    return *this;
}

sensor_msgs__Imu& sensor_msgs__Imu::operator =(
        sensor_msgs__Imu&& x)
{

    m_header = std::move(x.m_header);
    m_orientation = std::move(x.m_orientation);
    m_orientation_covariance = std::move(x.m_orientation_covariance);
    m_angular_velocity = std::move(x.m_angular_velocity);
    m_angular_velocity_covariance = std::move(x.m_angular_velocity_covariance);
    m_linear_acceleration = std::move(x.m_linear_acceleration);
    m_linear_acceleration_covariance = std::move(x.m_linear_acceleration_covariance);

    return *this;
}

bool sensor_msgs__Imu::operator ==(
        const sensor_msgs__Imu& x) const
{

    return (m_header == x.m_header && m_orientation == x.m_orientation && m_orientation_covariance == x.m_orientation_covariance && m_angular_velocity == x.m_angular_velocity && m_angular_velocity_covariance == x.m_angular_velocity_covariance && m_linear_acceleration == x.m_linear_acceleration && m_linear_acceleration_covariance == x.m_linear_acceleration_covariance);
}

bool sensor_msgs__Imu::operator !=(
        const sensor_msgs__Imu& x) const
{
    return !(*this == x);
}

size_t sensor_msgs__Imu::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t initial_alignment = current_alignment;


    current_alignment += std_msgs__Header::getMaxCdrSerializedSize(current_alignment);
    current_alignment += geometry_msgs__Quaternion::getMaxCdrSerializedSize(current_alignment);
    current_alignment += ((9) * 8) + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    current_alignment += geometry_msgs__Vector3::getMaxCdrSerializedSize(current_alignment);
    current_alignment += ((9) * 8) + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    current_alignment += geometry_msgs__Vector3::getMaxCdrSerializedSize(current_alignment);
    current_alignment += ((9) * 8) + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);



    return current_alignment - initial_alignment;
}

size_t sensor_msgs__Imu::getCdrSerializedSize(
        const sensor_msgs__Imu& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += std_msgs__Header::getCdrSerializedSize(data.header(), current_alignment);
    current_alignment += geometry_msgs__Quaternion::getCdrSerializedSize(data.orientation(), current_alignment);
    if ((9) > 0)
    {
        current_alignment += ((9) * 8) + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);
    }

    current_alignment += geometry_msgs__Vector3::getCdrSerializedSize(data.angular_velocity(), current_alignment);
    if ((9) > 0)
    {
        current_alignment += ((9) * 8) + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);
    }

    current_alignment += geometry_msgs__Vector3::getCdrSerializedSize(data.linear_acceleration(), current_alignment);
    if ((9) > 0)
    {
        current_alignment += ((9) * 8) + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);
    }


    return current_alignment - initial_alignment;
}

void sensor_msgs__Imu::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_header;
    scdr << m_orientation;
    scdr << m_orientation_covariance;

    scdr << m_angular_velocity;
    scdr << m_angular_velocity_covariance;

    scdr << m_linear_acceleration;
    scdr << m_linear_acceleration_covariance;


}

void sensor_msgs__Imu::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_header;
    dcdr >> m_orientation;
    dcdr >> m_orientation_covariance;

    dcdr >> m_angular_velocity;
    dcdr >> m_angular_velocity_covariance;

    dcdr >> m_linear_acceleration;
    dcdr >> m_linear_acceleration_covariance;

}

/*!
 * @brief This function copies the value in member header
 * @param _header New value to be copied in member header
 */
void sensor_msgs__Imu::header(
        const std_msgs__Header& _header)
{
    m_header = _header;
}

/*!
 * @brief This function moves the value in member header
 * @param _header New value to be moved in member header
 */
void sensor_msgs__Imu::header(
        std_msgs__Header&& _header)
{
    m_header = std::move(_header);
}

/*!
 * @brief This function returns a constant reference to member header
 * @return Constant reference to member header
 */
const std_msgs__Header& sensor_msgs__Imu::header() const
{
    return m_header;
}

/*!
 * @brief This function returns a reference to member header
 * @return Reference to member header
 */
std_msgs__Header& sensor_msgs__Imu::header()
{
    return m_header;
}
/*!
 * @brief This function copies the value in member orientation
 * @param _orientation New value to be copied in member orientation
 */
void sensor_msgs__Imu::orientation(
        const geometry_msgs__Quaternion& _orientation)
{
    m_orientation = _orientation;
}

/*!
 * @brief This function moves the value in member orientation
 * @param _orientation New value to be moved in member orientation
 */
void sensor_msgs__Imu::orientation(
        geometry_msgs__Quaternion&& _orientation)
{
    m_orientation = std::move(_orientation);
}

/*!
 * @brief This function returns a constant reference to member orientation
 * @return Constant reference to member orientation
 */
const geometry_msgs__Quaternion& sensor_msgs__Imu::orientation() const
{
    return m_orientation;
}

/*!
 * @brief This function returns a reference to member orientation
 * @return Reference to member orientation
 */
geometry_msgs__Quaternion& sensor_msgs__Imu::orientation()
{
    return m_orientation;
}
/*!
 * @brief This function copies the value in member orientation_covariance
 * @param _orientation_covariance New value to be copied in member orientation_covariance
 */
void sensor_msgs__Imu::orientation_covariance(
        const std::array<double, 9>& _orientation_covariance)
{
    m_orientation_covariance = _orientation_covariance;
}

/*!
 * @brief This function moves the value in member orientation_covariance
 * @param _orientation_covariance New value to be moved in member orientation_covariance
 */
void sensor_msgs__Imu::orientation_covariance(
        std::array<double, 9>&& _orientation_covariance)
{
    m_orientation_covariance = std::move(_orientation_covariance);
}

/*!
 * @brief This function returns a constant reference to member orientation_covariance
 * @return Constant reference to member orientation_covariance
 */
const std::array<double, 9>& sensor_msgs__Imu::orientation_covariance() const
{
    return m_orientation_covariance;
}

/*!
 * @brief This function returns a reference to member orientation_covariance
 * @return Reference to member orientation_covariance
 */
std::array<double, 9>& sensor_msgs__Imu::orientation_covariance()
{
    return m_orientation_covariance;
}
/*!
 * @brief This function copies the value in member angular_velocity
 * @param _angular_velocity New value to be copied in member angular_velocity
 */
void sensor_msgs__Imu::angular_velocity(
        const geometry_msgs__Vector3& _angular_velocity)
{
    m_angular_velocity = _angular_velocity;
}

/*!
 * @brief This function moves the value in member angular_velocity
 * @param _angular_velocity New value to be moved in member angular_velocity
 */
void sensor_msgs__Imu::angular_velocity(
        geometry_msgs__Vector3&& _angular_velocity)
{
    m_angular_velocity = std::move(_angular_velocity);
}

/*!
 * @brief This function returns a constant reference to member angular_velocity
 * @return Constant reference to member angular_velocity
 */
const geometry_msgs__Vector3& sensor_msgs__Imu::angular_velocity() const
{
    return m_angular_velocity;
}

/*!
 * @brief This function returns a reference to member angular_velocity
 * @return Reference to member angular_velocity
 */
geometry_msgs__Vector3& sensor_msgs__Imu::angular_velocity()
{
    return m_angular_velocity;
}
/*!
 * @brief This function copies the value in member angular_velocity_covariance
 * @param _angular_velocity_covariance New value to be copied in member angular_velocity_covariance
 */
void sensor_msgs__Imu::angular_velocity_covariance(
        const std::array<double, 9>& _angular_velocity_covariance)
{
    m_angular_velocity_covariance = _angular_velocity_covariance;
}

/*!
 * @brief This function moves the value in member angular_velocity_covariance
 * @param _angular_velocity_covariance New value to be moved in member angular_velocity_covariance
 */
void sensor_msgs__Imu::angular_velocity_covariance(
        std::array<double, 9>&& _angular_velocity_covariance)
{
    m_angular_velocity_covariance = std::move(_angular_velocity_covariance);
}

/*!
 * @brief This function returns a constant reference to member angular_velocity_covariance
 * @return Constant reference to member angular_velocity_covariance
 */
const std::array<double, 9>& sensor_msgs__Imu::angular_velocity_covariance() const
{
    return m_angular_velocity_covariance;
}

/*!
 * @brief This function returns a reference to member angular_velocity_covariance
 * @return Reference to member angular_velocity_covariance
 */
std::array<double, 9>& sensor_msgs__Imu::angular_velocity_covariance()
{
    return m_angular_velocity_covariance;
}
/*!
 * @brief This function copies the value in member linear_acceleration
 * @param _linear_acceleration New value to be copied in member linear_acceleration
 */
void sensor_msgs__Imu::linear_acceleration(
        const geometry_msgs__Vector3& _linear_acceleration)
{
    m_linear_acceleration = _linear_acceleration;
}

/*!
 * @brief This function moves the value in member linear_acceleration
 * @param _linear_acceleration New value to be moved in member linear_acceleration
 */
void sensor_msgs__Imu::linear_acceleration(
        geometry_msgs__Vector3&& _linear_acceleration)
{
    m_linear_acceleration = std::move(_linear_acceleration);
}

/*!
 * @brief This function returns a constant reference to member linear_acceleration
 * @return Constant reference to member linear_acceleration
 */
const geometry_msgs__Vector3& sensor_msgs__Imu::linear_acceleration() const
{
    return m_linear_acceleration;
}

/*!
 * @brief This function returns a reference to member linear_acceleration
 * @return Reference to member linear_acceleration
 */
geometry_msgs__Vector3& sensor_msgs__Imu::linear_acceleration()
{
    return m_linear_acceleration;
}
/*!
 * @brief This function copies the value in member linear_acceleration_covariance
 * @param _linear_acceleration_covariance New value to be copied in member linear_acceleration_covariance
 */
void sensor_msgs__Imu::linear_acceleration_covariance(
        const std::array<double, 9>& _linear_acceleration_covariance)
{
    m_linear_acceleration_covariance = _linear_acceleration_covariance;
}

/*!
 * @brief This function moves the value in member linear_acceleration_covariance
 * @param _linear_acceleration_covariance New value to be moved in member linear_acceleration_covariance
 */
void sensor_msgs__Imu::linear_acceleration_covariance(
        std::array<double, 9>&& _linear_acceleration_covariance)
{
    m_linear_acceleration_covariance = std::move(_linear_acceleration_covariance);
}

/*!
 * @brief This function returns a constant reference to member linear_acceleration_covariance
 * @return Constant reference to member linear_acceleration_covariance
 */
const std::array<double, 9>& sensor_msgs__Imu::linear_acceleration_covariance() const
{
    return m_linear_acceleration_covariance;
}

/*!
 * @brief This function returns a reference to member linear_acceleration_covariance
 * @return Reference to member linear_acceleration_covariance
 */
std::array<double, 9>& sensor_msgs__Imu::linear_acceleration_covariance()
{
    return m_linear_acceleration_covariance;
}

size_t sensor_msgs__Imu::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t current_align = current_alignment;










    return current_align;
}

bool sensor_msgs__Imu::isKeyDefined()
{
    return false;
}

void sensor_msgs__Imu::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
           
}

sensor_msgs__RegionOfInterest::sensor_msgs__RegionOfInterest()
{
    // m_x_offset com.eprosima.idl.parser.typecode.PrimitiveTypeCode@7fe8ea47
    m_x_offset = 0;
    // m_y_offset com.eprosima.idl.parser.typecode.PrimitiveTypeCode@226a82c4
    m_y_offset = 0;
    // m_height com.eprosima.idl.parser.typecode.PrimitiveTypeCode@731f8236
    m_height = 0;
    // m_width com.eprosima.idl.parser.typecode.PrimitiveTypeCode@255b53dc
    m_width = 0;
    // m_do_rectify com.eprosima.idl.parser.typecode.PrimitiveTypeCode@1dd92fe2
    m_do_rectify = false;

}

sensor_msgs__RegionOfInterest::~sensor_msgs__RegionOfInterest()
{





}

sensor_msgs__RegionOfInterest::sensor_msgs__RegionOfInterest(
        const sensor_msgs__RegionOfInterest& x)
{
    m_x_offset = x.m_x_offset;
    m_y_offset = x.m_y_offset;
    m_height = x.m_height;
    m_width = x.m_width;
    m_do_rectify = x.m_do_rectify;
}

sensor_msgs__RegionOfInterest::sensor_msgs__RegionOfInterest(
        sensor_msgs__RegionOfInterest&& x)
{
    m_x_offset = x.m_x_offset;
    m_y_offset = x.m_y_offset;
    m_height = x.m_height;
    m_width = x.m_width;
    m_do_rectify = x.m_do_rectify;
}

sensor_msgs__RegionOfInterest& sensor_msgs__RegionOfInterest::operator =(
        const sensor_msgs__RegionOfInterest& x)
{

    m_x_offset = x.m_x_offset;
    m_y_offset = x.m_y_offset;
    m_height = x.m_height;
    m_width = x.m_width;
    m_do_rectify = x.m_do_rectify;

    return *this;
}

sensor_msgs__RegionOfInterest& sensor_msgs__RegionOfInterest::operator =(
        sensor_msgs__RegionOfInterest&& x)
{

    m_x_offset = x.m_x_offset;
    m_y_offset = x.m_y_offset;
    m_height = x.m_height;
    m_width = x.m_width;
    m_do_rectify = x.m_do_rectify;

    return *this;
}

bool sensor_msgs__RegionOfInterest::operator ==(
        const sensor_msgs__RegionOfInterest& x) const
{

    return (m_x_offset == x.m_x_offset && m_y_offset == x.m_y_offset && m_height == x.m_height && m_width == x.m_width && m_do_rectify == x.m_do_rectify);
}

bool sensor_msgs__RegionOfInterest::operator !=(
        const sensor_msgs__RegionOfInterest& x) const
{
    return !(*this == x);
}

size_t sensor_msgs__RegionOfInterest::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);



    return current_alignment - initial_alignment;
}

size_t sensor_msgs__RegionOfInterest::getCdrSerializedSize(
        const sensor_msgs__RegionOfInterest& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);



    return current_alignment - initial_alignment;
}

void sensor_msgs__RegionOfInterest::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_x_offset;
    scdr << m_y_offset;
    scdr << m_height;
    scdr << m_width;
    scdr << m_do_rectify;

}

void sensor_msgs__RegionOfInterest::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_x_offset;
    dcdr >> m_y_offset;
    dcdr >> m_height;
    dcdr >> m_width;
    dcdr >> m_do_rectify;
}

/*!
 * @brief This function sets a value in member x_offset
 * @param _x_offset New value for member x_offset
 */
void sensor_msgs__RegionOfInterest::x_offset(
        uint32_t _x_offset)
{
    m_x_offset = _x_offset;
}

/*!
 * @brief This function returns the value of member x_offset
 * @return Value of member x_offset
 */
uint32_t sensor_msgs__RegionOfInterest::x_offset() const
{
    return m_x_offset;
}

/*!
 * @brief This function returns a reference to member x_offset
 * @return Reference to member x_offset
 */
uint32_t& sensor_msgs__RegionOfInterest::x_offset()
{
    return m_x_offset;
}

/*!
 * @brief This function sets a value in member y_offset
 * @param _y_offset New value for member y_offset
 */
void sensor_msgs__RegionOfInterest::y_offset(
        uint32_t _y_offset)
{
    m_y_offset = _y_offset;
}

/*!
 * @brief This function returns the value of member y_offset
 * @return Value of member y_offset
 */
uint32_t sensor_msgs__RegionOfInterest::y_offset() const
{
    return m_y_offset;
}

/*!
 * @brief This function returns a reference to member y_offset
 * @return Reference to member y_offset
 */
uint32_t& sensor_msgs__RegionOfInterest::y_offset()
{
    return m_y_offset;
}

/*!
 * @brief This function sets a value in member height
 * @param _height New value for member height
 */
void sensor_msgs__RegionOfInterest::height(
        uint32_t _height)
{
    m_height = _height;
}

/*!
 * @brief This function returns the value of member height
 * @return Value of member height
 */
uint32_t sensor_msgs__RegionOfInterest::height() const
{
    return m_height;
}

/*!
 * @brief This function returns a reference to member height
 * @return Reference to member height
 */
uint32_t& sensor_msgs__RegionOfInterest::height()
{
    return m_height;
}

/*!
 * @brief This function sets a value in member width
 * @param _width New value for member width
 */
void sensor_msgs__RegionOfInterest::width(
        uint32_t _width)
{
    m_width = _width;
}

/*!
 * @brief This function returns the value of member width
 * @return Value of member width
 */
uint32_t sensor_msgs__RegionOfInterest::width() const
{
    return m_width;
}

/*!
 * @brief This function returns a reference to member width
 * @return Reference to member width
 */
uint32_t& sensor_msgs__RegionOfInterest::width()
{
    return m_width;
}

/*!
 * @brief This function sets a value in member do_rectify
 * @param _do_rectify New value for member do_rectify
 */
void sensor_msgs__RegionOfInterest::do_rectify(
        bool _do_rectify)
{
    m_do_rectify = _do_rectify;
}

/*!
 * @brief This function returns the value of member do_rectify
 * @return Value of member do_rectify
 */
bool sensor_msgs__RegionOfInterest::do_rectify() const
{
    return m_do_rectify;
}

/*!
 * @brief This function returns a reference to member do_rectify
 * @return Reference to member do_rectify
 */
bool& sensor_msgs__RegionOfInterest::do_rectify()
{
    return m_do_rectify;
}


size_t sensor_msgs__RegionOfInterest::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t current_align = current_alignment;








    return current_align;
}

bool sensor_msgs__RegionOfInterest::isKeyDefined()
{
    return false;
}

void sensor_msgs__RegionOfInterest::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
         
}

sensor_msgs__CameraInfo::sensor_msgs__CameraInfo()
{
    // m_header com.eprosima.fastdds.idl.parser.typecode.StructTypeCode@314c508a

    // m_height com.eprosima.idl.parser.typecode.PrimitiveTypeCode@ca263c2
    m_height = 0;
    // m_width com.eprosima.idl.parser.typecode.PrimitiveTypeCode@589b3632
    m_width = 0;
    // m_distortion_model com.eprosima.idl.parser.typecode.StringTypeCode@45f45fa1
    m_distortion_model ="";
    // m_D com.eprosima.idl.parser.typecode.SequenceTypeCode@4c6e276e

    // m_K com.eprosima.idl.parser.typecode.ArrayTypeCode@534df152
    memset(&m_K, 0, (9) * 8);
    // m_R com.eprosima.idl.parser.typecode.ArrayTypeCode@52e677af
    memset(&m_R, 0, (9) * 8);
    // m_P com.eprosima.idl.parser.typecode.ArrayTypeCode@35083305
    memset(&m_P, 0, (12) * 8);
    // m_binning_x com.eprosima.idl.parser.typecode.PrimitiveTypeCode@8e0379d
    m_binning_x = 0;
    // m_binning_y com.eprosima.idl.parser.typecode.PrimitiveTypeCode@341b80b2
    m_binning_y = 0;
    // m_roi com.eprosima.fastdds.idl.parser.typecode.StructTypeCode@55a1c291


}

sensor_msgs__CameraInfo::~sensor_msgs__CameraInfo()
{











}

sensor_msgs__CameraInfo::sensor_msgs__CameraInfo(
        const sensor_msgs__CameraInfo& x)
{
    m_header = x.m_header;
    m_height = x.m_height;
    m_width = x.m_width;
    m_distortion_model = x.m_distortion_model;
    m_D = x.m_D;
    m_K = x.m_K;
    m_R = x.m_R;
    m_P = x.m_P;
    m_binning_x = x.m_binning_x;
    m_binning_y = x.m_binning_y;
    m_roi = x.m_roi;
}

sensor_msgs__CameraInfo::sensor_msgs__CameraInfo(
        sensor_msgs__CameraInfo&& x)
{
    m_header = std::move(x.m_header);
    m_height = x.m_height;
    m_width = x.m_width;
    m_distortion_model = std::move(x.m_distortion_model);
    m_D = std::move(x.m_D);
    m_K = std::move(x.m_K);
    m_R = std::move(x.m_R);
    m_P = std::move(x.m_P);
    m_binning_x = x.m_binning_x;
    m_binning_y = x.m_binning_y;
    m_roi = std::move(x.m_roi);
}

sensor_msgs__CameraInfo& sensor_msgs__CameraInfo::operator =(
        const sensor_msgs__CameraInfo& x)
{

    m_header = x.m_header;
    m_height = x.m_height;
    m_width = x.m_width;
    m_distortion_model = x.m_distortion_model;
    m_D = x.m_D;
    m_K = x.m_K;
    m_R = x.m_R;
    m_P = x.m_P;
    m_binning_x = x.m_binning_x;
    m_binning_y = x.m_binning_y;
    m_roi = x.m_roi;

    return *this;
}

sensor_msgs__CameraInfo& sensor_msgs__CameraInfo::operator =(
        sensor_msgs__CameraInfo&& x)
{

    m_header = std::move(x.m_header);
    m_height = x.m_height;
    m_width = x.m_width;
    m_distortion_model = std::move(x.m_distortion_model);
    m_D = std::move(x.m_D);
    m_K = std::move(x.m_K);
    m_R = std::move(x.m_R);
    m_P = std::move(x.m_P);
    m_binning_x = x.m_binning_x;
    m_binning_y = x.m_binning_y;
    m_roi = std::move(x.m_roi);

    return *this;
}

bool sensor_msgs__CameraInfo::operator ==(
        const sensor_msgs__CameraInfo& x) const
{

    return (m_header == x.m_header && m_height == x.m_height && m_width == x.m_width && m_distortion_model == x.m_distortion_model && m_D == x.m_D && m_K == x.m_K && m_R == x.m_R && m_P == x.m_P && m_binning_x == x.m_binning_x && m_binning_y == x.m_binning_y && m_roi == x.m_roi);
}

bool sensor_msgs__CameraInfo::operator !=(
        const sensor_msgs__CameraInfo& x) const
{
    return !(*this == x);
}

size_t sensor_msgs__CameraInfo::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t initial_alignment = current_alignment;


    current_alignment += std_msgs__Header::getMaxCdrSerializedSize(current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 255 + 1;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    current_alignment += (100 * 8) + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);



    current_alignment += ((9) * 8) + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    current_alignment += ((9) * 8) + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    current_alignment += ((12) * 8) + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += sensor_msgs__RegionOfInterest::getMaxCdrSerializedSize(current_alignment);

    return current_alignment - initial_alignment;
}

size_t sensor_msgs__CameraInfo::getCdrSerializedSize(
        const sensor_msgs__CameraInfo& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += std_msgs__Header::getCdrSerializedSize(data.header(), current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.distortion_model().size() + 1;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    if (data.D().size() > 0)
    {
        current_alignment += (data.D().size() * 8) + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);
    }



    if ((9) > 0)
    {
        current_alignment += ((9) * 8) + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);
    }

    if ((9) > 0)
    {
        current_alignment += ((9) * 8) + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);
    }

    if ((12) > 0)
    {
        current_alignment += ((12) * 8) + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);
    }

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += sensor_msgs__RegionOfInterest::getCdrSerializedSize(data.roi(), current_alignment);

    return current_alignment - initial_alignment;
}

void sensor_msgs__CameraInfo::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_header;
    scdr << m_height;
    scdr << m_width;
    scdr << m_distortion_model;
    scdr << m_D;
    scdr << m_K;

    scdr << m_R;

    scdr << m_P;

    scdr << m_binning_x;
    scdr << m_binning_y;
    scdr << m_roi;

}

void sensor_msgs__CameraInfo::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_header;
    dcdr >> m_height;
    dcdr >> m_width;
    dcdr >> m_distortion_model;
    dcdr >> m_D;
    dcdr >> m_K;

    dcdr >> m_R;

    dcdr >> m_P;

    dcdr >> m_binning_x;
    dcdr >> m_binning_y;
    dcdr >> m_roi;
}

/*!
 * @brief This function copies the value in member header
 * @param _header New value to be copied in member header
 */
void sensor_msgs__CameraInfo::header(
        const std_msgs__Header& _header)
{
    m_header = _header;
}

/*!
 * @brief This function moves the value in member header
 * @param _header New value to be moved in member header
 */
void sensor_msgs__CameraInfo::header(
        std_msgs__Header&& _header)
{
    m_header = std::move(_header);
}

/*!
 * @brief This function returns a constant reference to member header
 * @return Constant reference to member header
 */
const std_msgs__Header& sensor_msgs__CameraInfo::header() const
{
    return m_header;
}

/*!
 * @brief This function returns a reference to member header
 * @return Reference to member header
 */
std_msgs__Header& sensor_msgs__CameraInfo::header()
{
    return m_header;
}
/*!
 * @brief This function sets a value in member height
 * @param _height New value for member height
 */
void sensor_msgs__CameraInfo::height(
        uint32_t _height)
{
    m_height = _height;
}

/*!
 * @brief This function returns the value of member height
 * @return Value of member height
 */
uint32_t sensor_msgs__CameraInfo::height() const
{
    return m_height;
}

/*!
 * @brief This function returns a reference to member height
 * @return Reference to member height
 */
uint32_t& sensor_msgs__CameraInfo::height()
{
    return m_height;
}

/*!
 * @brief This function sets a value in member width
 * @param _width New value for member width
 */
void sensor_msgs__CameraInfo::width(
        uint32_t _width)
{
    m_width = _width;
}

/*!
 * @brief This function returns the value of member width
 * @return Value of member width
 */
uint32_t sensor_msgs__CameraInfo::width() const
{
    return m_width;
}

/*!
 * @brief This function returns a reference to member width
 * @return Reference to member width
 */
uint32_t& sensor_msgs__CameraInfo::width()
{
    return m_width;
}

/*!
 * @brief This function copies the value in member distortion_model
 * @param _distortion_model New value to be copied in member distortion_model
 */
void sensor_msgs__CameraInfo::distortion_model(
        const std::string& _distortion_model)
{
    m_distortion_model = _distortion_model;
}

/*!
 * @brief This function moves the value in member distortion_model
 * @param _distortion_model New value to be moved in member distortion_model
 */
void sensor_msgs__CameraInfo::distortion_model(
        std::string&& _distortion_model)
{
    m_distortion_model = std::move(_distortion_model);
}

/*!
 * @brief This function returns a constant reference to member distortion_model
 * @return Constant reference to member distortion_model
 */
const std::string& sensor_msgs__CameraInfo::distortion_model() const
{
    return m_distortion_model;
}

/*!
 * @brief This function returns a reference to member distortion_model
 * @return Reference to member distortion_model
 */
std::string& sensor_msgs__CameraInfo::distortion_model()
{
    return m_distortion_model;
}
/*!
 * @brief This function copies the value in member D
 * @param _D New value to be copied in member D
 */
void sensor_msgs__CameraInfo::D(
        const std::vector<double>& _D)
{
    m_D = _D;
}

/*!
 * @brief This function moves the value in member D
 * @param _D New value to be moved in member D
 */
void sensor_msgs__CameraInfo::D(
        std::vector<double>&& _D)
{
    m_D = std::move(_D);
}

/*!
 * @brief This function returns a constant reference to member D
 * @return Constant reference to member D
 */
const std::vector<double>& sensor_msgs__CameraInfo::D() const
{
    return m_D;
}

/*!
 * @brief This function returns a reference to member D
 * @return Reference to member D
 */
std::vector<double>& sensor_msgs__CameraInfo::D()
{
    return m_D;
}
/*!
 * @brief This function copies the value in member K
 * @param _K New value to be copied in member K
 */
void sensor_msgs__CameraInfo::K(
        const std::array<double, 9>& _K)
{
    m_K = _K;
}

/*!
 * @brief This function moves the value in member K
 * @param _K New value to be moved in member K
 */
void sensor_msgs__CameraInfo::K(
        std::array<double, 9>&& _K)
{
    m_K = std::move(_K);
}

/*!
 * @brief This function returns a constant reference to member K
 * @return Constant reference to member K
 */
const std::array<double, 9>& sensor_msgs__CameraInfo::K() const
{
    return m_K;
}

/*!
 * @brief This function returns a reference to member K
 * @return Reference to member K
 */
std::array<double, 9>& sensor_msgs__CameraInfo::K()
{
    return m_K;
}
/*!
 * @brief This function copies the value in member R
 * @param _R New value to be copied in member R
 */
void sensor_msgs__CameraInfo::R(
        const std::array<double, 9>& _R)
{
    m_R = _R;
}

/*!
 * @brief This function moves the value in member R
 * @param _R New value to be moved in member R
 */
void sensor_msgs__CameraInfo::R(
        std::array<double, 9>&& _R)
{
    m_R = std::move(_R);
}

/*!
 * @brief This function returns a constant reference to member R
 * @return Constant reference to member R
 */
const std::array<double, 9>& sensor_msgs__CameraInfo::R() const
{
    return m_R;
}

/*!
 * @brief This function returns a reference to member R
 * @return Reference to member R
 */
std::array<double, 9>& sensor_msgs__CameraInfo::R()
{
    return m_R;
}
/*!
 * @brief This function copies the value in member P
 * @param _P New value to be copied in member P
 */
void sensor_msgs__CameraInfo::P(
        const std::array<double, 12>& _P)
{
    m_P = _P;
}

/*!
 * @brief This function moves the value in member P
 * @param _P New value to be moved in member P
 */
void sensor_msgs__CameraInfo::P(
        std::array<double, 12>&& _P)
{
    m_P = std::move(_P);
}

/*!
 * @brief This function returns a constant reference to member P
 * @return Constant reference to member P
 */
const std::array<double, 12>& sensor_msgs__CameraInfo::P() const
{
    return m_P;
}

/*!
 * @brief This function returns a reference to member P
 * @return Reference to member P
 */
std::array<double, 12>& sensor_msgs__CameraInfo::P()
{
    return m_P;
}
/*!
 * @brief This function sets a value in member binning_x
 * @param _binning_x New value for member binning_x
 */
void sensor_msgs__CameraInfo::binning_x(
        uint32_t _binning_x)
{
    m_binning_x = _binning_x;
}

/*!
 * @brief This function returns the value of member binning_x
 * @return Value of member binning_x
 */
uint32_t sensor_msgs__CameraInfo::binning_x() const
{
    return m_binning_x;
}

/*!
 * @brief This function returns a reference to member binning_x
 * @return Reference to member binning_x
 */
uint32_t& sensor_msgs__CameraInfo::binning_x()
{
    return m_binning_x;
}

/*!
 * @brief This function sets a value in member binning_y
 * @param _binning_y New value for member binning_y
 */
void sensor_msgs__CameraInfo::binning_y(
        uint32_t _binning_y)
{
    m_binning_y = _binning_y;
}

/*!
 * @brief This function returns the value of member binning_y
 * @return Value of member binning_y
 */
uint32_t sensor_msgs__CameraInfo::binning_y() const
{
    return m_binning_y;
}

/*!
 * @brief This function returns a reference to member binning_y
 * @return Reference to member binning_y
 */
uint32_t& sensor_msgs__CameraInfo::binning_y()
{
    return m_binning_y;
}

/*!
 * @brief This function copies the value in member roi
 * @param _roi New value to be copied in member roi
 */
void sensor_msgs__CameraInfo::roi(
        const sensor_msgs__RegionOfInterest& _roi)
{
    m_roi = _roi;
}

/*!
 * @brief This function moves the value in member roi
 * @param _roi New value to be moved in member roi
 */
void sensor_msgs__CameraInfo::roi(
        sensor_msgs__RegionOfInterest&& _roi)
{
    m_roi = std::move(_roi);
}

/*!
 * @brief This function returns a constant reference to member roi
 * @return Constant reference to member roi
 */
const sensor_msgs__RegionOfInterest& sensor_msgs__CameraInfo::roi() const
{
    return m_roi;
}

/*!
 * @brief This function returns a reference to member roi
 * @return Reference to member roi
 */
sensor_msgs__RegionOfInterest& sensor_msgs__CameraInfo::roi()
{
    return m_roi;
}

size_t sensor_msgs__CameraInfo::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t current_align = current_alignment;














    return current_align;
}

bool sensor_msgs__CameraInfo::isKeyDefined()
{
    return false;
}

void sensor_msgs__CameraInfo::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
               
}

sensor_msgs__Image::sensor_msgs__Image()
{
    // m_header com.eprosima.fastdds.idl.parser.typecode.StructTypeCode@314c508a

    // m_height com.eprosima.idl.parser.typecode.PrimitiveTypeCode@482cd91f
    m_height = 0;
    // m_width com.eprosima.idl.parser.typecode.PrimitiveTypeCode@123f1134
    m_width = 0;
    // m_encoding com.eprosima.idl.parser.typecode.StringTypeCode@7d68ef40
    m_encoding ="";
    // m_is_bigendian com.eprosima.idl.parser.typecode.PrimitiveTypeCode@5b0abc94
    m_is_bigendian = 0;
    // m_step com.eprosima.idl.parser.typecode.PrimitiveTypeCode@75c072cb
    m_step = 0;
    // m_data com.eprosima.idl.parser.typecode.SequenceTypeCode@1f1c7bf6


}

sensor_msgs__Image::~sensor_msgs__Image()
{







}

sensor_msgs__Image::sensor_msgs__Image(
        const sensor_msgs__Image& x)
{
    m_header = x.m_header;
    m_height = x.m_height;
    m_width = x.m_width;
    m_encoding = x.m_encoding;
    m_is_bigendian = x.m_is_bigendian;
    m_step = x.m_step;
    m_data = x.m_data;
}

sensor_msgs__Image::sensor_msgs__Image(
        sensor_msgs__Image&& x)
{
    m_header = std::move(x.m_header);
    m_height = x.m_height;
    m_width = x.m_width;
    m_encoding = std::move(x.m_encoding);
    m_is_bigendian = x.m_is_bigendian;
    m_step = x.m_step;
    m_data = std::move(x.m_data);
}

sensor_msgs__Image& sensor_msgs__Image::operator =(
        const sensor_msgs__Image& x)
{

    m_header = x.m_header;
    m_height = x.m_height;
    m_width = x.m_width;
    m_encoding = x.m_encoding;
    m_is_bigendian = x.m_is_bigendian;
    m_step = x.m_step;
    m_data = x.m_data;

    return *this;
}

sensor_msgs__Image& sensor_msgs__Image::operator =(
        sensor_msgs__Image&& x)
{

    m_header = std::move(x.m_header);
    m_height = x.m_height;
    m_width = x.m_width;
    m_encoding = std::move(x.m_encoding);
    m_is_bigendian = x.m_is_bigendian;
    m_step = x.m_step;
    m_data = std::move(x.m_data);

    return *this;
}

bool sensor_msgs__Image::operator ==(
        const sensor_msgs__Image& x) const
{

    return (m_header == x.m_header && m_height == x.m_height && m_width == x.m_width && m_encoding == x.m_encoding && m_is_bigendian == x.m_is_bigendian && m_step == x.m_step && m_data == x.m_data);
}

bool sensor_msgs__Image::operator !=(
        const sensor_msgs__Image& x) const
{
    return !(*this == x);
}

size_t sensor_msgs__Image::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t initial_alignment = current_alignment;


    current_alignment += std_msgs__Header::getMaxCdrSerializedSize(current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 255 + 1;

    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    current_alignment += (100 * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);




    return current_alignment - initial_alignment;
}

size_t sensor_msgs__Image::getCdrSerializedSize(
        const sensor_msgs__Image& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += std_msgs__Header::getCdrSerializedSize(data.header(), current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.encoding().size() + 1;

    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    if (data.data().size() > 0)
    {
        current_alignment += (data.data().size() * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);
    }




    return current_alignment - initial_alignment;
}

void sensor_msgs__Image::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_header;
    scdr << m_height;
    scdr << m_width;
    scdr << m_encoding;
    scdr << m_is_bigendian;
    scdr << m_step;
    scdr << m_data;

}

void sensor_msgs__Image::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_header;
    dcdr >> m_height;
    dcdr >> m_width;
    dcdr >> m_encoding;
    dcdr >> m_is_bigendian;
    dcdr >> m_step;
    dcdr >> m_data;
}

/*!
 * @brief This function copies the value in member header
 * @param _header New value to be copied in member header
 */
void sensor_msgs__Image::header(
        const std_msgs__Header& _header)
{
    m_header = _header;
}

/*!
 * @brief This function moves the value in member header
 * @param _header New value to be moved in member header
 */
void sensor_msgs__Image::header(
        std_msgs__Header&& _header)
{
    m_header = std::move(_header);
}

/*!
 * @brief This function returns a constant reference to member header
 * @return Constant reference to member header
 */
const std_msgs__Header& sensor_msgs__Image::header() const
{
    return m_header;
}

/*!
 * @brief This function returns a reference to member header
 * @return Reference to member header
 */
std_msgs__Header& sensor_msgs__Image::header()
{
    return m_header;
}
/*!
 * @brief This function sets a value in member height
 * @param _height New value for member height
 */
void sensor_msgs__Image::height(
        uint32_t _height)
{
    m_height = _height;
}

/*!
 * @brief This function returns the value of member height
 * @return Value of member height
 */
uint32_t sensor_msgs__Image::height() const
{
    return m_height;
}

/*!
 * @brief This function returns a reference to member height
 * @return Reference to member height
 */
uint32_t& sensor_msgs__Image::height()
{
    return m_height;
}

/*!
 * @brief This function sets a value in member width
 * @param _width New value for member width
 */
void sensor_msgs__Image::width(
        uint32_t _width)
{
    m_width = _width;
}

/*!
 * @brief This function returns the value of member width
 * @return Value of member width
 */
uint32_t sensor_msgs__Image::width() const
{
    return m_width;
}

/*!
 * @brief This function returns a reference to member width
 * @return Reference to member width
 */
uint32_t& sensor_msgs__Image::width()
{
    return m_width;
}

/*!
 * @brief This function copies the value in member encoding
 * @param _encoding New value to be copied in member encoding
 */
void sensor_msgs__Image::encoding(
        const std::string& _encoding)
{
    m_encoding = _encoding;
}

/*!
 * @brief This function moves the value in member encoding
 * @param _encoding New value to be moved in member encoding
 */
void sensor_msgs__Image::encoding(
        std::string&& _encoding)
{
    m_encoding = std::move(_encoding);
}

/*!
 * @brief This function returns a constant reference to member encoding
 * @return Constant reference to member encoding
 */
const std::string& sensor_msgs__Image::encoding() const
{
    return m_encoding;
}

/*!
 * @brief This function returns a reference to member encoding
 * @return Reference to member encoding
 */
std::string& sensor_msgs__Image::encoding()
{
    return m_encoding;
}
/*!
 * @brief This function sets a value in member is_bigendian
 * @param _is_bigendian New value for member is_bigendian
 */
void sensor_msgs__Image::is_bigendian(
        uint8_t _is_bigendian)
{
    m_is_bigendian = _is_bigendian;
}

/*!
 * @brief This function returns the value of member is_bigendian
 * @return Value of member is_bigendian
 */
uint8_t sensor_msgs__Image::is_bigendian() const
{
    return m_is_bigendian;
}

/*!
 * @brief This function returns a reference to member is_bigendian
 * @return Reference to member is_bigendian
 */
uint8_t& sensor_msgs__Image::is_bigendian()
{
    return m_is_bigendian;
}

/*!
 * @brief This function sets a value in member step
 * @param _step New value for member step
 */
void sensor_msgs__Image::step(
        uint32_t _step)
{
    m_step = _step;
}

/*!
 * @brief This function returns the value of member step
 * @return Value of member step
 */
uint32_t sensor_msgs__Image::step() const
{
    return m_step;
}

/*!
 * @brief This function returns a reference to member step
 * @return Reference to member step
 */
uint32_t& sensor_msgs__Image::step()
{
    return m_step;
}

/*!
 * @brief This function copies the value in member data
 * @param _data New value to be copied in member data
 */
void sensor_msgs__Image::data(
        const std::vector<uint8_t>& _data)
{
    m_data = _data;
}

/*!
 * @brief This function moves the value in member data
 * @param _data New value to be moved in member data
 */
void sensor_msgs__Image::data(
        std::vector<uint8_t>&& _data)
{
    m_data = std::move(_data);
}

/*!
 * @brief This function returns a constant reference to member data
 * @return Constant reference to member data
 */
const std::vector<uint8_t>& sensor_msgs__Image::data() const
{
    return m_data;
}

/*!
 * @brief This function returns a reference to member data
 * @return Reference to member data
 */
std::vector<uint8_t>& sensor_msgs__Image::data()
{
    return m_data;
}

size_t sensor_msgs__Image::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t current_align = current_alignment;










    return current_align;
}

bool sensor_msgs__Image::isKeyDefined()
{
    return false;
}

void sensor_msgs__Image::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
           
}

sensor_msgs__CompressedImage::sensor_msgs__CompressedImage()
{
    // m_header com.eprosima.fastdds.idl.parser.typecode.StructTypeCode@314c508a

    // m_format com.eprosima.idl.parser.typecode.StringTypeCode@5d740a0f
    m_format ="";
    // m_data com.eprosima.idl.parser.typecode.SequenceTypeCode@214b199c


}

sensor_msgs__CompressedImage::~sensor_msgs__CompressedImage()
{



}

sensor_msgs__CompressedImage::sensor_msgs__CompressedImage(
        const sensor_msgs__CompressedImage& x)
{
    m_header = x.m_header;
    m_format = x.m_format;
    m_data = x.m_data;
}

sensor_msgs__CompressedImage::sensor_msgs__CompressedImage(
        sensor_msgs__CompressedImage&& x)
{
    m_header = std::move(x.m_header);
    m_format = std::move(x.m_format);
    m_data = std::move(x.m_data);
}

sensor_msgs__CompressedImage& sensor_msgs__CompressedImage::operator =(
        const sensor_msgs__CompressedImage& x)
{

    m_header = x.m_header;
    m_format = x.m_format;
    m_data = x.m_data;

    return *this;
}

sensor_msgs__CompressedImage& sensor_msgs__CompressedImage::operator =(
        sensor_msgs__CompressedImage&& x)
{

    m_header = std::move(x.m_header);
    m_format = std::move(x.m_format);
    m_data = std::move(x.m_data);

    return *this;
}

bool sensor_msgs__CompressedImage::operator ==(
        const sensor_msgs__CompressedImage& x) const
{

    return (m_header == x.m_header && m_format == x.m_format && m_data == x.m_data);
}

bool sensor_msgs__CompressedImage::operator !=(
        const sensor_msgs__CompressedImage& x) const
{
    return !(*this == x);
}

size_t sensor_msgs__CompressedImage::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t initial_alignment = current_alignment;


    current_alignment += std_msgs__Header::getMaxCdrSerializedSize(current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 255 + 1;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    current_alignment += (100 * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);




    return current_alignment - initial_alignment;
}

size_t sensor_msgs__CompressedImage::getCdrSerializedSize(
        const sensor_msgs__CompressedImage& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += std_msgs__Header::getCdrSerializedSize(data.header(), current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.format().size() + 1;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    if (data.data().size() > 0)
    {
        current_alignment += (data.data().size() * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);
    }




    return current_alignment - initial_alignment;
}

void sensor_msgs__CompressedImage::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_header;
    scdr << m_format;
    scdr << m_data;

}

void sensor_msgs__CompressedImage::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_header;
    dcdr >> m_format;
    dcdr >> m_data;
}

/*!
 * @brief This function copies the value in member header
 * @param _header New value to be copied in member header
 */
void sensor_msgs__CompressedImage::header(
        const std_msgs__Header& _header)
{
    m_header = _header;
}

/*!
 * @brief This function moves the value in member header
 * @param _header New value to be moved in member header
 */
void sensor_msgs__CompressedImage::header(
        std_msgs__Header&& _header)
{
    m_header = std::move(_header);
}

/*!
 * @brief This function returns a constant reference to member header
 * @return Constant reference to member header
 */
const std_msgs__Header& sensor_msgs__CompressedImage::header() const
{
    return m_header;
}

/*!
 * @brief This function returns a reference to member header
 * @return Reference to member header
 */
std_msgs__Header& sensor_msgs__CompressedImage::header()
{
    return m_header;
}
/*!
 * @brief This function copies the value in member format
 * @param _format New value to be copied in member format
 */
void sensor_msgs__CompressedImage::format(
        const std::string& _format)
{
    m_format = _format;
}

/*!
 * @brief This function moves the value in member format
 * @param _format New value to be moved in member format
 */
void sensor_msgs__CompressedImage::format(
        std::string&& _format)
{
    m_format = std::move(_format);
}

/*!
 * @brief This function returns a constant reference to member format
 * @return Constant reference to member format
 */
const std::string& sensor_msgs__CompressedImage::format() const
{
    return m_format;
}

/*!
 * @brief This function returns a reference to member format
 * @return Reference to member format
 */
std::string& sensor_msgs__CompressedImage::format()
{
    return m_format;
}
/*!
 * @brief This function copies the value in member data
 * @param _data New value to be copied in member data
 */
void sensor_msgs__CompressedImage::data(
        const std::vector<uint8_t>& _data)
{
    m_data = _data;
}

/*!
 * @brief This function moves the value in member data
 * @param _data New value to be moved in member data
 */
void sensor_msgs__CompressedImage::data(
        std::vector<uint8_t>&& _data)
{
    m_data = std::move(_data);
}

/*!
 * @brief This function returns a constant reference to member data
 * @return Constant reference to member data
 */
const std::vector<uint8_t>& sensor_msgs__CompressedImage::data() const
{
    return m_data;
}

/*!
 * @brief This function returns a reference to member data
 * @return Reference to member data
 */
std::vector<uint8_t>& sensor_msgs__CompressedImage::data()
{
    return m_data;
}

size_t sensor_msgs__CompressedImage::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t current_align = current_alignment;






    return current_align;
}

bool sensor_msgs__CompressedImage::isKeyDefined()
{
    return false;
}

void sensor_msgs__CompressedImage::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
       
}

sensor_msgs__PointField::sensor_msgs__PointField()
{
    // m_name com.eprosima.idl.parser.typecode.StringTypeCode@2893de87
    m_name ="";
    // m_offset com.eprosima.idl.parser.typecode.PrimitiveTypeCode@55ca8de8
    m_offset = 0;
    // m_datatype com.eprosima.idl.parser.typecode.PrimitiveTypeCode@2c34f934
    m_datatype = 0;
    // m_count com.eprosima.idl.parser.typecode.PrimitiveTypeCode@12d3a4e9
    m_count = 0;

}

sensor_msgs__PointField::~sensor_msgs__PointField()
{




}

sensor_msgs__PointField::sensor_msgs__PointField(
        const sensor_msgs__PointField& x)
{
    m_name = x.m_name;
    m_offset = x.m_offset;
    m_datatype = x.m_datatype;
    m_count = x.m_count;
}

sensor_msgs__PointField::sensor_msgs__PointField(
        sensor_msgs__PointField&& x)
{
    m_name = std::move(x.m_name);
    m_offset = x.m_offset;
    m_datatype = x.m_datatype;
    m_count = x.m_count;
}

sensor_msgs__PointField& sensor_msgs__PointField::operator =(
        const sensor_msgs__PointField& x)
{

    m_name = x.m_name;
    m_offset = x.m_offset;
    m_datatype = x.m_datatype;
    m_count = x.m_count;

    return *this;
}

sensor_msgs__PointField& sensor_msgs__PointField::operator =(
        sensor_msgs__PointField&& x)
{

    m_name = std::move(x.m_name);
    m_offset = x.m_offset;
    m_datatype = x.m_datatype;
    m_count = x.m_count;

    return *this;
}

bool sensor_msgs__PointField::operator ==(
        const sensor_msgs__PointField& x) const
{

    return (m_name == x.m_name && m_offset == x.m_offset && m_datatype == x.m_datatype && m_count == x.m_count);
}

bool sensor_msgs__PointField::operator !=(
        const sensor_msgs__PointField& x) const
{
    return !(*this == x);
}

size_t sensor_msgs__PointField::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 255 + 1;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);



    return current_alignment - initial_alignment;
}

size_t sensor_msgs__PointField::getCdrSerializedSize(
        const sensor_msgs__PointField& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.name().size() + 1;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);



    return current_alignment - initial_alignment;
}

void sensor_msgs__PointField::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_name;
    scdr << m_offset;
    scdr << m_datatype;
    scdr << m_count;

}

void sensor_msgs__PointField::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_name;
    dcdr >> m_offset;
    dcdr >> m_datatype;
    dcdr >> m_count;
}

/*!
 * @brief This function copies the value in member name
 * @param _name New value to be copied in member name
 */
void sensor_msgs__PointField::name(
        const std::string& _name)
{
    m_name = _name;
}

/*!
 * @brief This function moves the value in member name
 * @param _name New value to be moved in member name
 */
void sensor_msgs__PointField::name(
        std::string&& _name)
{
    m_name = std::move(_name);
}

/*!
 * @brief This function returns a constant reference to member name
 * @return Constant reference to member name
 */
const std::string& sensor_msgs__PointField::name() const
{
    return m_name;
}

/*!
 * @brief This function returns a reference to member name
 * @return Reference to member name
 */
std::string& sensor_msgs__PointField::name()
{
    return m_name;
}
/*!
 * @brief This function sets a value in member offset
 * @param _offset New value for member offset
 */
void sensor_msgs__PointField::offset(
        uint32_t _offset)
{
    m_offset = _offset;
}

/*!
 * @brief This function returns the value of member offset
 * @return Value of member offset
 */
uint32_t sensor_msgs__PointField::offset() const
{
    return m_offset;
}

/*!
 * @brief This function returns a reference to member offset
 * @return Reference to member offset
 */
uint32_t& sensor_msgs__PointField::offset()
{
    return m_offset;
}

/*!
 * @brief This function sets a value in member datatype
 * @param _datatype New value for member datatype
 */
void sensor_msgs__PointField::datatype(
        uint8_t _datatype)
{
    m_datatype = _datatype;
}

/*!
 * @brief This function returns the value of member datatype
 * @return Value of member datatype
 */
uint8_t sensor_msgs__PointField::datatype() const
{
    return m_datatype;
}

/*!
 * @brief This function returns a reference to member datatype
 * @return Reference to member datatype
 */
uint8_t& sensor_msgs__PointField::datatype()
{
    return m_datatype;
}

/*!
 * @brief This function sets a value in member count
 * @param _count New value for member count
 */
void sensor_msgs__PointField::count(
        uint32_t _count)
{
    m_count = _count;
}

/*!
 * @brief This function returns the value of member count
 * @return Value of member count
 */
uint32_t sensor_msgs__PointField::count() const
{
    return m_count;
}

/*!
 * @brief This function returns a reference to member count
 * @return Reference to member count
 */
uint32_t& sensor_msgs__PointField::count()
{
    return m_count;
}


size_t sensor_msgs__PointField::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t current_align = current_alignment;







    return current_align;
}

bool sensor_msgs__PointField::isKeyDefined()
{
    return false;
}

void sensor_msgs__PointField::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
        
}

sensor_msgs__PointCloud2::sensor_msgs__PointCloud2()
{
    // m_header com.eprosima.fastdds.idl.parser.typecode.StructTypeCode@314c508a

    // m_height com.eprosima.idl.parser.typecode.PrimitiveTypeCode@240237d2
    m_height = 0;
    // m_width com.eprosima.idl.parser.typecode.PrimitiveTypeCode@25a65b77
    m_width = 0;
    // m_fields com.eprosima.idl.parser.typecode.SequenceTypeCode@2ed0fbae

    // m_is_bigendian com.eprosima.idl.parser.typecode.PrimitiveTypeCode@212bf671
    m_is_bigendian = false;
    // m_point_step com.eprosima.idl.parser.typecode.PrimitiveTypeCode@14a2f921
    m_point_step = 0;
    // m_row_step com.eprosima.idl.parser.typecode.PrimitiveTypeCode@3c87521
    m_row_step = 0;
    // m_data com.eprosima.idl.parser.typecode.SequenceTypeCode@2aece37d

    // m_is_dense com.eprosima.idl.parser.typecode.PrimitiveTypeCode@548a102f
    m_is_dense = false;

}

sensor_msgs__PointCloud2::~sensor_msgs__PointCloud2()
{









}

sensor_msgs__PointCloud2::sensor_msgs__PointCloud2(
        const sensor_msgs__PointCloud2& x)
{
    m_header = x.m_header;
    m_height = x.m_height;
    m_width = x.m_width;
    m_fields = x.m_fields;
    m_is_bigendian = x.m_is_bigendian;
    m_point_step = x.m_point_step;
    m_row_step = x.m_row_step;
    m_data = x.m_data;
    m_is_dense = x.m_is_dense;
}

sensor_msgs__PointCloud2::sensor_msgs__PointCloud2(
        sensor_msgs__PointCloud2&& x)
{
    m_header = std::move(x.m_header);
    m_height = x.m_height;
    m_width = x.m_width;
    m_fields = std::move(x.m_fields);
    m_is_bigendian = x.m_is_bigendian;
    m_point_step = x.m_point_step;
    m_row_step = x.m_row_step;
    m_data = std::move(x.m_data);
    m_is_dense = x.m_is_dense;
}

sensor_msgs__PointCloud2& sensor_msgs__PointCloud2::operator =(
        const sensor_msgs__PointCloud2& x)
{

    m_header = x.m_header;
    m_height = x.m_height;
    m_width = x.m_width;
    m_fields = x.m_fields;
    m_is_bigendian = x.m_is_bigendian;
    m_point_step = x.m_point_step;
    m_row_step = x.m_row_step;
    m_data = x.m_data;
    m_is_dense = x.m_is_dense;

    return *this;
}

sensor_msgs__PointCloud2& sensor_msgs__PointCloud2::operator =(
        sensor_msgs__PointCloud2&& x)
{

    m_header = std::move(x.m_header);
    m_height = x.m_height;
    m_width = x.m_width;
    m_fields = std::move(x.m_fields);
    m_is_bigendian = x.m_is_bigendian;
    m_point_step = x.m_point_step;
    m_row_step = x.m_row_step;
    m_data = std::move(x.m_data);
    m_is_dense = x.m_is_dense;

    return *this;
}

bool sensor_msgs__PointCloud2::operator ==(
        const sensor_msgs__PointCloud2& x) const
{

    return (m_header == x.m_header && m_height == x.m_height && m_width == x.m_width && m_fields == x.m_fields && m_is_bigendian == x.m_is_bigendian && m_point_step == x.m_point_step && m_row_step == x.m_row_step && m_data == x.m_data && m_is_dense == x.m_is_dense);
}

bool sensor_msgs__PointCloud2::operator !=(
        const sensor_msgs__PointCloud2& x) const
{
    return !(*this == x);
}

size_t sensor_msgs__PointCloud2::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t initial_alignment = current_alignment;


    current_alignment += std_msgs__Header::getMaxCdrSerializedSize(current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    for(size_t a = 0; a < 100; ++a)
    {
        current_alignment += sensor_msgs__PointField::getMaxCdrSerializedSize(current_alignment);}

    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    current_alignment += (100 * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);



    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);



    return current_alignment - initial_alignment;
}

size_t sensor_msgs__PointCloud2::getCdrSerializedSize(
        const sensor_msgs__PointCloud2& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += std_msgs__Header::getCdrSerializedSize(data.header(), current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    for(size_t a = 0; a < data.fields().size(); ++a)
    {
        current_alignment += sensor_msgs__PointField::getCdrSerializedSize(data.fields().at(a), current_alignment);}

    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    if (data.data().size() > 0)
    {
        current_alignment += (data.data().size() * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);
    }



    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);



    return current_alignment - initial_alignment;
}

void sensor_msgs__PointCloud2::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_header;
    scdr << m_height;
    scdr << m_width;
    scdr << m_fields;
    scdr << m_is_bigendian;
    scdr << m_point_step;
    scdr << m_row_step;
    scdr << m_data;
    scdr << m_is_dense;

}

void sensor_msgs__PointCloud2::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_header;
    dcdr >> m_height;
    dcdr >> m_width;
    dcdr >> m_fields;
    dcdr >> m_is_bigendian;
    dcdr >> m_point_step;
    dcdr >> m_row_step;
    dcdr >> m_data;
    dcdr >> m_is_dense;
}

/*!
 * @brief This function copies the value in member header
 * @param _header New value to be copied in member header
 */
void sensor_msgs__PointCloud2::header(
        const std_msgs__Header& _header)
{
    m_header = _header;
}

/*!
 * @brief This function moves the value in member header
 * @param _header New value to be moved in member header
 */
void sensor_msgs__PointCloud2::header(
        std_msgs__Header&& _header)
{
    m_header = std::move(_header);
}

/*!
 * @brief This function returns a constant reference to member header
 * @return Constant reference to member header
 */
const std_msgs__Header& sensor_msgs__PointCloud2::header() const
{
    return m_header;
}

/*!
 * @brief This function returns a reference to member header
 * @return Reference to member header
 */
std_msgs__Header& sensor_msgs__PointCloud2::header()
{
    return m_header;
}
/*!
 * @brief This function sets a value in member height
 * @param _height New value for member height
 */
void sensor_msgs__PointCloud2::height(
        uint32_t _height)
{
    m_height = _height;
}

/*!
 * @brief This function returns the value of member height
 * @return Value of member height
 */
uint32_t sensor_msgs__PointCloud2::height() const
{
    return m_height;
}

/*!
 * @brief This function returns a reference to member height
 * @return Reference to member height
 */
uint32_t& sensor_msgs__PointCloud2::height()
{
    return m_height;
}

/*!
 * @brief This function sets a value in member width
 * @param _width New value for member width
 */
void sensor_msgs__PointCloud2::width(
        uint32_t _width)
{
    m_width = _width;
}

/*!
 * @brief This function returns the value of member width
 * @return Value of member width
 */
uint32_t sensor_msgs__PointCloud2::width() const
{
    return m_width;
}

/*!
 * @brief This function returns a reference to member width
 * @return Reference to member width
 */
uint32_t& sensor_msgs__PointCloud2::width()
{
    return m_width;
}

/*!
 * @brief This function copies the value in member fields
 * @param _fields New value to be copied in member fields
 */
void sensor_msgs__PointCloud2::fields(
        const std::vector<sensor_msgs__PointField>& _fields)
{
    m_fields = _fields;
}

/*!
 * @brief This function moves the value in member fields
 * @param _fields New value to be moved in member fields
 */
void sensor_msgs__PointCloud2::fields(
        std::vector<sensor_msgs__PointField>&& _fields)
{
    m_fields = std::move(_fields);
}

/*!
 * @brief This function returns a constant reference to member fields
 * @return Constant reference to member fields
 */
const std::vector<sensor_msgs__PointField>& sensor_msgs__PointCloud2::fields() const
{
    return m_fields;
}

/*!
 * @brief This function returns a reference to member fields
 * @return Reference to member fields
 */
std::vector<sensor_msgs__PointField>& sensor_msgs__PointCloud2::fields()
{
    return m_fields;
}
/*!
 * @brief This function sets a value in member is_bigendian
 * @param _is_bigendian New value for member is_bigendian
 */
void sensor_msgs__PointCloud2::is_bigendian(
        bool _is_bigendian)
{
    m_is_bigendian = _is_bigendian;
}

/*!
 * @brief This function returns the value of member is_bigendian
 * @return Value of member is_bigendian
 */
bool sensor_msgs__PointCloud2::is_bigendian() const
{
    return m_is_bigendian;
}

/*!
 * @brief This function returns a reference to member is_bigendian
 * @return Reference to member is_bigendian
 */
bool& sensor_msgs__PointCloud2::is_bigendian()
{
    return m_is_bigendian;
}

/*!
 * @brief This function sets a value in member point_step
 * @param _point_step New value for member point_step
 */
void sensor_msgs__PointCloud2::point_step(
        uint32_t _point_step)
{
    m_point_step = _point_step;
}

/*!
 * @brief This function returns the value of member point_step
 * @return Value of member point_step
 */
uint32_t sensor_msgs__PointCloud2::point_step() const
{
    return m_point_step;
}

/*!
 * @brief This function returns a reference to member point_step
 * @return Reference to member point_step
 */
uint32_t& sensor_msgs__PointCloud2::point_step()
{
    return m_point_step;
}

/*!
 * @brief This function sets a value in member row_step
 * @param _row_step New value for member row_step
 */
void sensor_msgs__PointCloud2::row_step(
        uint32_t _row_step)
{
    m_row_step = _row_step;
}

/*!
 * @brief This function returns the value of member row_step
 * @return Value of member row_step
 */
uint32_t sensor_msgs__PointCloud2::row_step() const
{
    return m_row_step;
}

/*!
 * @brief This function returns a reference to member row_step
 * @return Reference to member row_step
 */
uint32_t& sensor_msgs__PointCloud2::row_step()
{
    return m_row_step;
}

/*!
 * @brief This function copies the value in member data
 * @param _data New value to be copied in member data
 */
void sensor_msgs__PointCloud2::data(
        const std::vector<uint8_t>& _data)
{
    m_data = _data;
}

/*!
 * @brief This function moves the value in member data
 * @param _data New value to be moved in member data
 */
void sensor_msgs__PointCloud2::data(
        std::vector<uint8_t>&& _data)
{
    m_data = std::move(_data);
}

/*!
 * @brief This function returns a constant reference to member data
 * @return Constant reference to member data
 */
const std::vector<uint8_t>& sensor_msgs__PointCloud2::data() const
{
    return m_data;
}

/*!
 * @brief This function returns a reference to member data
 * @return Reference to member data
 */
std::vector<uint8_t>& sensor_msgs__PointCloud2::data()
{
    return m_data;
}
/*!
 * @brief This function sets a value in member is_dense
 * @param _is_dense New value for member is_dense
 */
void sensor_msgs__PointCloud2::is_dense(
        bool _is_dense)
{
    m_is_dense = _is_dense;
}

/*!
 * @brief This function returns the value of member is_dense
 * @return Value of member is_dense
 */
bool sensor_msgs__PointCloud2::is_dense() const
{
    return m_is_dense;
}

/*!
 * @brief This function returns a reference to member is_dense
 * @return Reference to member is_dense
 */
bool& sensor_msgs__PointCloud2::is_dense()
{
    return m_is_dense;
}


size_t sensor_msgs__PointCloud2::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t current_align = current_alignment;












    return current_align;
}

bool sensor_msgs__PointCloud2::isKeyDefined()
{
    return false;
}

void sensor_msgs__PointCloud2::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
             
}

nav_msgs__Path::nav_msgs__Path()
{
    // m_header com.eprosima.fastdds.idl.parser.typecode.StructTypeCode@314c508a

    // m_poses com.eprosima.idl.parser.typecode.SequenceTypeCode@5af97850


}

nav_msgs__Path::~nav_msgs__Path()
{


}

nav_msgs__Path::nav_msgs__Path(
        const nav_msgs__Path& x)
{
    m_header = x.m_header;
    m_poses = x.m_poses;
}

nav_msgs__Path::nav_msgs__Path(
        nav_msgs__Path&& x)
{
    m_header = std::move(x.m_header);
    m_poses = std::move(x.m_poses);
}

nav_msgs__Path& nav_msgs__Path::operator =(
        const nav_msgs__Path& x)
{

    m_header = x.m_header;
    m_poses = x.m_poses;

    return *this;
}

nav_msgs__Path& nav_msgs__Path::operator =(
        nav_msgs__Path&& x)
{

    m_header = std::move(x.m_header);
    m_poses = std::move(x.m_poses);

    return *this;
}

bool nav_msgs__Path::operator ==(
        const nav_msgs__Path& x) const
{

    return (m_header == x.m_header && m_poses == x.m_poses);
}

bool nav_msgs__Path::operator !=(
        const nav_msgs__Path& x) const
{
    return !(*this == x);
}

size_t nav_msgs__Path::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t initial_alignment = current_alignment;


    current_alignment += std_msgs__Header::getMaxCdrSerializedSize(current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    for(size_t a = 0; a < 100; ++a)
    {
        current_alignment += geometry_msgs__PoseStamped::getMaxCdrSerializedSize(current_alignment);}


    return current_alignment - initial_alignment;
}

size_t nav_msgs__Path::getCdrSerializedSize(
        const nav_msgs__Path& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += std_msgs__Header::getCdrSerializedSize(data.header(), current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    for(size_t a = 0; a < data.poses().size(); ++a)
    {
        current_alignment += geometry_msgs__PoseStamped::getCdrSerializedSize(data.poses().at(a), current_alignment);}


    return current_alignment - initial_alignment;
}

void nav_msgs__Path::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_header;
    scdr << m_poses;

}

void nav_msgs__Path::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_header;
    dcdr >> m_poses;
}

/*!
 * @brief This function copies the value in member header
 * @param _header New value to be copied in member header
 */
void nav_msgs__Path::header(
        const std_msgs__Header& _header)
{
    m_header = _header;
}

/*!
 * @brief This function moves the value in member header
 * @param _header New value to be moved in member header
 */
void nav_msgs__Path::header(
        std_msgs__Header&& _header)
{
    m_header = std::move(_header);
}

/*!
 * @brief This function returns a constant reference to member header
 * @return Constant reference to member header
 */
const std_msgs__Header& nav_msgs__Path::header() const
{
    return m_header;
}

/*!
 * @brief This function returns a reference to member header
 * @return Reference to member header
 */
std_msgs__Header& nav_msgs__Path::header()
{
    return m_header;
}
/*!
 * @brief This function copies the value in member poses
 * @param _poses New value to be copied in member poses
 */
void nav_msgs__Path::poses(
        const std::vector<geometry_msgs__PoseStamped>& _poses)
{
    m_poses = _poses;
}

/*!
 * @brief This function moves the value in member poses
 * @param _poses New value to be moved in member poses
 */
void nav_msgs__Path::poses(
        std::vector<geometry_msgs__PoseStamped>&& _poses)
{
    m_poses = std::move(_poses);
}

/*!
 * @brief This function returns a constant reference to member poses
 * @return Constant reference to member poses
 */
const std::vector<geometry_msgs__PoseStamped>& nav_msgs__Path::poses() const
{
    return m_poses;
}

/*!
 * @brief This function returns a reference to member poses
 * @return Reference to member poses
 */
std::vector<geometry_msgs__PoseStamped>& nav_msgs__Path::poses()
{
    return m_poses;
}

size_t nav_msgs__Path::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t current_align = current_alignment;





    return current_align;
}

bool nav_msgs__Path::isKeyDefined()
{
    return false;
}

void nav_msgs__Path::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
      
}

visualization_msgs__ImageMarker::visualization_msgs__ImageMarker()
{
    // m_header com.eprosima.fastdds.idl.parser.typecode.StructTypeCode@314c508a

    // m_ns com.eprosima.idl.parser.typecode.StringTypeCode@5ef60048
    m_ns ="";
    // m_id com.eprosima.idl.parser.typecode.PrimitiveTypeCode@1d548a08
    m_id = 0;
    // m_type com.eprosima.idl.parser.typecode.PrimitiveTypeCode@16aa0a0a
    m_type = 0;
    // m_action com.eprosima.idl.parser.typecode.PrimitiveTypeCode@780cb77
    m_action = 0;
    // m_position com.eprosima.fastdds.idl.parser.typecode.StructTypeCode@dd3b207

    // m_scale com.eprosima.idl.parser.typecode.PrimitiveTypeCode@691a7f8f
    m_scale = 0.0;
    // m_outline_color com.eprosima.fastdds.idl.parser.typecode.StructTypeCode@50a7bc6e

    // m_filled com.eprosima.idl.parser.typecode.PrimitiveTypeCode@161b062a
    m_filled = 0;
    // m_fill_color com.eprosima.fastdds.idl.parser.typecode.StructTypeCode@50a7bc6e

    // m_lifetime com.eprosima.fastdds.idl.parser.typecode.StructTypeCode@17c1bced

    // m_points com.eprosima.idl.parser.typecode.SequenceTypeCode@2d9d4f9d

    // m_outline_colors com.eprosima.idl.parser.typecode.SequenceTypeCode@4034c28c


}

visualization_msgs__ImageMarker::~visualization_msgs__ImageMarker()
{













}

visualization_msgs__ImageMarker::visualization_msgs__ImageMarker(
        const visualization_msgs__ImageMarker& x)
{
    m_header = x.m_header;
    m_ns = x.m_ns;
    m_id = x.m_id;
    m_type = x.m_type;
    m_action = x.m_action;
    m_position = x.m_position;
    m_scale = x.m_scale;
    m_outline_color = x.m_outline_color;
    m_filled = x.m_filled;
    m_fill_color = x.m_fill_color;
    m_lifetime = x.m_lifetime;
    m_points = x.m_points;
    m_outline_colors = x.m_outline_colors;
}

visualization_msgs__ImageMarker::visualization_msgs__ImageMarker(
        visualization_msgs__ImageMarker&& x)
{
    m_header = std::move(x.m_header);
    m_ns = std::move(x.m_ns);
    m_id = x.m_id;
    m_type = x.m_type;
    m_action = x.m_action;
    m_position = std::move(x.m_position);
    m_scale = x.m_scale;
    m_outline_color = std::move(x.m_outline_color);
    m_filled = x.m_filled;
    m_fill_color = std::move(x.m_fill_color);
    m_lifetime = std::move(x.m_lifetime);
    m_points = std::move(x.m_points);
    m_outline_colors = std::move(x.m_outline_colors);
}

visualization_msgs__ImageMarker& visualization_msgs__ImageMarker::operator =(
        const visualization_msgs__ImageMarker& x)
{

    m_header = x.m_header;
    m_ns = x.m_ns;
    m_id = x.m_id;
    m_type = x.m_type;
    m_action = x.m_action;
    m_position = x.m_position;
    m_scale = x.m_scale;
    m_outline_color = x.m_outline_color;
    m_filled = x.m_filled;
    m_fill_color = x.m_fill_color;
    m_lifetime = x.m_lifetime;
    m_points = x.m_points;
    m_outline_colors = x.m_outline_colors;

    return *this;
}

visualization_msgs__ImageMarker& visualization_msgs__ImageMarker::operator =(
        visualization_msgs__ImageMarker&& x)
{

    m_header = std::move(x.m_header);
    m_ns = std::move(x.m_ns);
    m_id = x.m_id;
    m_type = x.m_type;
    m_action = x.m_action;
    m_position = std::move(x.m_position);
    m_scale = x.m_scale;
    m_outline_color = std::move(x.m_outline_color);
    m_filled = x.m_filled;
    m_fill_color = std::move(x.m_fill_color);
    m_lifetime = std::move(x.m_lifetime);
    m_points = std::move(x.m_points);
    m_outline_colors = std::move(x.m_outline_colors);

    return *this;
}

bool visualization_msgs__ImageMarker::operator ==(
        const visualization_msgs__ImageMarker& x) const
{

    return (m_header == x.m_header && m_ns == x.m_ns && m_id == x.m_id && m_type == x.m_type && m_action == x.m_action && m_position == x.m_position && m_scale == x.m_scale && m_outline_color == x.m_outline_color && m_filled == x.m_filled && m_fill_color == x.m_fill_color && m_lifetime == x.m_lifetime && m_points == x.m_points && m_outline_colors == x.m_outline_colors);
}

bool visualization_msgs__ImageMarker::operator !=(
        const visualization_msgs__ImageMarker& x) const
{
    return !(*this == x);
}

size_t visualization_msgs__ImageMarker::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t initial_alignment = current_alignment;


    current_alignment += std_msgs__Header::getMaxCdrSerializedSize(current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 255 + 1;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += geometry_msgs__Point::getMaxCdrSerializedSize(current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += std_msgs__ColorRGBA::getMaxCdrSerializedSize(current_alignment);
    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    current_alignment += std_msgs__ColorRGBA::getMaxCdrSerializedSize(current_alignment);
    current_alignment += builtins__Duration::getMaxCdrSerializedSize(current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    for(size_t a = 0; a < 100; ++a)
    {
        current_alignment += geometry_msgs__Point::getMaxCdrSerializedSize(current_alignment);}

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    for(size_t a = 0; a < 100; ++a)
    {
        current_alignment += std_msgs__ColorRGBA::getMaxCdrSerializedSize(current_alignment);}


    return current_alignment - initial_alignment;
}

size_t visualization_msgs__ImageMarker::getCdrSerializedSize(
        const visualization_msgs__ImageMarker& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += std_msgs__Header::getCdrSerializedSize(data.header(), current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.ns().size() + 1;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += geometry_msgs__Point::getCdrSerializedSize(data.position(), current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += std_msgs__ColorRGBA::getCdrSerializedSize(data.outline_color(), current_alignment);
    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    current_alignment += std_msgs__ColorRGBA::getCdrSerializedSize(data.fill_color(), current_alignment);
    current_alignment += builtins__Duration::getCdrSerializedSize(data.lifetime(), current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    for(size_t a = 0; a < data.points().size(); ++a)
    {
        current_alignment += geometry_msgs__Point::getCdrSerializedSize(data.points().at(a), current_alignment);}

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    for(size_t a = 0; a < data.outline_colors().size(); ++a)
    {
        current_alignment += std_msgs__ColorRGBA::getCdrSerializedSize(data.outline_colors().at(a), current_alignment);}


    return current_alignment - initial_alignment;
}

void visualization_msgs__ImageMarker::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_header;
    scdr << m_ns;
    scdr << m_id;
    scdr << m_type;
    scdr << m_action;
    scdr << m_position;
    scdr << m_scale;
    scdr << m_outline_color;
    scdr << m_filled;
    scdr << m_fill_color;
    scdr << m_lifetime;
    scdr << m_points;
    scdr << m_outline_colors;

}

void visualization_msgs__ImageMarker::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_header;
    dcdr >> m_ns;
    dcdr >> m_id;
    dcdr >> m_type;
    dcdr >> m_action;
    dcdr >> m_position;
    dcdr >> m_scale;
    dcdr >> m_outline_color;
    dcdr >> m_filled;
    dcdr >> m_fill_color;
    dcdr >> m_lifetime;
    dcdr >> m_points;
    dcdr >> m_outline_colors;
}

/*!
 * @brief This function copies the value in member header
 * @param _header New value to be copied in member header
 */
void visualization_msgs__ImageMarker::header(
        const std_msgs__Header& _header)
{
    m_header = _header;
}

/*!
 * @brief This function moves the value in member header
 * @param _header New value to be moved in member header
 */
void visualization_msgs__ImageMarker::header(
        std_msgs__Header&& _header)
{
    m_header = std::move(_header);
}

/*!
 * @brief This function returns a constant reference to member header
 * @return Constant reference to member header
 */
const std_msgs__Header& visualization_msgs__ImageMarker::header() const
{
    return m_header;
}

/*!
 * @brief This function returns a reference to member header
 * @return Reference to member header
 */
std_msgs__Header& visualization_msgs__ImageMarker::header()
{
    return m_header;
}
/*!
 * @brief This function copies the value in member ns
 * @param _ns New value to be copied in member ns
 */
void visualization_msgs__ImageMarker::ns(
        const std::string& _ns)
{
    m_ns = _ns;
}

/*!
 * @brief This function moves the value in member ns
 * @param _ns New value to be moved in member ns
 */
void visualization_msgs__ImageMarker::ns(
        std::string&& _ns)
{
    m_ns = std::move(_ns);
}

/*!
 * @brief This function returns a constant reference to member ns
 * @return Constant reference to member ns
 */
const std::string& visualization_msgs__ImageMarker::ns() const
{
    return m_ns;
}

/*!
 * @brief This function returns a reference to member ns
 * @return Reference to member ns
 */
std::string& visualization_msgs__ImageMarker::ns()
{
    return m_ns;
}
/*!
 * @brief This function sets a value in member id
 * @param _id New value for member id
 */
void visualization_msgs__ImageMarker::id(
        int32_t _id)
{
    m_id = _id;
}

/*!
 * @brief This function returns the value of member id
 * @return Value of member id
 */
int32_t visualization_msgs__ImageMarker::id() const
{
    return m_id;
}

/*!
 * @brief This function returns a reference to member id
 * @return Reference to member id
 */
int32_t& visualization_msgs__ImageMarker::id()
{
    return m_id;
}

/*!
 * @brief This function sets a value in member type
 * @param _type New value for member type
 */
void visualization_msgs__ImageMarker::type(
        int32_t _type)
{
    m_type = _type;
}

/*!
 * @brief This function returns the value of member type
 * @return Value of member type
 */
int32_t visualization_msgs__ImageMarker::type() const
{
    return m_type;
}

/*!
 * @brief This function returns a reference to member type
 * @return Reference to member type
 */
int32_t& visualization_msgs__ImageMarker::type()
{
    return m_type;
}

/*!
 * @brief This function sets a value in member action
 * @param _action New value for member action
 */
void visualization_msgs__ImageMarker::action(
        int32_t _action)
{
    m_action = _action;
}

/*!
 * @brief This function returns the value of member action
 * @return Value of member action
 */
int32_t visualization_msgs__ImageMarker::action() const
{
    return m_action;
}

/*!
 * @brief This function returns a reference to member action
 * @return Reference to member action
 */
int32_t& visualization_msgs__ImageMarker::action()
{
    return m_action;
}

/*!
 * @brief This function copies the value in member position
 * @param _position New value to be copied in member position
 */
void visualization_msgs__ImageMarker::position(
        const geometry_msgs__Point& _position)
{
    m_position = _position;
}

/*!
 * @brief This function moves the value in member position
 * @param _position New value to be moved in member position
 */
void visualization_msgs__ImageMarker::position(
        geometry_msgs__Point&& _position)
{
    m_position = std::move(_position);
}

/*!
 * @brief This function returns a constant reference to member position
 * @return Constant reference to member position
 */
const geometry_msgs__Point& visualization_msgs__ImageMarker::position() const
{
    return m_position;
}

/*!
 * @brief This function returns a reference to member position
 * @return Reference to member position
 */
geometry_msgs__Point& visualization_msgs__ImageMarker::position()
{
    return m_position;
}
/*!
 * @brief This function sets a value in member scale
 * @param _scale New value for member scale
 */
void visualization_msgs__ImageMarker::scale(
        float _scale)
{
    m_scale = _scale;
}

/*!
 * @brief This function returns the value of member scale
 * @return Value of member scale
 */
float visualization_msgs__ImageMarker::scale() const
{
    return m_scale;
}

/*!
 * @brief This function returns a reference to member scale
 * @return Reference to member scale
 */
float& visualization_msgs__ImageMarker::scale()
{
    return m_scale;
}

/*!
 * @brief This function copies the value in member outline_color
 * @param _outline_color New value to be copied in member outline_color
 */
void visualization_msgs__ImageMarker::outline_color(
        const std_msgs__ColorRGBA& _outline_color)
{
    m_outline_color = _outline_color;
}

/*!
 * @brief This function moves the value in member outline_color
 * @param _outline_color New value to be moved in member outline_color
 */
void visualization_msgs__ImageMarker::outline_color(
        std_msgs__ColorRGBA&& _outline_color)
{
    m_outline_color = std::move(_outline_color);
}

/*!
 * @brief This function returns a constant reference to member outline_color
 * @return Constant reference to member outline_color
 */
const std_msgs__ColorRGBA& visualization_msgs__ImageMarker::outline_color() const
{
    return m_outline_color;
}

/*!
 * @brief This function returns a reference to member outline_color
 * @return Reference to member outline_color
 */
std_msgs__ColorRGBA& visualization_msgs__ImageMarker::outline_color()
{
    return m_outline_color;
}
/*!
 * @brief This function sets a value in member filled
 * @param _filled New value for member filled
 */
void visualization_msgs__ImageMarker::filled(
        uint8_t _filled)
{
    m_filled = _filled;
}

/*!
 * @brief This function returns the value of member filled
 * @return Value of member filled
 */
uint8_t visualization_msgs__ImageMarker::filled() const
{
    return m_filled;
}

/*!
 * @brief This function returns a reference to member filled
 * @return Reference to member filled
 */
uint8_t& visualization_msgs__ImageMarker::filled()
{
    return m_filled;
}

/*!
 * @brief This function copies the value in member fill_color
 * @param _fill_color New value to be copied in member fill_color
 */
void visualization_msgs__ImageMarker::fill_color(
        const std_msgs__ColorRGBA& _fill_color)
{
    m_fill_color = _fill_color;
}

/*!
 * @brief This function moves the value in member fill_color
 * @param _fill_color New value to be moved in member fill_color
 */
void visualization_msgs__ImageMarker::fill_color(
        std_msgs__ColorRGBA&& _fill_color)
{
    m_fill_color = std::move(_fill_color);
}

/*!
 * @brief This function returns a constant reference to member fill_color
 * @return Constant reference to member fill_color
 */
const std_msgs__ColorRGBA& visualization_msgs__ImageMarker::fill_color() const
{
    return m_fill_color;
}

/*!
 * @brief This function returns a reference to member fill_color
 * @return Reference to member fill_color
 */
std_msgs__ColorRGBA& visualization_msgs__ImageMarker::fill_color()
{
    return m_fill_color;
}
/*!
 * @brief This function copies the value in member lifetime
 * @param _lifetime New value to be copied in member lifetime
 */
void visualization_msgs__ImageMarker::lifetime(
        const builtins__Duration& _lifetime)
{
    m_lifetime = _lifetime;
}

/*!
 * @brief This function moves the value in member lifetime
 * @param _lifetime New value to be moved in member lifetime
 */
void visualization_msgs__ImageMarker::lifetime(
        builtins__Duration&& _lifetime)
{
    m_lifetime = std::move(_lifetime);
}

/*!
 * @brief This function returns a constant reference to member lifetime
 * @return Constant reference to member lifetime
 */
const builtins__Duration& visualization_msgs__ImageMarker::lifetime() const
{
    return m_lifetime;
}

/*!
 * @brief This function returns a reference to member lifetime
 * @return Reference to member lifetime
 */
builtins__Duration& visualization_msgs__ImageMarker::lifetime()
{
    return m_lifetime;
}
/*!
 * @brief This function copies the value in member points
 * @param _points New value to be copied in member points
 */
void visualization_msgs__ImageMarker::points(
        const std::vector<geometry_msgs__Point>& _points)
{
    m_points = _points;
}

/*!
 * @brief This function moves the value in member points
 * @param _points New value to be moved in member points
 */
void visualization_msgs__ImageMarker::points(
        std::vector<geometry_msgs__Point>&& _points)
{
    m_points = std::move(_points);
}

/*!
 * @brief This function returns a constant reference to member points
 * @return Constant reference to member points
 */
const std::vector<geometry_msgs__Point>& visualization_msgs__ImageMarker::points() const
{
    return m_points;
}

/*!
 * @brief This function returns a reference to member points
 * @return Reference to member points
 */
std::vector<geometry_msgs__Point>& visualization_msgs__ImageMarker::points()
{
    return m_points;
}
/*!
 * @brief This function copies the value in member outline_colors
 * @param _outline_colors New value to be copied in member outline_colors
 */
void visualization_msgs__ImageMarker::outline_colors(
        const std::vector<std_msgs__ColorRGBA>& _outline_colors)
{
    m_outline_colors = _outline_colors;
}

/*!
 * @brief This function moves the value in member outline_colors
 * @param _outline_colors New value to be moved in member outline_colors
 */
void visualization_msgs__ImageMarker::outline_colors(
        std::vector<std_msgs__ColorRGBA>&& _outline_colors)
{
    m_outline_colors = std::move(_outline_colors);
}

/*!
 * @brief This function returns a constant reference to member outline_colors
 * @return Constant reference to member outline_colors
 */
const std::vector<std_msgs__ColorRGBA>& visualization_msgs__ImageMarker::outline_colors() const
{
    return m_outline_colors;
}

/*!
 * @brief This function returns a reference to member outline_colors
 * @return Reference to member outline_colors
 */
std::vector<std_msgs__ColorRGBA>& visualization_msgs__ImageMarker::outline_colors()
{
    return m_outline_colors;
}

size_t visualization_msgs__ImageMarker::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t current_align = current_alignment;
















    return current_align;
}

bool visualization_msgs__ImageMarker::isKeyDefined()
{
    return false;
}

void visualization_msgs__ImageMarker::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
                 
}

visualization_msgs__Marker::visualization_msgs__Marker()
{
    // m_header com.eprosima.fastdds.idl.parser.typecode.StructTypeCode@314c508a

    // m_ns com.eprosima.idl.parser.typecode.StringTypeCode@e50a6f6
    m_ns ="";
    // m_id com.eprosima.idl.parser.typecode.PrimitiveTypeCode@14ec4505
    m_id = 0;
    // m_type com.eprosima.idl.parser.typecode.PrimitiveTypeCode@53ca01a2
    m_type = 0;
    // m_action com.eprosima.idl.parser.typecode.PrimitiveTypeCode@358c99f5
    m_action = 0;
    // m_pose com.eprosima.fastdds.idl.parser.typecode.StructTypeCode@58fdd99

    // m_scale com.eprosima.fastdds.idl.parser.typecode.StructTypeCode@12405818

    // m_color com.eprosima.fastdds.idl.parser.typecode.StructTypeCode@50a7bc6e

    // m_lifetime com.eprosima.fastdds.idl.parser.typecode.StructTypeCode@17c1bced

    // m_frame_locked com.eprosima.idl.parser.typecode.PrimitiveTypeCode@3ee0fea4
    m_frame_locked = false;
    // m_points com.eprosima.idl.parser.typecode.SequenceTypeCode@48524010

    // m_colors com.eprosima.idl.parser.typecode.SequenceTypeCode@4b168fa9

    // m_text com.eprosima.idl.parser.typecode.StringTypeCode@1a84f40f
    m_text ="";
    // m_mesh_resource com.eprosima.idl.parser.typecode.StringTypeCode@23282c25
    m_mesh_resource ="";
    // m_mesh_use_embedded_materials com.eprosima.idl.parser.typecode.PrimitiveTypeCode@7920ba90
    m_mesh_use_embedded_materials = false;

}

visualization_msgs__Marker::~visualization_msgs__Marker()
{















}

visualization_msgs__Marker::visualization_msgs__Marker(
        const visualization_msgs__Marker& x)
{
    m_header = x.m_header;
    m_ns = x.m_ns;
    m_id = x.m_id;
    m_type = x.m_type;
    m_action = x.m_action;
    m_pose = x.m_pose;
    m_scale = x.m_scale;
    m_color = x.m_color;
    m_lifetime = x.m_lifetime;
    m_frame_locked = x.m_frame_locked;
    m_points = x.m_points;
    m_colors = x.m_colors;
    m_text = x.m_text;
    m_mesh_resource = x.m_mesh_resource;
    m_mesh_use_embedded_materials = x.m_mesh_use_embedded_materials;
}

visualization_msgs__Marker::visualization_msgs__Marker(
        visualization_msgs__Marker&& x)
{
    m_header = std::move(x.m_header);
    m_ns = std::move(x.m_ns);
    m_id = x.m_id;
    m_type = x.m_type;
    m_action = x.m_action;
    m_pose = std::move(x.m_pose);
    m_scale = std::move(x.m_scale);
    m_color = std::move(x.m_color);
    m_lifetime = std::move(x.m_lifetime);
    m_frame_locked = x.m_frame_locked;
    m_points = std::move(x.m_points);
    m_colors = std::move(x.m_colors);
    m_text = std::move(x.m_text);
    m_mesh_resource = std::move(x.m_mesh_resource);
    m_mesh_use_embedded_materials = x.m_mesh_use_embedded_materials;
}

visualization_msgs__Marker& visualization_msgs__Marker::operator =(
        const visualization_msgs__Marker& x)
{

    m_header = x.m_header;
    m_ns = x.m_ns;
    m_id = x.m_id;
    m_type = x.m_type;
    m_action = x.m_action;
    m_pose = x.m_pose;
    m_scale = x.m_scale;
    m_color = x.m_color;
    m_lifetime = x.m_lifetime;
    m_frame_locked = x.m_frame_locked;
    m_points = x.m_points;
    m_colors = x.m_colors;
    m_text = x.m_text;
    m_mesh_resource = x.m_mesh_resource;
    m_mesh_use_embedded_materials = x.m_mesh_use_embedded_materials;

    return *this;
}

visualization_msgs__Marker& visualization_msgs__Marker::operator =(
        visualization_msgs__Marker&& x)
{

    m_header = std::move(x.m_header);
    m_ns = std::move(x.m_ns);
    m_id = x.m_id;
    m_type = x.m_type;
    m_action = x.m_action;
    m_pose = std::move(x.m_pose);
    m_scale = std::move(x.m_scale);
    m_color = std::move(x.m_color);
    m_lifetime = std::move(x.m_lifetime);
    m_frame_locked = x.m_frame_locked;
    m_points = std::move(x.m_points);
    m_colors = std::move(x.m_colors);
    m_text = std::move(x.m_text);
    m_mesh_resource = std::move(x.m_mesh_resource);
    m_mesh_use_embedded_materials = x.m_mesh_use_embedded_materials;

    return *this;
}

bool visualization_msgs__Marker::operator ==(
        const visualization_msgs__Marker& x) const
{

    return (m_header == x.m_header && m_ns == x.m_ns && m_id == x.m_id && m_type == x.m_type && m_action == x.m_action && m_pose == x.m_pose && m_scale == x.m_scale && m_color == x.m_color && m_lifetime == x.m_lifetime && m_frame_locked == x.m_frame_locked && m_points == x.m_points && m_colors == x.m_colors && m_text == x.m_text && m_mesh_resource == x.m_mesh_resource && m_mesh_use_embedded_materials == x.m_mesh_use_embedded_materials);
}

bool visualization_msgs__Marker::operator !=(
        const visualization_msgs__Marker& x) const
{
    return !(*this == x);
}

size_t visualization_msgs__Marker::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t initial_alignment = current_alignment;


    current_alignment += std_msgs__Header::getMaxCdrSerializedSize(current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 255 + 1;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += geometry_msgs__Pose::getMaxCdrSerializedSize(current_alignment);
    current_alignment += geometry_msgs__Vector3::getMaxCdrSerializedSize(current_alignment);
    current_alignment += std_msgs__ColorRGBA::getMaxCdrSerializedSize(current_alignment);
    current_alignment += builtins__Duration::getMaxCdrSerializedSize(current_alignment);
    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    for(size_t a = 0; a < 100; ++a)
    {
        current_alignment += geometry_msgs__Point::getMaxCdrSerializedSize(current_alignment);}

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    for(size_t a = 0; a < 100; ++a)
    {
        current_alignment += std_msgs__ColorRGBA::getMaxCdrSerializedSize(current_alignment);}

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 255 + 1;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 255 + 1;

    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);



    return current_alignment - initial_alignment;
}

size_t visualization_msgs__Marker::getCdrSerializedSize(
        const visualization_msgs__Marker& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += std_msgs__Header::getCdrSerializedSize(data.header(), current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.ns().size() + 1;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += geometry_msgs__Pose::getCdrSerializedSize(data.pose(), current_alignment);
    current_alignment += geometry_msgs__Vector3::getCdrSerializedSize(data.scale(), current_alignment);
    current_alignment += std_msgs__ColorRGBA::getCdrSerializedSize(data.color(), current_alignment);
    current_alignment += builtins__Duration::getCdrSerializedSize(data.lifetime(), current_alignment);
    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    for(size_t a = 0; a < data.points().size(); ++a)
    {
        current_alignment += geometry_msgs__Point::getCdrSerializedSize(data.points().at(a), current_alignment);}

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    for(size_t a = 0; a < data.colors().size(); ++a)
    {
        current_alignment += std_msgs__ColorRGBA::getCdrSerializedSize(data.colors().at(a), current_alignment);}

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.text().size() + 1;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.mesh_resource().size() + 1;

    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);



    return current_alignment - initial_alignment;
}

void visualization_msgs__Marker::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_header;
    scdr << m_ns;
    scdr << m_id;
    scdr << m_type;
    scdr << m_action;
    scdr << m_pose;
    scdr << m_scale;
    scdr << m_color;
    scdr << m_lifetime;
    scdr << m_frame_locked;
    scdr << m_points;
    scdr << m_colors;
    scdr << m_text;
    scdr << m_mesh_resource;
    scdr << m_mesh_use_embedded_materials;

}

void visualization_msgs__Marker::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_header;
    dcdr >> m_ns;
    dcdr >> m_id;
    dcdr >> m_type;
    dcdr >> m_action;
    dcdr >> m_pose;
    dcdr >> m_scale;
    dcdr >> m_color;
    dcdr >> m_lifetime;
    dcdr >> m_frame_locked;
    dcdr >> m_points;
    dcdr >> m_colors;
    dcdr >> m_text;
    dcdr >> m_mesh_resource;
    dcdr >> m_mesh_use_embedded_materials;
}

/*!
 * @brief This function copies the value in member header
 * @param _header New value to be copied in member header
 */
void visualization_msgs__Marker::header(
        const std_msgs__Header& _header)
{
    m_header = _header;
}

/*!
 * @brief This function moves the value in member header
 * @param _header New value to be moved in member header
 */
void visualization_msgs__Marker::header(
        std_msgs__Header&& _header)
{
    m_header = std::move(_header);
}

/*!
 * @brief This function returns a constant reference to member header
 * @return Constant reference to member header
 */
const std_msgs__Header& visualization_msgs__Marker::header() const
{
    return m_header;
}

/*!
 * @brief This function returns a reference to member header
 * @return Reference to member header
 */
std_msgs__Header& visualization_msgs__Marker::header()
{
    return m_header;
}
/*!
 * @brief This function copies the value in member ns
 * @param _ns New value to be copied in member ns
 */
void visualization_msgs__Marker::ns(
        const std::string& _ns)
{
    m_ns = _ns;
}

/*!
 * @brief This function moves the value in member ns
 * @param _ns New value to be moved in member ns
 */
void visualization_msgs__Marker::ns(
        std::string&& _ns)
{
    m_ns = std::move(_ns);
}

/*!
 * @brief This function returns a constant reference to member ns
 * @return Constant reference to member ns
 */
const std::string& visualization_msgs__Marker::ns() const
{
    return m_ns;
}

/*!
 * @brief This function returns a reference to member ns
 * @return Reference to member ns
 */
std::string& visualization_msgs__Marker::ns()
{
    return m_ns;
}
/*!
 * @brief This function sets a value in member id
 * @param _id New value for member id
 */
void visualization_msgs__Marker::id(
        int32_t _id)
{
    m_id = _id;
}

/*!
 * @brief This function returns the value of member id
 * @return Value of member id
 */
int32_t visualization_msgs__Marker::id() const
{
    return m_id;
}

/*!
 * @brief This function returns a reference to member id
 * @return Reference to member id
 */
int32_t& visualization_msgs__Marker::id()
{
    return m_id;
}

/*!
 * @brief This function sets a value in member type
 * @param _type New value for member type
 */
void visualization_msgs__Marker::type(
        int32_t _type)
{
    m_type = _type;
}

/*!
 * @brief This function returns the value of member type
 * @return Value of member type
 */
int32_t visualization_msgs__Marker::type() const
{
    return m_type;
}

/*!
 * @brief This function returns a reference to member type
 * @return Reference to member type
 */
int32_t& visualization_msgs__Marker::type()
{
    return m_type;
}

/*!
 * @brief This function sets a value in member action
 * @param _action New value for member action
 */
void visualization_msgs__Marker::action(
        int32_t _action)
{
    m_action = _action;
}

/*!
 * @brief This function returns the value of member action
 * @return Value of member action
 */
int32_t visualization_msgs__Marker::action() const
{
    return m_action;
}

/*!
 * @brief This function returns a reference to member action
 * @return Reference to member action
 */
int32_t& visualization_msgs__Marker::action()
{
    return m_action;
}

/*!
 * @brief This function copies the value in member pose
 * @param _pose New value to be copied in member pose
 */
void visualization_msgs__Marker::pose(
        const geometry_msgs__Pose& _pose)
{
    m_pose = _pose;
}

/*!
 * @brief This function moves the value in member pose
 * @param _pose New value to be moved in member pose
 */
void visualization_msgs__Marker::pose(
        geometry_msgs__Pose&& _pose)
{
    m_pose = std::move(_pose);
}

/*!
 * @brief This function returns a constant reference to member pose
 * @return Constant reference to member pose
 */
const geometry_msgs__Pose& visualization_msgs__Marker::pose() const
{
    return m_pose;
}

/*!
 * @brief This function returns a reference to member pose
 * @return Reference to member pose
 */
geometry_msgs__Pose& visualization_msgs__Marker::pose()
{
    return m_pose;
}
/*!
 * @brief This function copies the value in member scale
 * @param _scale New value to be copied in member scale
 */
void visualization_msgs__Marker::scale(
        const geometry_msgs__Vector3& _scale)
{
    m_scale = _scale;
}

/*!
 * @brief This function moves the value in member scale
 * @param _scale New value to be moved in member scale
 */
void visualization_msgs__Marker::scale(
        geometry_msgs__Vector3&& _scale)
{
    m_scale = std::move(_scale);
}

/*!
 * @brief This function returns a constant reference to member scale
 * @return Constant reference to member scale
 */
const geometry_msgs__Vector3& visualization_msgs__Marker::scale() const
{
    return m_scale;
}

/*!
 * @brief This function returns a reference to member scale
 * @return Reference to member scale
 */
geometry_msgs__Vector3& visualization_msgs__Marker::scale()
{
    return m_scale;
}
/*!
 * @brief This function copies the value in member color
 * @param _color New value to be copied in member color
 */
void visualization_msgs__Marker::color(
        const std_msgs__ColorRGBA& _color)
{
    m_color = _color;
}

/*!
 * @brief This function moves the value in member color
 * @param _color New value to be moved in member color
 */
void visualization_msgs__Marker::color(
        std_msgs__ColorRGBA&& _color)
{
    m_color = std::move(_color);
}

/*!
 * @brief This function returns a constant reference to member color
 * @return Constant reference to member color
 */
const std_msgs__ColorRGBA& visualization_msgs__Marker::color() const
{
    return m_color;
}

/*!
 * @brief This function returns a reference to member color
 * @return Reference to member color
 */
std_msgs__ColorRGBA& visualization_msgs__Marker::color()
{
    return m_color;
}
/*!
 * @brief This function copies the value in member lifetime
 * @param _lifetime New value to be copied in member lifetime
 */
void visualization_msgs__Marker::lifetime(
        const builtins__Duration& _lifetime)
{
    m_lifetime = _lifetime;
}

/*!
 * @brief This function moves the value in member lifetime
 * @param _lifetime New value to be moved in member lifetime
 */
void visualization_msgs__Marker::lifetime(
        builtins__Duration&& _lifetime)
{
    m_lifetime = std::move(_lifetime);
}

/*!
 * @brief This function returns a constant reference to member lifetime
 * @return Constant reference to member lifetime
 */
const builtins__Duration& visualization_msgs__Marker::lifetime() const
{
    return m_lifetime;
}

/*!
 * @brief This function returns a reference to member lifetime
 * @return Reference to member lifetime
 */
builtins__Duration& visualization_msgs__Marker::lifetime()
{
    return m_lifetime;
}
/*!
 * @brief This function sets a value in member frame_locked
 * @param _frame_locked New value for member frame_locked
 */
void visualization_msgs__Marker::frame_locked(
        bool _frame_locked)
{
    m_frame_locked = _frame_locked;
}

/*!
 * @brief This function returns the value of member frame_locked
 * @return Value of member frame_locked
 */
bool visualization_msgs__Marker::frame_locked() const
{
    return m_frame_locked;
}

/*!
 * @brief This function returns a reference to member frame_locked
 * @return Reference to member frame_locked
 */
bool& visualization_msgs__Marker::frame_locked()
{
    return m_frame_locked;
}

/*!
 * @brief This function copies the value in member points
 * @param _points New value to be copied in member points
 */
void visualization_msgs__Marker::points(
        const std::vector<geometry_msgs__Point>& _points)
{
    m_points = _points;
}

/*!
 * @brief This function moves the value in member points
 * @param _points New value to be moved in member points
 */
void visualization_msgs__Marker::points(
        std::vector<geometry_msgs__Point>&& _points)
{
    m_points = std::move(_points);
}

/*!
 * @brief This function returns a constant reference to member points
 * @return Constant reference to member points
 */
const std::vector<geometry_msgs__Point>& visualization_msgs__Marker::points() const
{
    return m_points;
}

/*!
 * @brief This function returns a reference to member points
 * @return Reference to member points
 */
std::vector<geometry_msgs__Point>& visualization_msgs__Marker::points()
{
    return m_points;
}
/*!
 * @brief This function copies the value in member colors
 * @param _colors New value to be copied in member colors
 */
void visualization_msgs__Marker::colors(
        const std::vector<std_msgs__ColorRGBA>& _colors)
{
    m_colors = _colors;
}

/*!
 * @brief This function moves the value in member colors
 * @param _colors New value to be moved in member colors
 */
void visualization_msgs__Marker::colors(
        std::vector<std_msgs__ColorRGBA>&& _colors)
{
    m_colors = std::move(_colors);
}

/*!
 * @brief This function returns a constant reference to member colors
 * @return Constant reference to member colors
 */
const std::vector<std_msgs__ColorRGBA>& visualization_msgs__Marker::colors() const
{
    return m_colors;
}

/*!
 * @brief This function returns a reference to member colors
 * @return Reference to member colors
 */
std::vector<std_msgs__ColorRGBA>& visualization_msgs__Marker::colors()
{
    return m_colors;
}
/*!
 * @brief This function copies the value in member text
 * @param _text New value to be copied in member text
 */
void visualization_msgs__Marker::text(
        const std::string& _text)
{
    m_text = _text;
}

/*!
 * @brief This function moves the value in member text
 * @param _text New value to be moved in member text
 */
void visualization_msgs__Marker::text(
        std::string&& _text)
{
    m_text = std::move(_text);
}

/*!
 * @brief This function returns a constant reference to member text
 * @return Constant reference to member text
 */
const std::string& visualization_msgs__Marker::text() const
{
    return m_text;
}

/*!
 * @brief This function returns a reference to member text
 * @return Reference to member text
 */
std::string& visualization_msgs__Marker::text()
{
    return m_text;
}
/*!
 * @brief This function copies the value in member mesh_resource
 * @param _mesh_resource New value to be copied in member mesh_resource
 */
void visualization_msgs__Marker::mesh_resource(
        const std::string& _mesh_resource)
{
    m_mesh_resource = _mesh_resource;
}

/*!
 * @brief This function moves the value in member mesh_resource
 * @param _mesh_resource New value to be moved in member mesh_resource
 */
void visualization_msgs__Marker::mesh_resource(
        std::string&& _mesh_resource)
{
    m_mesh_resource = std::move(_mesh_resource);
}

/*!
 * @brief This function returns a constant reference to member mesh_resource
 * @return Constant reference to member mesh_resource
 */
const std::string& visualization_msgs__Marker::mesh_resource() const
{
    return m_mesh_resource;
}

/*!
 * @brief This function returns a reference to member mesh_resource
 * @return Reference to member mesh_resource
 */
std::string& visualization_msgs__Marker::mesh_resource()
{
    return m_mesh_resource;
}
/*!
 * @brief This function sets a value in member mesh_use_embedded_materials
 * @param _mesh_use_embedded_materials New value for member mesh_use_embedded_materials
 */
void visualization_msgs__Marker::mesh_use_embedded_materials(
        bool _mesh_use_embedded_materials)
{
    m_mesh_use_embedded_materials = _mesh_use_embedded_materials;
}

/*!
 * @brief This function returns the value of member mesh_use_embedded_materials
 * @return Value of member mesh_use_embedded_materials
 */
bool visualization_msgs__Marker::mesh_use_embedded_materials() const
{
    return m_mesh_use_embedded_materials;
}

/*!
 * @brief This function returns a reference to member mesh_use_embedded_materials
 * @return Reference to member mesh_use_embedded_materials
 */
bool& visualization_msgs__Marker::mesh_use_embedded_materials()
{
    return m_mesh_use_embedded_materials;
}


size_t visualization_msgs__Marker::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t current_align = current_alignment;


















    return current_align;
}

bool visualization_msgs__Marker::isKeyDefined()
{
    return false;
}

void visualization_msgs__Marker::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
                   
}

foxglove_msgs__ImageMarkerArray::foxglove_msgs__ImageMarkerArray()
{
    // m_markers com.eprosima.idl.parser.typecode.SequenceTypeCode@3d299e3


}

foxglove_msgs__ImageMarkerArray::~foxglove_msgs__ImageMarkerArray()
{
}

foxglove_msgs__ImageMarkerArray::foxglove_msgs__ImageMarkerArray(
        const foxglove_msgs__ImageMarkerArray& x)
{
    m_markers = x.m_markers;
}

foxglove_msgs__ImageMarkerArray::foxglove_msgs__ImageMarkerArray(
        foxglove_msgs__ImageMarkerArray&& x)
{
    m_markers = std::move(x.m_markers);
}

foxglove_msgs__ImageMarkerArray& foxglove_msgs__ImageMarkerArray::operator =(
        const foxglove_msgs__ImageMarkerArray& x)
{

    m_markers = x.m_markers;

    return *this;
}

foxglove_msgs__ImageMarkerArray& foxglove_msgs__ImageMarkerArray::operator =(
        foxglove_msgs__ImageMarkerArray&& x)
{

    m_markers = std::move(x.m_markers);

    return *this;
}

bool foxglove_msgs__ImageMarkerArray::operator ==(
        const foxglove_msgs__ImageMarkerArray& x) const
{

    return (m_markers == x.m_markers);
}

bool foxglove_msgs__ImageMarkerArray::operator !=(
        const foxglove_msgs__ImageMarkerArray& x) const
{
    return !(*this == x);
}

size_t foxglove_msgs__ImageMarkerArray::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    for(size_t a = 0; a < 100; ++a)
    {
        current_alignment += visualization_msgs__ImageMarker::getMaxCdrSerializedSize(current_alignment);}

    return current_alignment - initial_alignment;
}

size_t foxglove_msgs__ImageMarkerArray::getCdrSerializedSize(
        const foxglove_msgs__ImageMarkerArray& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    for(size_t a = 0; a < data.markers().size(); ++a)
    {
        current_alignment += visualization_msgs__ImageMarker::getCdrSerializedSize(data.markers().at(a), current_alignment);}

    return current_alignment - initial_alignment;
}

void foxglove_msgs__ImageMarkerArray::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_markers;
}

void foxglove_msgs__ImageMarkerArray::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_markers;}

/*!
 * @brief This function copies the value in member markers
 * @param _markers New value to be copied in member markers
 */
void foxglove_msgs__ImageMarkerArray::markers(
        const std::vector<visualization_msgs__ImageMarker>& _markers)
{
    m_markers = _markers;
}

/*!
 * @brief This function moves the value in member markers
 * @param _markers New value to be moved in member markers
 */
void foxglove_msgs__ImageMarkerArray::markers(
        std::vector<visualization_msgs__ImageMarker>&& _markers)
{
    m_markers = std::move(_markers);
}

/*!
 * @brief This function returns a constant reference to member markers
 * @return Constant reference to member markers
 */
const std::vector<visualization_msgs__ImageMarker>& foxglove_msgs__ImageMarkerArray::markers() const
{
    return m_markers;
}

/*!
 * @brief This function returns a reference to member markers
 * @return Reference to member markers
 */
std::vector<visualization_msgs__ImageMarker>& foxglove_msgs__ImageMarkerArray::markers()
{
    return m_markers;
}

size_t foxglove_msgs__ImageMarkerArray::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t current_align = current_alignment;



    return current_align;
}

bool foxglove_msgs__ImageMarkerArray::isKeyDefined()
{
    return false;
}

void foxglove_msgs__ImageMarkerArray::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
     
}
