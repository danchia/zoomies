// Copyright 2016 Proyectos y Sistemas de Mantenimiento SL (eProsima).
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/*!
 * @file ros_types.cpp
 * This source file contains the definition of the described types in the IDL file.
 *
 * This file was generated by the tool gen.
 */

#ifdef _WIN32
// Remove linker warning LNK4221 on Visual Studio
namespace {
char dummy;
}  // namespace
#endif  // _WIN32

#include "ros_types.h"
#include <fastcdr/Cdr.h>

#include <fastcdr/exceptions/BadParamException.h>
using namespace eprosima::fastcdr::exception;

#include <utility>

builtins__Time::builtins__Time()
{
    // m_sec com.eprosima.idl.parser.typecode.PrimitiveTypeCode@553a3d88
    m_sec = 0;
    // m_nsec com.eprosima.idl.parser.typecode.PrimitiveTypeCode@cb0ed20
    m_nsec = 0;

}

builtins__Time::~builtins__Time()
{


}

builtins__Time::builtins__Time(
        const builtins__Time& x)
{
    m_sec = x.m_sec;
    m_nsec = x.m_nsec;
}

builtins__Time::builtins__Time(
        builtins__Time&& x)
{
    m_sec = x.m_sec;
    m_nsec = x.m_nsec;
}

builtins__Time& builtins__Time::operator =(
        const builtins__Time& x)
{

    m_sec = x.m_sec;
    m_nsec = x.m_nsec;

    return *this;
}

builtins__Time& builtins__Time::operator =(
        builtins__Time&& x)
{

    m_sec = x.m_sec;
    m_nsec = x.m_nsec;

    return *this;
}

bool builtins__Time::operator ==(
        const builtins__Time& x) const
{

    return (m_sec == x.m_sec && m_nsec == x.m_nsec);
}

bool builtins__Time::operator !=(
        const builtins__Time& x) const
{
    return !(*this == x);
}

size_t builtins__Time::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);



    return current_alignment - initial_alignment;
}

size_t builtins__Time::getCdrSerializedSize(
        const builtins__Time& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);



    return current_alignment - initial_alignment;
}

void builtins__Time::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_sec;
    scdr << m_nsec;

}

void builtins__Time::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_sec;
    dcdr >> m_nsec;
}

/*!
 * @brief This function sets a value in member sec
 * @param _sec New value for member sec
 */
void builtins__Time::sec(
        int32_t _sec)
{
    m_sec = _sec;
}

/*!
 * @brief This function returns the value of member sec
 * @return Value of member sec
 */
int32_t builtins__Time::sec() const
{
    return m_sec;
}

/*!
 * @brief This function returns a reference to member sec
 * @return Reference to member sec
 */
int32_t& builtins__Time::sec()
{
    return m_sec;
}

/*!
 * @brief This function sets a value in member nsec
 * @param _nsec New value for member nsec
 */
void builtins__Time::nsec(
        int32_t _nsec)
{
    m_nsec = _nsec;
}

/*!
 * @brief This function returns the value of member nsec
 * @return Value of member nsec
 */
int32_t builtins__Time::nsec() const
{
    return m_nsec;
}

/*!
 * @brief This function returns a reference to member nsec
 * @return Reference to member nsec
 */
int32_t& builtins__Time::nsec()
{
    return m_nsec;
}


size_t builtins__Time::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t current_align = current_alignment;





    return current_align;
}

bool builtins__Time::isKeyDefined()
{
    return false;
}

void builtins__Time::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
      
}

builtins__Duration::builtins__Duration()
{
    // m_sec com.eprosima.idl.parser.typecode.PrimitiveTypeCode@c81cdd1
    m_sec = 0;
    // m_nsec com.eprosima.idl.parser.typecode.PrimitiveTypeCode@1fc2b765
    m_nsec = 0;

}

builtins__Duration::~builtins__Duration()
{


}

builtins__Duration::builtins__Duration(
        const builtins__Duration& x)
{
    m_sec = x.m_sec;
    m_nsec = x.m_nsec;
}

builtins__Duration::builtins__Duration(
        builtins__Duration&& x)
{
    m_sec = x.m_sec;
    m_nsec = x.m_nsec;
}

builtins__Duration& builtins__Duration::operator =(
        const builtins__Duration& x)
{

    m_sec = x.m_sec;
    m_nsec = x.m_nsec;

    return *this;
}

builtins__Duration& builtins__Duration::operator =(
        builtins__Duration&& x)
{

    m_sec = x.m_sec;
    m_nsec = x.m_nsec;

    return *this;
}

bool builtins__Duration::operator ==(
        const builtins__Duration& x) const
{

    return (m_sec == x.m_sec && m_nsec == x.m_nsec);
}

bool builtins__Duration::operator !=(
        const builtins__Duration& x) const
{
    return !(*this == x);
}

size_t builtins__Duration::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);



    return current_alignment - initial_alignment;
}

size_t builtins__Duration::getCdrSerializedSize(
        const builtins__Duration& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);



    return current_alignment - initial_alignment;
}

void builtins__Duration::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_sec;
    scdr << m_nsec;

}

void builtins__Duration::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_sec;
    dcdr >> m_nsec;
}

/*!
 * @brief This function sets a value in member sec
 * @param _sec New value for member sec
 */
void builtins__Duration::sec(
        int32_t _sec)
{
    m_sec = _sec;
}

/*!
 * @brief This function returns the value of member sec
 * @return Value of member sec
 */
int32_t builtins__Duration::sec() const
{
    return m_sec;
}

/*!
 * @brief This function returns a reference to member sec
 * @return Reference to member sec
 */
int32_t& builtins__Duration::sec()
{
    return m_sec;
}

/*!
 * @brief This function sets a value in member nsec
 * @param _nsec New value for member nsec
 */
void builtins__Duration::nsec(
        int32_t _nsec)
{
    m_nsec = _nsec;
}

/*!
 * @brief This function returns the value of member nsec
 * @return Value of member nsec
 */
int32_t builtins__Duration::nsec() const
{
    return m_nsec;
}

/*!
 * @brief This function returns a reference to member nsec
 * @return Reference to member nsec
 */
int32_t& builtins__Duration::nsec()
{
    return m_nsec;
}


size_t builtins__Duration::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t current_align = current_alignment;





    return current_align;
}

bool builtins__Duration::isKeyDefined()
{
    return false;
}

void builtins__Duration::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
      
}

std_msgs__Header::std_msgs__Header()
{
    // m_stamp com.eprosima.fastdds.idl.parser.typecode.StructTypeCode@517cd4b

    // m_frame_id com.eprosima.idl.parser.typecode.StringTypeCode@6cc7b4de
    m_frame_id ="";

}

std_msgs__Header::~std_msgs__Header()
{


}

std_msgs__Header::std_msgs__Header(
        const std_msgs__Header& x)
{
    m_stamp = x.m_stamp;
    m_frame_id = x.m_frame_id;
}

std_msgs__Header::std_msgs__Header(
        std_msgs__Header&& x)
{
    m_stamp = std::move(x.m_stamp);
    m_frame_id = std::move(x.m_frame_id);
}

std_msgs__Header& std_msgs__Header::operator =(
        const std_msgs__Header& x)
{

    m_stamp = x.m_stamp;
    m_frame_id = x.m_frame_id;

    return *this;
}

std_msgs__Header& std_msgs__Header::operator =(
        std_msgs__Header&& x)
{

    m_stamp = std::move(x.m_stamp);
    m_frame_id = std::move(x.m_frame_id);

    return *this;
}

bool std_msgs__Header::operator ==(
        const std_msgs__Header& x) const
{

    return (m_stamp == x.m_stamp && m_frame_id == x.m_frame_id);
}

bool std_msgs__Header::operator !=(
        const std_msgs__Header& x) const
{
    return !(*this == x);
}

size_t std_msgs__Header::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t initial_alignment = current_alignment;


    current_alignment += builtins__Time::getMaxCdrSerializedSize(current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 255 + 1;


    return current_alignment - initial_alignment;
}

size_t std_msgs__Header::getCdrSerializedSize(
        const std_msgs__Header& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += builtins__Time::getCdrSerializedSize(data.stamp(), current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.frame_id().size() + 1;


    return current_alignment - initial_alignment;
}

void std_msgs__Header::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_stamp;
    scdr << m_frame_id;

}

void std_msgs__Header::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_stamp;
    dcdr >> m_frame_id;
}

/*!
 * @brief This function copies the value in member stamp
 * @param _stamp New value to be copied in member stamp
 */
void std_msgs__Header::stamp(
        const builtins__Time& _stamp)
{
    m_stamp = _stamp;
}

/*!
 * @brief This function moves the value in member stamp
 * @param _stamp New value to be moved in member stamp
 */
void std_msgs__Header::stamp(
        builtins__Time&& _stamp)
{
    m_stamp = std::move(_stamp);
}

/*!
 * @brief This function returns a constant reference to member stamp
 * @return Constant reference to member stamp
 */
const builtins__Time& std_msgs__Header::stamp() const
{
    return m_stamp;
}

/*!
 * @brief This function returns a reference to member stamp
 * @return Reference to member stamp
 */
builtins__Time& std_msgs__Header::stamp()
{
    return m_stamp;
}
/*!
 * @brief This function copies the value in member frame_id
 * @param _frame_id New value to be copied in member frame_id
 */
void std_msgs__Header::frame_id(
        const std::string& _frame_id)
{
    m_frame_id = _frame_id;
}

/*!
 * @brief This function moves the value in member frame_id
 * @param _frame_id New value to be moved in member frame_id
 */
void std_msgs__Header::frame_id(
        std::string&& _frame_id)
{
    m_frame_id = std::move(_frame_id);
}

/*!
 * @brief This function returns a constant reference to member frame_id
 * @return Constant reference to member frame_id
 */
const std::string& std_msgs__Header::frame_id() const
{
    return m_frame_id;
}

/*!
 * @brief This function returns a reference to member frame_id
 * @return Reference to member frame_id
 */
std::string& std_msgs__Header::frame_id()
{
    return m_frame_id;
}

size_t std_msgs__Header::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t current_align = current_alignment;





    return current_align;
}

bool std_msgs__Header::isKeyDefined()
{
    return false;
}

void std_msgs__Header::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
      
}

std_msgs__ColorRGBA::std_msgs__ColorRGBA()
{
    // m_r com.eprosima.idl.parser.typecode.PrimitiveTypeCode@799d4f69
    m_r = 0.0;
    // m_g com.eprosima.idl.parser.typecode.PrimitiveTypeCode@49c43f4e
    m_g = 0.0;
    // m_b com.eprosima.idl.parser.typecode.PrimitiveTypeCode@290dbf45
    m_b = 0.0;
    // m_a com.eprosima.idl.parser.typecode.PrimitiveTypeCode@12028586
    m_a = 0.0;

}

std_msgs__ColorRGBA::~std_msgs__ColorRGBA()
{




}

std_msgs__ColorRGBA::std_msgs__ColorRGBA(
        const std_msgs__ColorRGBA& x)
{
    m_r = x.m_r;
    m_g = x.m_g;
    m_b = x.m_b;
    m_a = x.m_a;
}

std_msgs__ColorRGBA::std_msgs__ColorRGBA(
        std_msgs__ColorRGBA&& x)
{
    m_r = x.m_r;
    m_g = x.m_g;
    m_b = x.m_b;
    m_a = x.m_a;
}

std_msgs__ColorRGBA& std_msgs__ColorRGBA::operator =(
        const std_msgs__ColorRGBA& x)
{

    m_r = x.m_r;
    m_g = x.m_g;
    m_b = x.m_b;
    m_a = x.m_a;

    return *this;
}

std_msgs__ColorRGBA& std_msgs__ColorRGBA::operator =(
        std_msgs__ColorRGBA&& x)
{

    m_r = x.m_r;
    m_g = x.m_g;
    m_b = x.m_b;
    m_a = x.m_a;

    return *this;
}

bool std_msgs__ColorRGBA::operator ==(
        const std_msgs__ColorRGBA& x) const
{

    return (m_r == x.m_r && m_g == x.m_g && m_b == x.m_b && m_a == x.m_a);
}

bool std_msgs__ColorRGBA::operator !=(
        const std_msgs__ColorRGBA& x) const
{
    return !(*this == x);
}

size_t std_msgs__ColorRGBA::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);



    return current_alignment - initial_alignment;
}

size_t std_msgs__ColorRGBA::getCdrSerializedSize(
        const std_msgs__ColorRGBA& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);



    return current_alignment - initial_alignment;
}

void std_msgs__ColorRGBA::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_r;
    scdr << m_g;
    scdr << m_b;
    scdr << m_a;

}

void std_msgs__ColorRGBA::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_r;
    dcdr >> m_g;
    dcdr >> m_b;
    dcdr >> m_a;
}

/*!
 * @brief This function sets a value in member r
 * @param _r New value for member r
 */
void std_msgs__ColorRGBA::r(
        float _r)
{
    m_r = _r;
}

/*!
 * @brief This function returns the value of member r
 * @return Value of member r
 */
float std_msgs__ColorRGBA::r() const
{
    return m_r;
}

/*!
 * @brief This function returns a reference to member r
 * @return Reference to member r
 */
float& std_msgs__ColorRGBA::r()
{
    return m_r;
}

/*!
 * @brief This function sets a value in member g
 * @param _g New value for member g
 */
void std_msgs__ColorRGBA::g(
        float _g)
{
    m_g = _g;
}

/*!
 * @brief This function returns the value of member g
 * @return Value of member g
 */
float std_msgs__ColorRGBA::g() const
{
    return m_g;
}

/*!
 * @brief This function returns a reference to member g
 * @return Reference to member g
 */
float& std_msgs__ColorRGBA::g()
{
    return m_g;
}

/*!
 * @brief This function sets a value in member b
 * @param _b New value for member b
 */
void std_msgs__ColorRGBA::b(
        float _b)
{
    m_b = _b;
}

/*!
 * @brief This function returns the value of member b
 * @return Value of member b
 */
float std_msgs__ColorRGBA::b() const
{
    return m_b;
}

/*!
 * @brief This function returns a reference to member b
 * @return Reference to member b
 */
float& std_msgs__ColorRGBA::b()
{
    return m_b;
}

/*!
 * @brief This function sets a value in member a
 * @param _a New value for member a
 */
void std_msgs__ColorRGBA::a(
        float _a)
{
    m_a = _a;
}

/*!
 * @brief This function returns the value of member a
 * @return Value of member a
 */
float std_msgs__ColorRGBA::a() const
{
    return m_a;
}

/*!
 * @brief This function returns a reference to member a
 * @return Reference to member a
 */
float& std_msgs__ColorRGBA::a()
{
    return m_a;
}


size_t std_msgs__ColorRGBA::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t current_align = current_alignment;







    return current_align;
}

bool std_msgs__ColorRGBA::isKeyDefined()
{
    return false;
}

void std_msgs__ColorRGBA::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
        
}

sensor_msgs__RegionOfInterest::sensor_msgs__RegionOfInterest()
{
    // m_x_offset com.eprosima.idl.parser.typecode.PrimitiveTypeCode@4df828d7
    m_x_offset = 0;
    // m_y_offset com.eprosima.idl.parser.typecode.PrimitiveTypeCode@b59d31
    m_y_offset = 0;
    // m_height com.eprosima.idl.parser.typecode.PrimitiveTypeCode@62fdb4a6
    m_height = 0;
    // m_width com.eprosima.idl.parser.typecode.PrimitiveTypeCode@11e21d0e
    m_width = 0;
    // m_do_rectify com.eprosima.idl.parser.typecode.PrimitiveTypeCode@1dd02175
    m_do_rectify = false;

}

sensor_msgs__RegionOfInterest::~sensor_msgs__RegionOfInterest()
{





}

sensor_msgs__RegionOfInterest::sensor_msgs__RegionOfInterest(
        const sensor_msgs__RegionOfInterest& x)
{
    m_x_offset = x.m_x_offset;
    m_y_offset = x.m_y_offset;
    m_height = x.m_height;
    m_width = x.m_width;
    m_do_rectify = x.m_do_rectify;
}

sensor_msgs__RegionOfInterest::sensor_msgs__RegionOfInterest(
        sensor_msgs__RegionOfInterest&& x)
{
    m_x_offset = x.m_x_offset;
    m_y_offset = x.m_y_offset;
    m_height = x.m_height;
    m_width = x.m_width;
    m_do_rectify = x.m_do_rectify;
}

sensor_msgs__RegionOfInterest& sensor_msgs__RegionOfInterest::operator =(
        const sensor_msgs__RegionOfInterest& x)
{

    m_x_offset = x.m_x_offset;
    m_y_offset = x.m_y_offset;
    m_height = x.m_height;
    m_width = x.m_width;
    m_do_rectify = x.m_do_rectify;

    return *this;
}

sensor_msgs__RegionOfInterest& sensor_msgs__RegionOfInterest::operator =(
        sensor_msgs__RegionOfInterest&& x)
{

    m_x_offset = x.m_x_offset;
    m_y_offset = x.m_y_offset;
    m_height = x.m_height;
    m_width = x.m_width;
    m_do_rectify = x.m_do_rectify;

    return *this;
}

bool sensor_msgs__RegionOfInterest::operator ==(
        const sensor_msgs__RegionOfInterest& x) const
{

    return (m_x_offset == x.m_x_offset && m_y_offset == x.m_y_offset && m_height == x.m_height && m_width == x.m_width && m_do_rectify == x.m_do_rectify);
}

bool sensor_msgs__RegionOfInterest::operator !=(
        const sensor_msgs__RegionOfInterest& x) const
{
    return !(*this == x);
}

size_t sensor_msgs__RegionOfInterest::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);



    return current_alignment - initial_alignment;
}

size_t sensor_msgs__RegionOfInterest::getCdrSerializedSize(
        const sensor_msgs__RegionOfInterest& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);



    return current_alignment - initial_alignment;
}

void sensor_msgs__RegionOfInterest::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_x_offset;
    scdr << m_y_offset;
    scdr << m_height;
    scdr << m_width;
    scdr << m_do_rectify;

}

void sensor_msgs__RegionOfInterest::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_x_offset;
    dcdr >> m_y_offset;
    dcdr >> m_height;
    dcdr >> m_width;
    dcdr >> m_do_rectify;
}

/*!
 * @brief This function sets a value in member x_offset
 * @param _x_offset New value for member x_offset
 */
void sensor_msgs__RegionOfInterest::x_offset(
        uint32_t _x_offset)
{
    m_x_offset = _x_offset;
}

/*!
 * @brief This function returns the value of member x_offset
 * @return Value of member x_offset
 */
uint32_t sensor_msgs__RegionOfInterest::x_offset() const
{
    return m_x_offset;
}

/*!
 * @brief This function returns a reference to member x_offset
 * @return Reference to member x_offset
 */
uint32_t& sensor_msgs__RegionOfInterest::x_offset()
{
    return m_x_offset;
}

/*!
 * @brief This function sets a value in member y_offset
 * @param _y_offset New value for member y_offset
 */
void sensor_msgs__RegionOfInterest::y_offset(
        uint32_t _y_offset)
{
    m_y_offset = _y_offset;
}

/*!
 * @brief This function returns the value of member y_offset
 * @return Value of member y_offset
 */
uint32_t sensor_msgs__RegionOfInterest::y_offset() const
{
    return m_y_offset;
}

/*!
 * @brief This function returns a reference to member y_offset
 * @return Reference to member y_offset
 */
uint32_t& sensor_msgs__RegionOfInterest::y_offset()
{
    return m_y_offset;
}

/*!
 * @brief This function sets a value in member height
 * @param _height New value for member height
 */
void sensor_msgs__RegionOfInterest::height(
        uint32_t _height)
{
    m_height = _height;
}

/*!
 * @brief This function returns the value of member height
 * @return Value of member height
 */
uint32_t sensor_msgs__RegionOfInterest::height() const
{
    return m_height;
}

/*!
 * @brief This function returns a reference to member height
 * @return Reference to member height
 */
uint32_t& sensor_msgs__RegionOfInterest::height()
{
    return m_height;
}

/*!
 * @brief This function sets a value in member width
 * @param _width New value for member width
 */
void sensor_msgs__RegionOfInterest::width(
        uint32_t _width)
{
    m_width = _width;
}

/*!
 * @brief This function returns the value of member width
 * @return Value of member width
 */
uint32_t sensor_msgs__RegionOfInterest::width() const
{
    return m_width;
}

/*!
 * @brief This function returns a reference to member width
 * @return Reference to member width
 */
uint32_t& sensor_msgs__RegionOfInterest::width()
{
    return m_width;
}

/*!
 * @brief This function sets a value in member do_rectify
 * @param _do_rectify New value for member do_rectify
 */
void sensor_msgs__RegionOfInterest::do_rectify(
        bool _do_rectify)
{
    m_do_rectify = _do_rectify;
}

/*!
 * @brief This function returns the value of member do_rectify
 * @return Value of member do_rectify
 */
bool sensor_msgs__RegionOfInterest::do_rectify() const
{
    return m_do_rectify;
}

/*!
 * @brief This function returns a reference to member do_rectify
 * @return Reference to member do_rectify
 */
bool& sensor_msgs__RegionOfInterest::do_rectify()
{
    return m_do_rectify;
}


size_t sensor_msgs__RegionOfInterest::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t current_align = current_alignment;








    return current_align;
}

bool sensor_msgs__RegionOfInterest::isKeyDefined()
{
    return false;
}

void sensor_msgs__RegionOfInterest::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
         
}

sensor_msgs__CameraInfo::sensor_msgs__CameraInfo()
{
    // m_header com.eprosima.fastdds.idl.parser.typecode.StructTypeCode@7fe8ea47

    // m_height com.eprosima.idl.parser.typecode.PrimitiveTypeCode@226a82c4
    m_height = 0;
    // m_width com.eprosima.idl.parser.typecode.PrimitiveTypeCode@731f8236
    m_width = 0;
    // m_distortion_model com.eprosima.idl.parser.typecode.StringTypeCode@6b53e23f
    m_distortion_model ="";
    // m_D com.eprosima.idl.parser.typecode.SequenceTypeCode@64d2d351

    // m_K com.eprosima.idl.parser.typecode.ArrayTypeCode@1b68b9a4
    memset(&m_K, 0, (9) * 8);
    // m_R com.eprosima.idl.parser.typecode.ArrayTypeCode@4f9a3314
    memset(&m_R, 0, (9) * 8);
    // m_P com.eprosima.idl.parser.typecode.ArrayTypeCode@3b2c72c2
    memset(&m_P, 0, (12) * 8);
    // m_binning_x com.eprosima.idl.parser.typecode.PrimitiveTypeCode@491666ad
    m_binning_x = 0;
    // m_binning_y com.eprosima.idl.parser.typecode.PrimitiveTypeCode@51931956
    m_binning_y = 0;
    // m_roi com.eprosima.fastdds.idl.parser.typecode.StructTypeCode@2b4a2ec7


}

sensor_msgs__CameraInfo::~sensor_msgs__CameraInfo()
{











}

sensor_msgs__CameraInfo::sensor_msgs__CameraInfo(
        const sensor_msgs__CameraInfo& x)
{
    m_header = x.m_header;
    m_height = x.m_height;
    m_width = x.m_width;
    m_distortion_model = x.m_distortion_model;
    m_D = x.m_D;
    m_K = x.m_K;
    m_R = x.m_R;
    m_P = x.m_P;
    m_binning_x = x.m_binning_x;
    m_binning_y = x.m_binning_y;
    m_roi = x.m_roi;
}

sensor_msgs__CameraInfo::sensor_msgs__CameraInfo(
        sensor_msgs__CameraInfo&& x)
{
    m_header = std::move(x.m_header);
    m_height = x.m_height;
    m_width = x.m_width;
    m_distortion_model = std::move(x.m_distortion_model);
    m_D = std::move(x.m_D);
    m_K = std::move(x.m_K);
    m_R = std::move(x.m_R);
    m_P = std::move(x.m_P);
    m_binning_x = x.m_binning_x;
    m_binning_y = x.m_binning_y;
    m_roi = std::move(x.m_roi);
}

sensor_msgs__CameraInfo& sensor_msgs__CameraInfo::operator =(
        const sensor_msgs__CameraInfo& x)
{

    m_header = x.m_header;
    m_height = x.m_height;
    m_width = x.m_width;
    m_distortion_model = x.m_distortion_model;
    m_D = x.m_D;
    m_K = x.m_K;
    m_R = x.m_R;
    m_P = x.m_P;
    m_binning_x = x.m_binning_x;
    m_binning_y = x.m_binning_y;
    m_roi = x.m_roi;

    return *this;
}

sensor_msgs__CameraInfo& sensor_msgs__CameraInfo::operator =(
        sensor_msgs__CameraInfo&& x)
{

    m_header = std::move(x.m_header);
    m_height = x.m_height;
    m_width = x.m_width;
    m_distortion_model = std::move(x.m_distortion_model);
    m_D = std::move(x.m_D);
    m_K = std::move(x.m_K);
    m_R = std::move(x.m_R);
    m_P = std::move(x.m_P);
    m_binning_x = x.m_binning_x;
    m_binning_y = x.m_binning_y;
    m_roi = std::move(x.m_roi);

    return *this;
}

bool sensor_msgs__CameraInfo::operator ==(
        const sensor_msgs__CameraInfo& x) const
{

    return (m_header == x.m_header && m_height == x.m_height && m_width == x.m_width && m_distortion_model == x.m_distortion_model && m_D == x.m_D && m_K == x.m_K && m_R == x.m_R && m_P == x.m_P && m_binning_x == x.m_binning_x && m_binning_y == x.m_binning_y && m_roi == x.m_roi);
}

bool sensor_msgs__CameraInfo::operator !=(
        const sensor_msgs__CameraInfo& x) const
{
    return !(*this == x);
}

size_t sensor_msgs__CameraInfo::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t initial_alignment = current_alignment;


    current_alignment += std_msgs__Header::getMaxCdrSerializedSize(current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 255 + 1;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    current_alignment += (100 * 8) + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);



    current_alignment += ((9) * 8) + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    current_alignment += ((9) * 8) + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    current_alignment += ((12) * 8) + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += sensor_msgs__RegionOfInterest::getMaxCdrSerializedSize(current_alignment);

    return current_alignment - initial_alignment;
}

size_t sensor_msgs__CameraInfo::getCdrSerializedSize(
        const sensor_msgs__CameraInfo& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += std_msgs__Header::getCdrSerializedSize(data.header(), current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.distortion_model().size() + 1;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    if (data.D().size() > 0)
    {
        current_alignment += (data.D().size() * 8) + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);
    }



    if ((9) > 0)
    {
        current_alignment += ((9) * 8) + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);
    }

    if ((9) > 0)
    {
        current_alignment += ((9) * 8) + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);
    }

    if ((12) > 0)
    {
        current_alignment += ((12) * 8) + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);
    }

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += sensor_msgs__RegionOfInterest::getCdrSerializedSize(data.roi(), current_alignment);

    return current_alignment - initial_alignment;
}

void sensor_msgs__CameraInfo::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_header;
    scdr << m_height;
    scdr << m_width;
    scdr << m_distortion_model;
    scdr << m_D;
    scdr << m_K;

    scdr << m_R;

    scdr << m_P;

    scdr << m_binning_x;
    scdr << m_binning_y;
    scdr << m_roi;

}

void sensor_msgs__CameraInfo::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_header;
    dcdr >> m_height;
    dcdr >> m_width;
    dcdr >> m_distortion_model;
    dcdr >> m_D;
    dcdr >> m_K;

    dcdr >> m_R;

    dcdr >> m_P;

    dcdr >> m_binning_x;
    dcdr >> m_binning_y;
    dcdr >> m_roi;
}

/*!
 * @brief This function copies the value in member header
 * @param _header New value to be copied in member header
 */
void sensor_msgs__CameraInfo::header(
        const std_msgs__Header& _header)
{
    m_header = _header;
}

/*!
 * @brief This function moves the value in member header
 * @param _header New value to be moved in member header
 */
void sensor_msgs__CameraInfo::header(
        std_msgs__Header&& _header)
{
    m_header = std::move(_header);
}

/*!
 * @brief This function returns a constant reference to member header
 * @return Constant reference to member header
 */
const std_msgs__Header& sensor_msgs__CameraInfo::header() const
{
    return m_header;
}

/*!
 * @brief This function returns a reference to member header
 * @return Reference to member header
 */
std_msgs__Header& sensor_msgs__CameraInfo::header()
{
    return m_header;
}
/*!
 * @brief This function sets a value in member height
 * @param _height New value for member height
 */
void sensor_msgs__CameraInfo::height(
        uint32_t _height)
{
    m_height = _height;
}

/*!
 * @brief This function returns the value of member height
 * @return Value of member height
 */
uint32_t sensor_msgs__CameraInfo::height() const
{
    return m_height;
}

/*!
 * @brief This function returns a reference to member height
 * @return Reference to member height
 */
uint32_t& sensor_msgs__CameraInfo::height()
{
    return m_height;
}

/*!
 * @brief This function sets a value in member width
 * @param _width New value for member width
 */
void sensor_msgs__CameraInfo::width(
        uint32_t _width)
{
    m_width = _width;
}

/*!
 * @brief This function returns the value of member width
 * @return Value of member width
 */
uint32_t sensor_msgs__CameraInfo::width() const
{
    return m_width;
}

/*!
 * @brief This function returns a reference to member width
 * @return Reference to member width
 */
uint32_t& sensor_msgs__CameraInfo::width()
{
    return m_width;
}

/*!
 * @brief This function copies the value in member distortion_model
 * @param _distortion_model New value to be copied in member distortion_model
 */
void sensor_msgs__CameraInfo::distortion_model(
        const std::string& _distortion_model)
{
    m_distortion_model = _distortion_model;
}

/*!
 * @brief This function moves the value in member distortion_model
 * @param _distortion_model New value to be moved in member distortion_model
 */
void sensor_msgs__CameraInfo::distortion_model(
        std::string&& _distortion_model)
{
    m_distortion_model = std::move(_distortion_model);
}

/*!
 * @brief This function returns a constant reference to member distortion_model
 * @return Constant reference to member distortion_model
 */
const std::string& sensor_msgs__CameraInfo::distortion_model() const
{
    return m_distortion_model;
}

/*!
 * @brief This function returns a reference to member distortion_model
 * @return Reference to member distortion_model
 */
std::string& sensor_msgs__CameraInfo::distortion_model()
{
    return m_distortion_model;
}
/*!
 * @brief This function copies the value in member D
 * @param _D New value to be copied in member D
 */
void sensor_msgs__CameraInfo::D(
        const std::vector<double>& _D)
{
    m_D = _D;
}

/*!
 * @brief This function moves the value in member D
 * @param _D New value to be moved in member D
 */
void sensor_msgs__CameraInfo::D(
        std::vector<double>&& _D)
{
    m_D = std::move(_D);
}

/*!
 * @brief This function returns a constant reference to member D
 * @return Constant reference to member D
 */
const std::vector<double>& sensor_msgs__CameraInfo::D() const
{
    return m_D;
}

/*!
 * @brief This function returns a reference to member D
 * @return Reference to member D
 */
std::vector<double>& sensor_msgs__CameraInfo::D()
{
    return m_D;
}
/*!
 * @brief This function copies the value in member K
 * @param _K New value to be copied in member K
 */
void sensor_msgs__CameraInfo::K(
        const std::array<double, 9>& _K)
{
    m_K = _K;
}

/*!
 * @brief This function moves the value in member K
 * @param _K New value to be moved in member K
 */
void sensor_msgs__CameraInfo::K(
        std::array<double, 9>&& _K)
{
    m_K = std::move(_K);
}

/*!
 * @brief This function returns a constant reference to member K
 * @return Constant reference to member K
 */
const std::array<double, 9>& sensor_msgs__CameraInfo::K() const
{
    return m_K;
}

/*!
 * @brief This function returns a reference to member K
 * @return Reference to member K
 */
std::array<double, 9>& sensor_msgs__CameraInfo::K()
{
    return m_K;
}
/*!
 * @brief This function copies the value in member R
 * @param _R New value to be copied in member R
 */
void sensor_msgs__CameraInfo::R(
        const std::array<double, 9>& _R)
{
    m_R = _R;
}

/*!
 * @brief This function moves the value in member R
 * @param _R New value to be moved in member R
 */
void sensor_msgs__CameraInfo::R(
        std::array<double, 9>&& _R)
{
    m_R = std::move(_R);
}

/*!
 * @brief This function returns a constant reference to member R
 * @return Constant reference to member R
 */
const std::array<double, 9>& sensor_msgs__CameraInfo::R() const
{
    return m_R;
}

/*!
 * @brief This function returns a reference to member R
 * @return Reference to member R
 */
std::array<double, 9>& sensor_msgs__CameraInfo::R()
{
    return m_R;
}
/*!
 * @brief This function copies the value in member P
 * @param _P New value to be copied in member P
 */
void sensor_msgs__CameraInfo::P(
        const std::array<double, 12>& _P)
{
    m_P = _P;
}

/*!
 * @brief This function moves the value in member P
 * @param _P New value to be moved in member P
 */
void sensor_msgs__CameraInfo::P(
        std::array<double, 12>&& _P)
{
    m_P = std::move(_P);
}

/*!
 * @brief This function returns a constant reference to member P
 * @return Constant reference to member P
 */
const std::array<double, 12>& sensor_msgs__CameraInfo::P() const
{
    return m_P;
}

/*!
 * @brief This function returns a reference to member P
 * @return Reference to member P
 */
std::array<double, 12>& sensor_msgs__CameraInfo::P()
{
    return m_P;
}
/*!
 * @brief This function sets a value in member binning_x
 * @param _binning_x New value for member binning_x
 */
void sensor_msgs__CameraInfo::binning_x(
        uint32_t _binning_x)
{
    m_binning_x = _binning_x;
}

/*!
 * @brief This function returns the value of member binning_x
 * @return Value of member binning_x
 */
uint32_t sensor_msgs__CameraInfo::binning_x() const
{
    return m_binning_x;
}

/*!
 * @brief This function returns a reference to member binning_x
 * @return Reference to member binning_x
 */
uint32_t& sensor_msgs__CameraInfo::binning_x()
{
    return m_binning_x;
}

/*!
 * @brief This function sets a value in member binning_y
 * @param _binning_y New value for member binning_y
 */
void sensor_msgs__CameraInfo::binning_y(
        uint32_t _binning_y)
{
    m_binning_y = _binning_y;
}

/*!
 * @brief This function returns the value of member binning_y
 * @return Value of member binning_y
 */
uint32_t sensor_msgs__CameraInfo::binning_y() const
{
    return m_binning_y;
}

/*!
 * @brief This function returns a reference to member binning_y
 * @return Reference to member binning_y
 */
uint32_t& sensor_msgs__CameraInfo::binning_y()
{
    return m_binning_y;
}

/*!
 * @brief This function copies the value in member roi
 * @param _roi New value to be copied in member roi
 */
void sensor_msgs__CameraInfo::roi(
        const sensor_msgs__RegionOfInterest& _roi)
{
    m_roi = _roi;
}

/*!
 * @brief This function moves the value in member roi
 * @param _roi New value to be moved in member roi
 */
void sensor_msgs__CameraInfo::roi(
        sensor_msgs__RegionOfInterest&& _roi)
{
    m_roi = std::move(_roi);
}

/*!
 * @brief This function returns a constant reference to member roi
 * @return Constant reference to member roi
 */
const sensor_msgs__RegionOfInterest& sensor_msgs__CameraInfo::roi() const
{
    return m_roi;
}

/*!
 * @brief This function returns a reference to member roi
 * @return Reference to member roi
 */
sensor_msgs__RegionOfInterest& sensor_msgs__CameraInfo::roi()
{
    return m_roi;
}

size_t sensor_msgs__CameraInfo::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t current_align = current_alignment;














    return current_align;
}

bool sensor_msgs__CameraInfo::isKeyDefined()
{
    return false;
}

void sensor_msgs__CameraInfo::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
               
}

sensor_msgs__Image::sensor_msgs__Image()
{
    // m_header com.eprosima.fastdds.idl.parser.typecode.StructTypeCode@7fe8ea47

    // m_height com.eprosima.idl.parser.typecode.PrimitiveTypeCode@1a38c59b
    m_height = 0;
    // m_width com.eprosima.idl.parser.typecode.PrimitiveTypeCode@7f77e91b
    m_width = 0;
    // m_encoding com.eprosima.idl.parser.typecode.StringTypeCode@44a664f2
    m_encoding ="";
    // m_is_bigendian com.eprosima.idl.parser.typecode.PrimitiveTypeCode@7f9fcf7f
    m_is_bigendian = 0;
    // m_step com.eprosima.idl.parser.typecode.PrimitiveTypeCode@2357d90a
    m_step = 0;
    // m_data com.eprosima.idl.parser.typecode.SequenceTypeCode@6328d34a


}

sensor_msgs__Image::~sensor_msgs__Image()
{







}

sensor_msgs__Image::sensor_msgs__Image(
        const sensor_msgs__Image& x)
{
    m_header = x.m_header;
    m_height = x.m_height;
    m_width = x.m_width;
    m_encoding = x.m_encoding;
    m_is_bigendian = x.m_is_bigendian;
    m_step = x.m_step;
    m_data = x.m_data;
}

sensor_msgs__Image::sensor_msgs__Image(
        sensor_msgs__Image&& x)
{
    m_header = std::move(x.m_header);
    m_height = x.m_height;
    m_width = x.m_width;
    m_encoding = std::move(x.m_encoding);
    m_is_bigendian = x.m_is_bigendian;
    m_step = x.m_step;
    m_data = std::move(x.m_data);
}

sensor_msgs__Image& sensor_msgs__Image::operator =(
        const sensor_msgs__Image& x)
{

    m_header = x.m_header;
    m_height = x.m_height;
    m_width = x.m_width;
    m_encoding = x.m_encoding;
    m_is_bigendian = x.m_is_bigendian;
    m_step = x.m_step;
    m_data = x.m_data;

    return *this;
}

sensor_msgs__Image& sensor_msgs__Image::operator =(
        sensor_msgs__Image&& x)
{

    m_header = std::move(x.m_header);
    m_height = x.m_height;
    m_width = x.m_width;
    m_encoding = std::move(x.m_encoding);
    m_is_bigendian = x.m_is_bigendian;
    m_step = x.m_step;
    m_data = std::move(x.m_data);

    return *this;
}

bool sensor_msgs__Image::operator ==(
        const sensor_msgs__Image& x) const
{

    return (m_header == x.m_header && m_height == x.m_height && m_width == x.m_width && m_encoding == x.m_encoding && m_is_bigendian == x.m_is_bigendian && m_step == x.m_step && m_data == x.m_data);
}

bool sensor_msgs__Image::operator !=(
        const sensor_msgs__Image& x) const
{
    return !(*this == x);
}

size_t sensor_msgs__Image::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t initial_alignment = current_alignment;


    current_alignment += std_msgs__Header::getMaxCdrSerializedSize(current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 255 + 1;

    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    current_alignment += (100 * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);




    return current_alignment - initial_alignment;
}

size_t sensor_msgs__Image::getCdrSerializedSize(
        const sensor_msgs__Image& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += std_msgs__Header::getCdrSerializedSize(data.header(), current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.encoding().size() + 1;

    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    if (data.data().size() > 0)
    {
        current_alignment += (data.data().size() * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);
    }




    return current_alignment - initial_alignment;
}

void sensor_msgs__Image::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_header;
    scdr << m_height;
    scdr << m_width;
    scdr << m_encoding;
    scdr << m_is_bigendian;
    scdr << m_step;
    scdr << m_data;

}

void sensor_msgs__Image::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_header;
    dcdr >> m_height;
    dcdr >> m_width;
    dcdr >> m_encoding;
    dcdr >> m_is_bigendian;
    dcdr >> m_step;
    dcdr >> m_data;
}

/*!
 * @brief This function copies the value in member header
 * @param _header New value to be copied in member header
 */
void sensor_msgs__Image::header(
        const std_msgs__Header& _header)
{
    m_header = _header;
}

/*!
 * @brief This function moves the value in member header
 * @param _header New value to be moved in member header
 */
void sensor_msgs__Image::header(
        std_msgs__Header&& _header)
{
    m_header = std::move(_header);
}

/*!
 * @brief This function returns a constant reference to member header
 * @return Constant reference to member header
 */
const std_msgs__Header& sensor_msgs__Image::header() const
{
    return m_header;
}

/*!
 * @brief This function returns a reference to member header
 * @return Reference to member header
 */
std_msgs__Header& sensor_msgs__Image::header()
{
    return m_header;
}
/*!
 * @brief This function sets a value in member height
 * @param _height New value for member height
 */
void sensor_msgs__Image::height(
        uint32_t _height)
{
    m_height = _height;
}

/*!
 * @brief This function returns the value of member height
 * @return Value of member height
 */
uint32_t sensor_msgs__Image::height() const
{
    return m_height;
}

/*!
 * @brief This function returns a reference to member height
 * @return Reference to member height
 */
uint32_t& sensor_msgs__Image::height()
{
    return m_height;
}

/*!
 * @brief This function sets a value in member width
 * @param _width New value for member width
 */
void sensor_msgs__Image::width(
        uint32_t _width)
{
    m_width = _width;
}

/*!
 * @brief This function returns the value of member width
 * @return Value of member width
 */
uint32_t sensor_msgs__Image::width() const
{
    return m_width;
}

/*!
 * @brief This function returns a reference to member width
 * @return Reference to member width
 */
uint32_t& sensor_msgs__Image::width()
{
    return m_width;
}

/*!
 * @brief This function copies the value in member encoding
 * @param _encoding New value to be copied in member encoding
 */
void sensor_msgs__Image::encoding(
        const std::string& _encoding)
{
    m_encoding = _encoding;
}

/*!
 * @brief This function moves the value in member encoding
 * @param _encoding New value to be moved in member encoding
 */
void sensor_msgs__Image::encoding(
        std::string&& _encoding)
{
    m_encoding = std::move(_encoding);
}

/*!
 * @brief This function returns a constant reference to member encoding
 * @return Constant reference to member encoding
 */
const std::string& sensor_msgs__Image::encoding() const
{
    return m_encoding;
}

/*!
 * @brief This function returns a reference to member encoding
 * @return Reference to member encoding
 */
std::string& sensor_msgs__Image::encoding()
{
    return m_encoding;
}
/*!
 * @brief This function sets a value in member is_bigendian
 * @param _is_bigendian New value for member is_bigendian
 */
void sensor_msgs__Image::is_bigendian(
        uint8_t _is_bigendian)
{
    m_is_bigendian = _is_bigendian;
}

/*!
 * @brief This function returns the value of member is_bigendian
 * @return Value of member is_bigendian
 */
uint8_t sensor_msgs__Image::is_bigendian() const
{
    return m_is_bigendian;
}

/*!
 * @brief This function returns a reference to member is_bigendian
 * @return Reference to member is_bigendian
 */
uint8_t& sensor_msgs__Image::is_bigendian()
{
    return m_is_bigendian;
}

/*!
 * @brief This function sets a value in member step
 * @param _step New value for member step
 */
void sensor_msgs__Image::step(
        uint32_t _step)
{
    m_step = _step;
}

/*!
 * @brief This function returns the value of member step
 * @return Value of member step
 */
uint32_t sensor_msgs__Image::step() const
{
    return m_step;
}

/*!
 * @brief This function returns a reference to member step
 * @return Reference to member step
 */
uint32_t& sensor_msgs__Image::step()
{
    return m_step;
}

/*!
 * @brief This function copies the value in member data
 * @param _data New value to be copied in member data
 */
void sensor_msgs__Image::data(
        const std::vector<uint8_t>& _data)
{
    m_data = _data;
}

/*!
 * @brief This function moves the value in member data
 * @param _data New value to be moved in member data
 */
void sensor_msgs__Image::data(
        std::vector<uint8_t>&& _data)
{
    m_data = std::move(_data);
}

/*!
 * @brief This function returns a constant reference to member data
 * @return Constant reference to member data
 */
const std::vector<uint8_t>& sensor_msgs__Image::data() const
{
    return m_data;
}

/*!
 * @brief This function returns a reference to member data
 * @return Reference to member data
 */
std::vector<uint8_t>& sensor_msgs__Image::data()
{
    return m_data;
}

size_t sensor_msgs__Image::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t current_align = current_alignment;










    return current_align;
}

bool sensor_msgs__Image::isKeyDefined()
{
    return false;
}

void sensor_msgs__Image::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
           
}

sensor_msgs__CompressedImage::sensor_msgs__CompressedImage()
{
    // m_header com.eprosima.fastdds.idl.parser.typecode.StructTypeCode@7fe8ea47

    // m_format com.eprosima.idl.parser.typecode.StringTypeCode@6ee12bac
    m_format ="";
    // m_data com.eprosima.idl.parser.typecode.SequenceTypeCode@55040f2f


}

sensor_msgs__CompressedImage::~sensor_msgs__CompressedImage()
{



}

sensor_msgs__CompressedImage::sensor_msgs__CompressedImage(
        const sensor_msgs__CompressedImage& x)
{
    m_header = x.m_header;
    m_format = x.m_format;
    m_data = x.m_data;
}

sensor_msgs__CompressedImage::sensor_msgs__CompressedImage(
        sensor_msgs__CompressedImage&& x)
{
    m_header = std::move(x.m_header);
    m_format = std::move(x.m_format);
    m_data = std::move(x.m_data);
}

sensor_msgs__CompressedImage& sensor_msgs__CompressedImage::operator =(
        const sensor_msgs__CompressedImage& x)
{

    m_header = x.m_header;
    m_format = x.m_format;
    m_data = x.m_data;

    return *this;
}

sensor_msgs__CompressedImage& sensor_msgs__CompressedImage::operator =(
        sensor_msgs__CompressedImage&& x)
{

    m_header = std::move(x.m_header);
    m_format = std::move(x.m_format);
    m_data = std::move(x.m_data);

    return *this;
}

bool sensor_msgs__CompressedImage::operator ==(
        const sensor_msgs__CompressedImage& x) const
{

    return (m_header == x.m_header && m_format == x.m_format && m_data == x.m_data);
}

bool sensor_msgs__CompressedImage::operator !=(
        const sensor_msgs__CompressedImage& x) const
{
    return !(*this == x);
}

size_t sensor_msgs__CompressedImage::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t initial_alignment = current_alignment;


    current_alignment += std_msgs__Header::getMaxCdrSerializedSize(current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 255 + 1;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    current_alignment += (100 * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);




    return current_alignment - initial_alignment;
}

size_t sensor_msgs__CompressedImage::getCdrSerializedSize(
        const sensor_msgs__CompressedImage& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += std_msgs__Header::getCdrSerializedSize(data.header(), current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.format().size() + 1;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    if (data.data().size() > 0)
    {
        current_alignment += (data.data().size() * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);
    }




    return current_alignment - initial_alignment;
}

void sensor_msgs__CompressedImage::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_header;
    scdr << m_format;
    scdr << m_data;

}

void sensor_msgs__CompressedImage::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_header;
    dcdr >> m_format;
    dcdr >> m_data;
}

/*!
 * @brief This function copies the value in member header
 * @param _header New value to be copied in member header
 */
void sensor_msgs__CompressedImage::header(
        const std_msgs__Header& _header)
{
    m_header = _header;
}

/*!
 * @brief This function moves the value in member header
 * @param _header New value to be moved in member header
 */
void sensor_msgs__CompressedImage::header(
        std_msgs__Header&& _header)
{
    m_header = std::move(_header);
}

/*!
 * @brief This function returns a constant reference to member header
 * @return Constant reference to member header
 */
const std_msgs__Header& sensor_msgs__CompressedImage::header() const
{
    return m_header;
}

/*!
 * @brief This function returns a reference to member header
 * @return Reference to member header
 */
std_msgs__Header& sensor_msgs__CompressedImage::header()
{
    return m_header;
}
/*!
 * @brief This function copies the value in member format
 * @param _format New value to be copied in member format
 */
void sensor_msgs__CompressedImage::format(
        const std::string& _format)
{
    m_format = _format;
}

/*!
 * @brief This function moves the value in member format
 * @param _format New value to be moved in member format
 */
void sensor_msgs__CompressedImage::format(
        std::string&& _format)
{
    m_format = std::move(_format);
}

/*!
 * @brief This function returns a constant reference to member format
 * @return Constant reference to member format
 */
const std::string& sensor_msgs__CompressedImage::format() const
{
    return m_format;
}

/*!
 * @brief This function returns a reference to member format
 * @return Reference to member format
 */
std::string& sensor_msgs__CompressedImage::format()
{
    return m_format;
}
/*!
 * @brief This function copies the value in member data
 * @param _data New value to be copied in member data
 */
void sensor_msgs__CompressedImage::data(
        const std::vector<uint8_t>& _data)
{
    m_data = _data;
}

/*!
 * @brief This function moves the value in member data
 * @param _data New value to be moved in member data
 */
void sensor_msgs__CompressedImage::data(
        std::vector<uint8_t>&& _data)
{
    m_data = std::move(_data);
}

/*!
 * @brief This function returns a constant reference to member data
 * @return Constant reference to member data
 */
const std::vector<uint8_t>& sensor_msgs__CompressedImage::data() const
{
    return m_data;
}

/*!
 * @brief This function returns a reference to member data
 * @return Reference to member data
 */
std::vector<uint8_t>& sensor_msgs__CompressedImage::data()
{
    return m_data;
}

size_t sensor_msgs__CompressedImage::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t current_align = current_alignment;






    return current_align;
}

bool sensor_msgs__CompressedImage::isKeyDefined()
{
    return false;
}

void sensor_msgs__CompressedImage::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
       
}

sensor_msgs__PointField::sensor_msgs__PointField()
{
    // m_name com.eprosima.idl.parser.typecode.StringTypeCode@52aa2946
    m_name ="";
    // m_offset com.eprosima.idl.parser.typecode.PrimitiveTypeCode@4de5031f
    m_offset = 0;
    // m_datatype com.eprosima.idl.parser.typecode.PrimitiveTypeCode@67e2d983
    m_datatype = 0;
    // m_count com.eprosima.idl.parser.typecode.PrimitiveTypeCode@5d47c63f
    m_count = 0;

}

sensor_msgs__PointField::~sensor_msgs__PointField()
{




}

sensor_msgs__PointField::sensor_msgs__PointField(
        const sensor_msgs__PointField& x)
{
    m_name = x.m_name;
    m_offset = x.m_offset;
    m_datatype = x.m_datatype;
    m_count = x.m_count;
}

sensor_msgs__PointField::sensor_msgs__PointField(
        sensor_msgs__PointField&& x)
{
    m_name = std::move(x.m_name);
    m_offset = x.m_offset;
    m_datatype = x.m_datatype;
    m_count = x.m_count;
}

sensor_msgs__PointField& sensor_msgs__PointField::operator =(
        const sensor_msgs__PointField& x)
{

    m_name = x.m_name;
    m_offset = x.m_offset;
    m_datatype = x.m_datatype;
    m_count = x.m_count;

    return *this;
}

sensor_msgs__PointField& sensor_msgs__PointField::operator =(
        sensor_msgs__PointField&& x)
{

    m_name = std::move(x.m_name);
    m_offset = x.m_offset;
    m_datatype = x.m_datatype;
    m_count = x.m_count;

    return *this;
}

bool sensor_msgs__PointField::operator ==(
        const sensor_msgs__PointField& x) const
{

    return (m_name == x.m_name && m_offset == x.m_offset && m_datatype == x.m_datatype && m_count == x.m_count);
}

bool sensor_msgs__PointField::operator !=(
        const sensor_msgs__PointField& x) const
{
    return !(*this == x);
}

size_t sensor_msgs__PointField::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 255 + 1;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);



    return current_alignment - initial_alignment;
}

size_t sensor_msgs__PointField::getCdrSerializedSize(
        const sensor_msgs__PointField& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.name().size() + 1;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);



    return current_alignment - initial_alignment;
}

void sensor_msgs__PointField::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_name;
    scdr << m_offset;
    scdr << m_datatype;
    scdr << m_count;

}

void sensor_msgs__PointField::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_name;
    dcdr >> m_offset;
    dcdr >> m_datatype;
    dcdr >> m_count;
}

/*!
 * @brief This function copies the value in member name
 * @param _name New value to be copied in member name
 */
void sensor_msgs__PointField::name(
        const std::string& _name)
{
    m_name = _name;
}

/*!
 * @brief This function moves the value in member name
 * @param _name New value to be moved in member name
 */
void sensor_msgs__PointField::name(
        std::string&& _name)
{
    m_name = std::move(_name);
}

/*!
 * @brief This function returns a constant reference to member name
 * @return Constant reference to member name
 */
const std::string& sensor_msgs__PointField::name() const
{
    return m_name;
}

/*!
 * @brief This function returns a reference to member name
 * @return Reference to member name
 */
std::string& sensor_msgs__PointField::name()
{
    return m_name;
}
/*!
 * @brief This function sets a value in member offset
 * @param _offset New value for member offset
 */
void sensor_msgs__PointField::offset(
        uint32_t _offset)
{
    m_offset = _offset;
}

/*!
 * @brief This function returns the value of member offset
 * @return Value of member offset
 */
uint32_t sensor_msgs__PointField::offset() const
{
    return m_offset;
}

/*!
 * @brief This function returns a reference to member offset
 * @return Reference to member offset
 */
uint32_t& sensor_msgs__PointField::offset()
{
    return m_offset;
}

/*!
 * @brief This function sets a value in member datatype
 * @param _datatype New value for member datatype
 */
void sensor_msgs__PointField::datatype(
        uint8_t _datatype)
{
    m_datatype = _datatype;
}

/*!
 * @brief This function returns the value of member datatype
 * @return Value of member datatype
 */
uint8_t sensor_msgs__PointField::datatype() const
{
    return m_datatype;
}

/*!
 * @brief This function returns a reference to member datatype
 * @return Reference to member datatype
 */
uint8_t& sensor_msgs__PointField::datatype()
{
    return m_datatype;
}

/*!
 * @brief This function sets a value in member count
 * @param _count New value for member count
 */
void sensor_msgs__PointField::count(
        uint32_t _count)
{
    m_count = _count;
}

/*!
 * @brief This function returns the value of member count
 * @return Value of member count
 */
uint32_t sensor_msgs__PointField::count() const
{
    return m_count;
}

/*!
 * @brief This function returns a reference to member count
 * @return Reference to member count
 */
uint32_t& sensor_msgs__PointField::count()
{
    return m_count;
}


size_t sensor_msgs__PointField::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t current_align = current_alignment;







    return current_align;
}

bool sensor_msgs__PointField::isKeyDefined()
{
    return false;
}

void sensor_msgs__PointField::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
        
}

sensor_msgs__PointCloud2::sensor_msgs__PointCloud2()
{
    // m_header com.eprosima.fastdds.idl.parser.typecode.StructTypeCode@7fe8ea47

    // m_height com.eprosima.idl.parser.typecode.PrimitiveTypeCode@5ea434c8
    m_height = 0;
    // m_width com.eprosima.idl.parser.typecode.PrimitiveTypeCode@3bbc39f8
    m_width = 0;
    // m_fields com.eprosima.idl.parser.typecode.SequenceTypeCode@4ae3c1cd

    // m_is_bigendian com.eprosima.idl.parser.typecode.PrimitiveTypeCode@29f69090
    m_is_bigendian = false;
    // m_point_step com.eprosima.idl.parser.typecode.PrimitiveTypeCode@568bf312
    m_point_step = 0;
    // m_row_step com.eprosima.idl.parser.typecode.PrimitiveTypeCode@ca263c2
    m_row_step = 0;
    // m_data com.eprosima.idl.parser.typecode.SequenceTypeCode@589b3632

    // m_is_dense com.eprosima.idl.parser.typecode.PrimitiveTypeCode@45f45fa1
    m_is_dense = false;

}

sensor_msgs__PointCloud2::~sensor_msgs__PointCloud2()
{









}

sensor_msgs__PointCloud2::sensor_msgs__PointCloud2(
        const sensor_msgs__PointCloud2& x)
{
    m_header = x.m_header;
    m_height = x.m_height;
    m_width = x.m_width;
    m_fields = x.m_fields;
    m_is_bigendian = x.m_is_bigendian;
    m_point_step = x.m_point_step;
    m_row_step = x.m_row_step;
    m_data = x.m_data;
    m_is_dense = x.m_is_dense;
}

sensor_msgs__PointCloud2::sensor_msgs__PointCloud2(
        sensor_msgs__PointCloud2&& x)
{
    m_header = std::move(x.m_header);
    m_height = x.m_height;
    m_width = x.m_width;
    m_fields = std::move(x.m_fields);
    m_is_bigendian = x.m_is_bigendian;
    m_point_step = x.m_point_step;
    m_row_step = x.m_row_step;
    m_data = std::move(x.m_data);
    m_is_dense = x.m_is_dense;
}

sensor_msgs__PointCloud2& sensor_msgs__PointCloud2::operator =(
        const sensor_msgs__PointCloud2& x)
{

    m_header = x.m_header;
    m_height = x.m_height;
    m_width = x.m_width;
    m_fields = x.m_fields;
    m_is_bigendian = x.m_is_bigendian;
    m_point_step = x.m_point_step;
    m_row_step = x.m_row_step;
    m_data = x.m_data;
    m_is_dense = x.m_is_dense;

    return *this;
}

sensor_msgs__PointCloud2& sensor_msgs__PointCloud2::operator =(
        sensor_msgs__PointCloud2&& x)
{

    m_header = std::move(x.m_header);
    m_height = x.m_height;
    m_width = x.m_width;
    m_fields = std::move(x.m_fields);
    m_is_bigendian = x.m_is_bigendian;
    m_point_step = x.m_point_step;
    m_row_step = x.m_row_step;
    m_data = std::move(x.m_data);
    m_is_dense = x.m_is_dense;

    return *this;
}

bool sensor_msgs__PointCloud2::operator ==(
        const sensor_msgs__PointCloud2& x) const
{

    return (m_header == x.m_header && m_height == x.m_height && m_width == x.m_width && m_fields == x.m_fields && m_is_bigendian == x.m_is_bigendian && m_point_step == x.m_point_step && m_row_step == x.m_row_step && m_data == x.m_data && m_is_dense == x.m_is_dense);
}

bool sensor_msgs__PointCloud2::operator !=(
        const sensor_msgs__PointCloud2& x) const
{
    return !(*this == x);
}

size_t sensor_msgs__PointCloud2::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t initial_alignment = current_alignment;


    current_alignment += std_msgs__Header::getMaxCdrSerializedSize(current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    for(size_t a = 0; a < 100; ++a)
    {
        current_alignment += sensor_msgs__PointField::getMaxCdrSerializedSize(current_alignment);}

    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    current_alignment += (100 * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);



    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);



    return current_alignment - initial_alignment;
}

size_t sensor_msgs__PointCloud2::getCdrSerializedSize(
        const sensor_msgs__PointCloud2& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += std_msgs__Header::getCdrSerializedSize(data.header(), current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    for(size_t a = 0; a < data.fields().size(); ++a)
    {
        current_alignment += sensor_msgs__PointField::getCdrSerializedSize(data.fields().at(a), current_alignment);}

    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    if (data.data().size() > 0)
    {
        current_alignment += (data.data().size() * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);
    }



    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);



    return current_alignment - initial_alignment;
}

void sensor_msgs__PointCloud2::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_header;
    scdr << m_height;
    scdr << m_width;
    scdr << m_fields;
    scdr << m_is_bigendian;
    scdr << m_point_step;
    scdr << m_row_step;
    scdr << m_data;
    scdr << m_is_dense;

}

void sensor_msgs__PointCloud2::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_header;
    dcdr >> m_height;
    dcdr >> m_width;
    dcdr >> m_fields;
    dcdr >> m_is_bigendian;
    dcdr >> m_point_step;
    dcdr >> m_row_step;
    dcdr >> m_data;
    dcdr >> m_is_dense;
}

/*!
 * @brief This function copies the value in member header
 * @param _header New value to be copied in member header
 */
void sensor_msgs__PointCloud2::header(
        const std_msgs__Header& _header)
{
    m_header = _header;
}

/*!
 * @brief This function moves the value in member header
 * @param _header New value to be moved in member header
 */
void sensor_msgs__PointCloud2::header(
        std_msgs__Header&& _header)
{
    m_header = std::move(_header);
}

/*!
 * @brief This function returns a constant reference to member header
 * @return Constant reference to member header
 */
const std_msgs__Header& sensor_msgs__PointCloud2::header() const
{
    return m_header;
}

/*!
 * @brief This function returns a reference to member header
 * @return Reference to member header
 */
std_msgs__Header& sensor_msgs__PointCloud2::header()
{
    return m_header;
}
/*!
 * @brief This function sets a value in member height
 * @param _height New value for member height
 */
void sensor_msgs__PointCloud2::height(
        uint32_t _height)
{
    m_height = _height;
}

/*!
 * @brief This function returns the value of member height
 * @return Value of member height
 */
uint32_t sensor_msgs__PointCloud2::height() const
{
    return m_height;
}

/*!
 * @brief This function returns a reference to member height
 * @return Reference to member height
 */
uint32_t& sensor_msgs__PointCloud2::height()
{
    return m_height;
}

/*!
 * @brief This function sets a value in member width
 * @param _width New value for member width
 */
void sensor_msgs__PointCloud2::width(
        uint32_t _width)
{
    m_width = _width;
}

/*!
 * @brief This function returns the value of member width
 * @return Value of member width
 */
uint32_t sensor_msgs__PointCloud2::width() const
{
    return m_width;
}

/*!
 * @brief This function returns a reference to member width
 * @return Reference to member width
 */
uint32_t& sensor_msgs__PointCloud2::width()
{
    return m_width;
}

/*!
 * @brief This function copies the value in member fields
 * @param _fields New value to be copied in member fields
 */
void sensor_msgs__PointCloud2::fields(
        const std::vector<sensor_msgs__PointField>& _fields)
{
    m_fields = _fields;
}

/*!
 * @brief This function moves the value in member fields
 * @param _fields New value to be moved in member fields
 */
void sensor_msgs__PointCloud2::fields(
        std::vector<sensor_msgs__PointField>&& _fields)
{
    m_fields = std::move(_fields);
}

/*!
 * @brief This function returns a constant reference to member fields
 * @return Constant reference to member fields
 */
const std::vector<sensor_msgs__PointField>& sensor_msgs__PointCloud2::fields() const
{
    return m_fields;
}

/*!
 * @brief This function returns a reference to member fields
 * @return Reference to member fields
 */
std::vector<sensor_msgs__PointField>& sensor_msgs__PointCloud2::fields()
{
    return m_fields;
}
/*!
 * @brief This function sets a value in member is_bigendian
 * @param _is_bigendian New value for member is_bigendian
 */
void sensor_msgs__PointCloud2::is_bigendian(
        bool _is_bigendian)
{
    m_is_bigendian = _is_bigendian;
}

/*!
 * @brief This function returns the value of member is_bigendian
 * @return Value of member is_bigendian
 */
bool sensor_msgs__PointCloud2::is_bigendian() const
{
    return m_is_bigendian;
}

/*!
 * @brief This function returns a reference to member is_bigendian
 * @return Reference to member is_bigendian
 */
bool& sensor_msgs__PointCloud2::is_bigendian()
{
    return m_is_bigendian;
}

/*!
 * @brief This function sets a value in member point_step
 * @param _point_step New value for member point_step
 */
void sensor_msgs__PointCloud2::point_step(
        uint32_t _point_step)
{
    m_point_step = _point_step;
}

/*!
 * @brief This function returns the value of member point_step
 * @return Value of member point_step
 */
uint32_t sensor_msgs__PointCloud2::point_step() const
{
    return m_point_step;
}

/*!
 * @brief This function returns a reference to member point_step
 * @return Reference to member point_step
 */
uint32_t& sensor_msgs__PointCloud2::point_step()
{
    return m_point_step;
}

/*!
 * @brief This function sets a value in member row_step
 * @param _row_step New value for member row_step
 */
void sensor_msgs__PointCloud2::row_step(
        uint32_t _row_step)
{
    m_row_step = _row_step;
}

/*!
 * @brief This function returns the value of member row_step
 * @return Value of member row_step
 */
uint32_t sensor_msgs__PointCloud2::row_step() const
{
    return m_row_step;
}

/*!
 * @brief This function returns a reference to member row_step
 * @return Reference to member row_step
 */
uint32_t& sensor_msgs__PointCloud2::row_step()
{
    return m_row_step;
}

/*!
 * @brief This function copies the value in member data
 * @param _data New value to be copied in member data
 */
void sensor_msgs__PointCloud2::data(
        const std::vector<uint8_t>& _data)
{
    m_data = _data;
}

/*!
 * @brief This function moves the value in member data
 * @param _data New value to be moved in member data
 */
void sensor_msgs__PointCloud2::data(
        std::vector<uint8_t>&& _data)
{
    m_data = std::move(_data);
}

/*!
 * @brief This function returns a constant reference to member data
 * @return Constant reference to member data
 */
const std::vector<uint8_t>& sensor_msgs__PointCloud2::data() const
{
    return m_data;
}

/*!
 * @brief This function returns a reference to member data
 * @return Reference to member data
 */
std::vector<uint8_t>& sensor_msgs__PointCloud2::data()
{
    return m_data;
}
/*!
 * @brief This function sets a value in member is_dense
 * @param _is_dense New value for member is_dense
 */
void sensor_msgs__PointCloud2::is_dense(
        bool _is_dense)
{
    m_is_dense = _is_dense;
}

/*!
 * @brief This function returns the value of member is_dense
 * @return Value of member is_dense
 */
bool sensor_msgs__PointCloud2::is_dense() const
{
    return m_is_dense;
}

/*!
 * @brief This function returns a reference to member is_dense
 * @return Reference to member is_dense
 */
bool& sensor_msgs__PointCloud2::is_dense()
{
    return m_is_dense;
}


size_t sensor_msgs__PointCloud2::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t current_align = current_alignment;












    return current_align;
}

bool sensor_msgs__PointCloud2::isKeyDefined()
{
    return false;
}

void sensor_msgs__PointCloud2::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
             
}

geometry_msgs__Point::geometry_msgs__Point()
{
    // m_x com.eprosima.idl.parser.typecode.PrimitiveTypeCode@52e677af
    m_x = 0.0;
    // m_y com.eprosima.idl.parser.typecode.PrimitiveTypeCode@35083305
    m_y = 0.0;
    // m_z com.eprosima.idl.parser.typecode.PrimitiveTypeCode@8e0379d
    m_z = 0.0;

}

geometry_msgs__Point::~geometry_msgs__Point()
{



}

geometry_msgs__Point::geometry_msgs__Point(
        const geometry_msgs__Point& x)
{
    m_x = x.m_x;
    m_y = x.m_y;
    m_z = x.m_z;
}

geometry_msgs__Point::geometry_msgs__Point(
        geometry_msgs__Point&& x)
{
    m_x = x.m_x;
    m_y = x.m_y;
    m_z = x.m_z;
}

geometry_msgs__Point& geometry_msgs__Point::operator =(
        const geometry_msgs__Point& x)
{

    m_x = x.m_x;
    m_y = x.m_y;
    m_z = x.m_z;

    return *this;
}

geometry_msgs__Point& geometry_msgs__Point::operator =(
        geometry_msgs__Point&& x)
{

    m_x = x.m_x;
    m_y = x.m_y;
    m_z = x.m_z;

    return *this;
}

bool geometry_msgs__Point::operator ==(
        const geometry_msgs__Point& x) const
{

    return (m_x == x.m_x && m_y == x.m_y && m_z == x.m_z);
}

bool geometry_msgs__Point::operator !=(
        const geometry_msgs__Point& x) const
{
    return !(*this == x);
}

size_t geometry_msgs__Point::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t initial_alignment = current_alignment;


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);



    return current_alignment - initial_alignment;
}

size_t geometry_msgs__Point::getCdrSerializedSize(
        const geometry_msgs__Point& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);



    return current_alignment - initial_alignment;
}

void geometry_msgs__Point::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_x;
    scdr << m_y;
    scdr << m_z;

}

void geometry_msgs__Point::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_x;
    dcdr >> m_y;
    dcdr >> m_z;
}

/*!
 * @brief This function sets a value in member x
 * @param _x New value for member x
 */
void geometry_msgs__Point::x(
        double _x)
{
    m_x = _x;
}

/*!
 * @brief This function returns the value of member x
 * @return Value of member x
 */
double geometry_msgs__Point::x() const
{
    return m_x;
}

/*!
 * @brief This function returns a reference to member x
 * @return Reference to member x
 */
double& geometry_msgs__Point::x()
{
    return m_x;
}

/*!
 * @brief This function sets a value in member y
 * @param _y New value for member y
 */
void geometry_msgs__Point::y(
        double _y)
{
    m_y = _y;
}

/*!
 * @brief This function returns the value of member y
 * @return Value of member y
 */
double geometry_msgs__Point::y() const
{
    return m_y;
}

/*!
 * @brief This function returns a reference to member y
 * @return Reference to member y
 */
double& geometry_msgs__Point::y()
{
    return m_y;
}

/*!
 * @brief This function sets a value in member z
 * @param _z New value for member z
 */
void geometry_msgs__Point::z(
        double _z)
{
    m_z = _z;
}

/*!
 * @brief This function returns the value of member z
 * @return Value of member z
 */
double geometry_msgs__Point::z() const
{
    return m_z;
}

/*!
 * @brief This function returns a reference to member z
 * @return Reference to member z
 */
double& geometry_msgs__Point::z()
{
    return m_z;
}


size_t geometry_msgs__Point::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t current_align = current_alignment;






    return current_align;
}

bool geometry_msgs__Point::isKeyDefined()
{
    return false;
}

void geometry_msgs__Point::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
       
}

visualization_msgs__ImageMarker::visualization_msgs__ImageMarker()
{
    // m_header com.eprosima.fastdds.idl.parser.typecode.StructTypeCode@7fe8ea47

    // m_ns com.eprosima.idl.parser.typecode.StringTypeCode@341b80b2
    m_ns ="";
    // m_id com.eprosima.idl.parser.typecode.PrimitiveTypeCode@55a1c291
    m_id = 0;
    // m_type com.eprosima.idl.parser.typecode.PrimitiveTypeCode@2145433b
    m_type = 0;
    // m_action com.eprosima.idl.parser.typecode.PrimitiveTypeCode@2890c451
    m_action = 0;
    // m_position com.eprosima.fastdds.idl.parser.typecode.StructTypeCode@40e6dfe1

    // m_scale com.eprosima.idl.parser.typecode.PrimitiveTypeCode@1b083826
    m_scale = 0.0;
    // m_outline_color com.eprosima.fastdds.idl.parser.typecode.StructTypeCode@105fece7

    // m_filled com.eprosima.idl.parser.typecode.PrimitiveTypeCode@3ec300f1
    m_filled = 0;
    // m_fill_color com.eprosima.fastdds.idl.parser.typecode.StructTypeCode@105fece7

    // m_lifetime com.eprosima.fastdds.idl.parser.typecode.StructTypeCode@482cd91f

    // m_points com.eprosima.idl.parser.typecode.SequenceTypeCode@123f1134

    // m_outline_colors com.eprosima.idl.parser.typecode.SequenceTypeCode@7d68ef40


}

visualization_msgs__ImageMarker::~visualization_msgs__ImageMarker()
{













}

visualization_msgs__ImageMarker::visualization_msgs__ImageMarker(
        const visualization_msgs__ImageMarker& x)
{
    m_header = x.m_header;
    m_ns = x.m_ns;
    m_id = x.m_id;
    m_type = x.m_type;
    m_action = x.m_action;
    m_position = x.m_position;
    m_scale = x.m_scale;
    m_outline_color = x.m_outline_color;
    m_filled = x.m_filled;
    m_fill_color = x.m_fill_color;
    m_lifetime = x.m_lifetime;
    m_points = x.m_points;
    m_outline_colors = x.m_outline_colors;
}

visualization_msgs__ImageMarker::visualization_msgs__ImageMarker(
        visualization_msgs__ImageMarker&& x)
{
    m_header = std::move(x.m_header);
    m_ns = std::move(x.m_ns);
    m_id = x.m_id;
    m_type = x.m_type;
    m_action = x.m_action;
    m_position = std::move(x.m_position);
    m_scale = x.m_scale;
    m_outline_color = std::move(x.m_outline_color);
    m_filled = x.m_filled;
    m_fill_color = std::move(x.m_fill_color);
    m_lifetime = std::move(x.m_lifetime);
    m_points = std::move(x.m_points);
    m_outline_colors = std::move(x.m_outline_colors);
}

visualization_msgs__ImageMarker& visualization_msgs__ImageMarker::operator =(
        const visualization_msgs__ImageMarker& x)
{

    m_header = x.m_header;
    m_ns = x.m_ns;
    m_id = x.m_id;
    m_type = x.m_type;
    m_action = x.m_action;
    m_position = x.m_position;
    m_scale = x.m_scale;
    m_outline_color = x.m_outline_color;
    m_filled = x.m_filled;
    m_fill_color = x.m_fill_color;
    m_lifetime = x.m_lifetime;
    m_points = x.m_points;
    m_outline_colors = x.m_outline_colors;

    return *this;
}

visualization_msgs__ImageMarker& visualization_msgs__ImageMarker::operator =(
        visualization_msgs__ImageMarker&& x)
{

    m_header = std::move(x.m_header);
    m_ns = std::move(x.m_ns);
    m_id = x.m_id;
    m_type = x.m_type;
    m_action = x.m_action;
    m_position = std::move(x.m_position);
    m_scale = x.m_scale;
    m_outline_color = std::move(x.m_outline_color);
    m_filled = x.m_filled;
    m_fill_color = std::move(x.m_fill_color);
    m_lifetime = std::move(x.m_lifetime);
    m_points = std::move(x.m_points);
    m_outline_colors = std::move(x.m_outline_colors);

    return *this;
}

bool visualization_msgs__ImageMarker::operator ==(
        const visualization_msgs__ImageMarker& x) const
{

    return (m_header == x.m_header && m_ns == x.m_ns && m_id == x.m_id && m_type == x.m_type && m_action == x.m_action && m_position == x.m_position && m_scale == x.m_scale && m_outline_color == x.m_outline_color && m_filled == x.m_filled && m_fill_color == x.m_fill_color && m_lifetime == x.m_lifetime && m_points == x.m_points && m_outline_colors == x.m_outline_colors);
}

bool visualization_msgs__ImageMarker::operator !=(
        const visualization_msgs__ImageMarker& x) const
{
    return !(*this == x);
}

size_t visualization_msgs__ImageMarker::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t initial_alignment = current_alignment;


    current_alignment += std_msgs__Header::getMaxCdrSerializedSize(current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 255 + 1;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += geometry_msgs__Point::getMaxCdrSerializedSize(current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += std_msgs__ColorRGBA::getMaxCdrSerializedSize(current_alignment);
    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    current_alignment += std_msgs__ColorRGBA::getMaxCdrSerializedSize(current_alignment);
    current_alignment += builtins__Duration::getMaxCdrSerializedSize(current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    for(size_t a = 0; a < 100; ++a)
    {
        current_alignment += geometry_msgs__Point::getMaxCdrSerializedSize(current_alignment);}

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    for(size_t a = 0; a < 100; ++a)
    {
        current_alignment += std_msgs__ColorRGBA::getMaxCdrSerializedSize(current_alignment);}


    return current_alignment - initial_alignment;
}

size_t visualization_msgs__ImageMarker::getCdrSerializedSize(
        const visualization_msgs__ImageMarker& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += std_msgs__Header::getCdrSerializedSize(data.header(), current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.ns().size() + 1;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += geometry_msgs__Point::getCdrSerializedSize(data.position(), current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += std_msgs__ColorRGBA::getCdrSerializedSize(data.outline_color(), current_alignment);
    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    current_alignment += std_msgs__ColorRGBA::getCdrSerializedSize(data.fill_color(), current_alignment);
    current_alignment += builtins__Duration::getCdrSerializedSize(data.lifetime(), current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    for(size_t a = 0; a < data.points().size(); ++a)
    {
        current_alignment += geometry_msgs__Point::getCdrSerializedSize(data.points().at(a), current_alignment);}

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    for(size_t a = 0; a < data.outline_colors().size(); ++a)
    {
        current_alignment += std_msgs__ColorRGBA::getCdrSerializedSize(data.outline_colors().at(a), current_alignment);}


    return current_alignment - initial_alignment;
}

void visualization_msgs__ImageMarker::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_header;
    scdr << m_ns;
    scdr << m_id;
    scdr << m_type;
    scdr << m_action;
    scdr << m_position;
    scdr << m_scale;
    scdr << m_outline_color;
    scdr << m_filled;
    scdr << m_fill_color;
    scdr << m_lifetime;
    scdr << m_points;
    scdr << m_outline_colors;

}

void visualization_msgs__ImageMarker::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_header;
    dcdr >> m_ns;
    dcdr >> m_id;
    dcdr >> m_type;
    dcdr >> m_action;
    dcdr >> m_position;
    dcdr >> m_scale;
    dcdr >> m_outline_color;
    dcdr >> m_filled;
    dcdr >> m_fill_color;
    dcdr >> m_lifetime;
    dcdr >> m_points;
    dcdr >> m_outline_colors;
}

/*!
 * @brief This function copies the value in member header
 * @param _header New value to be copied in member header
 */
void visualization_msgs__ImageMarker::header(
        const std_msgs__Header& _header)
{
    m_header = _header;
}

/*!
 * @brief This function moves the value in member header
 * @param _header New value to be moved in member header
 */
void visualization_msgs__ImageMarker::header(
        std_msgs__Header&& _header)
{
    m_header = std::move(_header);
}

/*!
 * @brief This function returns a constant reference to member header
 * @return Constant reference to member header
 */
const std_msgs__Header& visualization_msgs__ImageMarker::header() const
{
    return m_header;
}

/*!
 * @brief This function returns a reference to member header
 * @return Reference to member header
 */
std_msgs__Header& visualization_msgs__ImageMarker::header()
{
    return m_header;
}
/*!
 * @brief This function copies the value in member ns
 * @param _ns New value to be copied in member ns
 */
void visualization_msgs__ImageMarker::ns(
        const std::string& _ns)
{
    m_ns = _ns;
}

/*!
 * @brief This function moves the value in member ns
 * @param _ns New value to be moved in member ns
 */
void visualization_msgs__ImageMarker::ns(
        std::string&& _ns)
{
    m_ns = std::move(_ns);
}

/*!
 * @brief This function returns a constant reference to member ns
 * @return Constant reference to member ns
 */
const std::string& visualization_msgs__ImageMarker::ns() const
{
    return m_ns;
}

/*!
 * @brief This function returns a reference to member ns
 * @return Reference to member ns
 */
std::string& visualization_msgs__ImageMarker::ns()
{
    return m_ns;
}
/*!
 * @brief This function sets a value in member id
 * @param _id New value for member id
 */
void visualization_msgs__ImageMarker::id(
        int32_t _id)
{
    m_id = _id;
}

/*!
 * @brief This function returns the value of member id
 * @return Value of member id
 */
int32_t visualization_msgs__ImageMarker::id() const
{
    return m_id;
}

/*!
 * @brief This function returns a reference to member id
 * @return Reference to member id
 */
int32_t& visualization_msgs__ImageMarker::id()
{
    return m_id;
}

/*!
 * @brief This function sets a value in member type
 * @param _type New value for member type
 */
void visualization_msgs__ImageMarker::type(
        int32_t _type)
{
    m_type = _type;
}

/*!
 * @brief This function returns the value of member type
 * @return Value of member type
 */
int32_t visualization_msgs__ImageMarker::type() const
{
    return m_type;
}

/*!
 * @brief This function returns a reference to member type
 * @return Reference to member type
 */
int32_t& visualization_msgs__ImageMarker::type()
{
    return m_type;
}

/*!
 * @brief This function sets a value in member action
 * @param _action New value for member action
 */
void visualization_msgs__ImageMarker::action(
        int32_t _action)
{
    m_action = _action;
}

/*!
 * @brief This function returns the value of member action
 * @return Value of member action
 */
int32_t visualization_msgs__ImageMarker::action() const
{
    return m_action;
}

/*!
 * @brief This function returns a reference to member action
 * @return Reference to member action
 */
int32_t& visualization_msgs__ImageMarker::action()
{
    return m_action;
}

/*!
 * @brief This function copies the value in member position
 * @param _position New value to be copied in member position
 */
void visualization_msgs__ImageMarker::position(
        const geometry_msgs__Point& _position)
{
    m_position = _position;
}

/*!
 * @brief This function moves the value in member position
 * @param _position New value to be moved in member position
 */
void visualization_msgs__ImageMarker::position(
        geometry_msgs__Point&& _position)
{
    m_position = std::move(_position);
}

/*!
 * @brief This function returns a constant reference to member position
 * @return Constant reference to member position
 */
const geometry_msgs__Point& visualization_msgs__ImageMarker::position() const
{
    return m_position;
}

/*!
 * @brief This function returns a reference to member position
 * @return Reference to member position
 */
geometry_msgs__Point& visualization_msgs__ImageMarker::position()
{
    return m_position;
}
/*!
 * @brief This function sets a value in member scale
 * @param _scale New value for member scale
 */
void visualization_msgs__ImageMarker::scale(
        float _scale)
{
    m_scale = _scale;
}

/*!
 * @brief This function returns the value of member scale
 * @return Value of member scale
 */
float visualization_msgs__ImageMarker::scale() const
{
    return m_scale;
}

/*!
 * @brief This function returns a reference to member scale
 * @return Reference to member scale
 */
float& visualization_msgs__ImageMarker::scale()
{
    return m_scale;
}

/*!
 * @brief This function copies the value in member outline_color
 * @param _outline_color New value to be copied in member outline_color
 */
void visualization_msgs__ImageMarker::outline_color(
        const std_msgs__ColorRGBA& _outline_color)
{
    m_outline_color = _outline_color;
}

/*!
 * @brief This function moves the value in member outline_color
 * @param _outline_color New value to be moved in member outline_color
 */
void visualization_msgs__ImageMarker::outline_color(
        std_msgs__ColorRGBA&& _outline_color)
{
    m_outline_color = std::move(_outline_color);
}

/*!
 * @brief This function returns a constant reference to member outline_color
 * @return Constant reference to member outline_color
 */
const std_msgs__ColorRGBA& visualization_msgs__ImageMarker::outline_color() const
{
    return m_outline_color;
}

/*!
 * @brief This function returns a reference to member outline_color
 * @return Reference to member outline_color
 */
std_msgs__ColorRGBA& visualization_msgs__ImageMarker::outline_color()
{
    return m_outline_color;
}
/*!
 * @brief This function sets a value in member filled
 * @param _filled New value for member filled
 */
void visualization_msgs__ImageMarker::filled(
        uint8_t _filled)
{
    m_filled = _filled;
}

/*!
 * @brief This function returns the value of member filled
 * @return Value of member filled
 */
uint8_t visualization_msgs__ImageMarker::filled() const
{
    return m_filled;
}

/*!
 * @brief This function returns a reference to member filled
 * @return Reference to member filled
 */
uint8_t& visualization_msgs__ImageMarker::filled()
{
    return m_filled;
}

/*!
 * @brief This function copies the value in member fill_color
 * @param _fill_color New value to be copied in member fill_color
 */
void visualization_msgs__ImageMarker::fill_color(
        const std_msgs__ColorRGBA& _fill_color)
{
    m_fill_color = _fill_color;
}

/*!
 * @brief This function moves the value in member fill_color
 * @param _fill_color New value to be moved in member fill_color
 */
void visualization_msgs__ImageMarker::fill_color(
        std_msgs__ColorRGBA&& _fill_color)
{
    m_fill_color = std::move(_fill_color);
}

/*!
 * @brief This function returns a constant reference to member fill_color
 * @return Constant reference to member fill_color
 */
const std_msgs__ColorRGBA& visualization_msgs__ImageMarker::fill_color() const
{
    return m_fill_color;
}

/*!
 * @brief This function returns a reference to member fill_color
 * @return Reference to member fill_color
 */
std_msgs__ColorRGBA& visualization_msgs__ImageMarker::fill_color()
{
    return m_fill_color;
}
/*!
 * @brief This function copies the value in member lifetime
 * @param _lifetime New value to be copied in member lifetime
 */
void visualization_msgs__ImageMarker::lifetime(
        const builtins__Duration& _lifetime)
{
    m_lifetime = _lifetime;
}

/*!
 * @brief This function moves the value in member lifetime
 * @param _lifetime New value to be moved in member lifetime
 */
void visualization_msgs__ImageMarker::lifetime(
        builtins__Duration&& _lifetime)
{
    m_lifetime = std::move(_lifetime);
}

/*!
 * @brief This function returns a constant reference to member lifetime
 * @return Constant reference to member lifetime
 */
const builtins__Duration& visualization_msgs__ImageMarker::lifetime() const
{
    return m_lifetime;
}

/*!
 * @brief This function returns a reference to member lifetime
 * @return Reference to member lifetime
 */
builtins__Duration& visualization_msgs__ImageMarker::lifetime()
{
    return m_lifetime;
}
/*!
 * @brief This function copies the value in member points
 * @param _points New value to be copied in member points
 */
void visualization_msgs__ImageMarker::points(
        const std::vector<geometry_msgs__Point>& _points)
{
    m_points = _points;
}

/*!
 * @brief This function moves the value in member points
 * @param _points New value to be moved in member points
 */
void visualization_msgs__ImageMarker::points(
        std::vector<geometry_msgs__Point>&& _points)
{
    m_points = std::move(_points);
}

/*!
 * @brief This function returns a constant reference to member points
 * @return Constant reference to member points
 */
const std::vector<geometry_msgs__Point>& visualization_msgs__ImageMarker::points() const
{
    return m_points;
}

/*!
 * @brief This function returns a reference to member points
 * @return Reference to member points
 */
std::vector<geometry_msgs__Point>& visualization_msgs__ImageMarker::points()
{
    return m_points;
}
/*!
 * @brief This function copies the value in member outline_colors
 * @param _outline_colors New value to be copied in member outline_colors
 */
void visualization_msgs__ImageMarker::outline_colors(
        const std::vector<std_msgs__ColorRGBA>& _outline_colors)
{
    m_outline_colors = _outline_colors;
}

/*!
 * @brief This function moves the value in member outline_colors
 * @param _outline_colors New value to be moved in member outline_colors
 */
void visualization_msgs__ImageMarker::outline_colors(
        std::vector<std_msgs__ColorRGBA>&& _outline_colors)
{
    m_outline_colors = std::move(_outline_colors);
}

/*!
 * @brief This function returns a constant reference to member outline_colors
 * @return Constant reference to member outline_colors
 */
const std::vector<std_msgs__ColorRGBA>& visualization_msgs__ImageMarker::outline_colors() const
{
    return m_outline_colors;
}

/*!
 * @brief This function returns a reference to member outline_colors
 * @return Reference to member outline_colors
 */
std::vector<std_msgs__ColorRGBA>& visualization_msgs__ImageMarker::outline_colors()
{
    return m_outline_colors;
}

size_t visualization_msgs__ImageMarker::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t current_align = current_alignment;
















    return current_align;
}

bool visualization_msgs__ImageMarker::isKeyDefined()
{
    return false;
}

void visualization_msgs__ImageMarker::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
                 
}

foxglove_msgs__ImageMarkerArray::foxglove_msgs__ImageMarkerArray()
{
    // m_markers com.eprosima.idl.parser.typecode.SequenceTypeCode@5b0abc94


}

foxglove_msgs__ImageMarkerArray::~foxglove_msgs__ImageMarkerArray()
{
}

foxglove_msgs__ImageMarkerArray::foxglove_msgs__ImageMarkerArray(
        const foxglove_msgs__ImageMarkerArray& x)
{
    m_markers = x.m_markers;
}

foxglove_msgs__ImageMarkerArray::foxglove_msgs__ImageMarkerArray(
        foxglove_msgs__ImageMarkerArray&& x)
{
    m_markers = std::move(x.m_markers);
}

foxglove_msgs__ImageMarkerArray& foxglove_msgs__ImageMarkerArray::operator =(
        const foxglove_msgs__ImageMarkerArray& x)
{

    m_markers = x.m_markers;

    return *this;
}

foxglove_msgs__ImageMarkerArray& foxglove_msgs__ImageMarkerArray::operator =(
        foxglove_msgs__ImageMarkerArray&& x)
{

    m_markers = std::move(x.m_markers);

    return *this;
}

bool foxglove_msgs__ImageMarkerArray::operator ==(
        const foxglove_msgs__ImageMarkerArray& x) const
{

    return (m_markers == x.m_markers);
}

bool foxglove_msgs__ImageMarkerArray::operator !=(
        const foxglove_msgs__ImageMarkerArray& x) const
{
    return !(*this == x);
}

size_t foxglove_msgs__ImageMarkerArray::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    for(size_t a = 0; a < 100; ++a)
    {
        current_alignment += visualization_msgs__ImageMarker::getMaxCdrSerializedSize(current_alignment);}

    return current_alignment - initial_alignment;
}

size_t foxglove_msgs__ImageMarkerArray::getCdrSerializedSize(
        const foxglove_msgs__ImageMarkerArray& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    for(size_t a = 0; a < data.markers().size(); ++a)
    {
        current_alignment += visualization_msgs__ImageMarker::getCdrSerializedSize(data.markers().at(a), current_alignment);}

    return current_alignment - initial_alignment;
}

void foxglove_msgs__ImageMarkerArray::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_markers;
}

void foxglove_msgs__ImageMarkerArray::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_markers;}

/*!
 * @brief This function copies the value in member markers
 * @param _markers New value to be copied in member markers
 */
void foxglove_msgs__ImageMarkerArray::markers(
        const std::vector<visualization_msgs__ImageMarker>& _markers)
{
    m_markers = _markers;
}

/*!
 * @brief This function moves the value in member markers
 * @param _markers New value to be moved in member markers
 */
void foxglove_msgs__ImageMarkerArray::markers(
        std::vector<visualization_msgs__ImageMarker>&& _markers)
{
    m_markers = std::move(_markers);
}

/*!
 * @brief This function returns a constant reference to member markers
 * @return Constant reference to member markers
 */
const std::vector<visualization_msgs__ImageMarker>& foxglove_msgs__ImageMarkerArray::markers() const
{
    return m_markers;
}

/*!
 * @brief This function returns a reference to member markers
 * @return Reference to member markers
 */
std::vector<visualization_msgs__ImageMarker>& foxglove_msgs__ImageMarkerArray::markers()
{
    return m_markers;
}

size_t foxglove_msgs__ImageMarkerArray::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t current_align = current_alignment;



    return current_align;
}

bool foxglove_msgs__ImageMarkerArray::isKeyDefined()
{
    return false;
}

void foxglove_msgs__ImageMarkerArray::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
     
}
